/* This file was automatically generated. Do not edit! */
char init_scm[] = 
 "(define call/cc call-with-current-continuation)\n"
 "(define (list . x) x)\n"
 "(define (map proc . lists)\n"
 "(letrec\n"
 "((mapcar\n"
 "(lambda (f x)\n"
 "(if (null? x)\n"
 "'()\n"
 "(cons (f (car x)) (mapcar f (cdr x))))))\n"
 "(car-of (lambda (x) (mapcar car x)))\n"
 "(cdr-of (lambda (x) (mapcar cdr x)))\n"
 "(null-of? (lambda (x) (memq #t (mapcar null? x))))\n"
 "(map2\n"
 "(lambda (lists r)\n"
 "(if (null-of? lists)\n"
 "(reverse r)\n"
 "(map2 (cdr-of lists)\n"
 "(cons (apply proc (car-of lists)) r))))))\n"
 "(map2 lists '())))\n"
 "(define (for-each proc . lists)\n"
 "(apply map proc lists)\n"
 "#t)\n"
 "(define (equal? x y)\n"
 "(cond ((eq? x y) #t)\n"
 "((string? x)\n"
 "(and (string? y)\n"
 "(string=? x y)))\n"
 "((pair? x)\n"
 "(and (pair? y)\n"
 "(equal? (car x) (car y))\n"
 "(equal? (cdr x) (cdr y))))\n"
 "(else\n"
 "(eqv? x y))))\n"
 "(define (member obj lst)\n"
 "(let loop ((lst lst))\n"
 "(cond ((null? lst)\n"
 "#f)\n"
 "((equal? obj (car lst))\n"
 "lst)\n"
 "(else\n"
 "(loop (cdr lst))))))\n"
 "(define (assoc obj lst)\n"
 "(let loop ((lst lst))\n"
 "(cond ((null? lst)\n"
 "#f)\n"
 "((equal? obj (caar lst))\n"
 "(car lst))\n"
 "(else\n"
 "(loop (cdr lst))))))\n"
 "(define (string . x) (list->string x))\n"
 "(define (string>? a b) (string<? b a))\n"
 "(define (string<=? a b) (not (string>? a b)))\n"
 "(define (string>=? a b) (not (string<? a b)))\n"
 "(define (string-ci>? a b) (string-ci<? b a))\n"
 "(define (string-ci<=? a b) (not (string-ci>? a b)))\n"
 "(define (string-ci>=? a b) (not (string-ci<? a b)))\n"
 "(define (number->string n . radix)\n"
 "(letrec\n"
 "((digits\n"
 "(string->list \"0123456789abcdef\"))\n"
 "(conv\n"
 "(lambda (n rdx res)\n"
 "(if (zero? n)\n"
 "(if (null? res) '(#\\0) res)\n"
 "(conv (quotient n rdx)\n"
 "rdx\n"
 "(cons (list-ref digits (remainder n rdx))\n"
 "res)))))\n"
 "(conv-int\n"
 "(lambda (n rdx)\n"
 "(if (negative? n)\n"
 "(list->string (cons #\\- (conv (abs n) rdx '())))\n"
 "(list->string (conv n rdx '())))))\n"
 "(get-radix\n"
 "(lambda ()\n"
 "(cond ((null? radix) 10)\n"
 "((<= 2 (car radix) 16) (car radix))\n"
 "(else (error \"number->string: invalid radix\"\n"
 "(car radix)))))))\n"
 "(conv-int n (get-radix))))\n"
 "(define (string->number str . radix)\n"
 "(letrec\n"
 "((digits\n"
 "(string->list \"0123456789abcdef\"))\n"
 "(value-of-digit\n"
 "(lambda (x)\n"
 "(letrec\n"
 "((v (lambda (x d n)\n"
 "(cond ((null? d) 17)\n"
 "((char=? x (car d)) n)\n"
 "(else (v x (cdr d) (+ n 1)))))))\n"
 "(v (char-downcase x) digits 0))))\n"
 "(conv3\n"
 "(lambda (lst res rdx)\n"
 "(if (null? lst)\n"
 "res\n"
 "(let ((dval (value-of-digit (car lst))))\n"
 "(and (< dval rdx)\n"
 "(conv3 (cdr lst)\n"
 "(+ (value-of-digit (car lst))\n"
 "(* res rdx))\n"
 "rdx))))))\n"
 "(conv\n"
 "(lambda (lst rdx)\n"
 "(if (null? lst)\n"
 "#f\n"
 "(conv3 lst 0 rdx))))\n"
 "(sconv\n"
 "(lambda (lst rdx)\n"
 "(cond ((null? lst)\n"
 "#f)\n"
 "((char=? (car lst) #\\+)\n"
 "(conv (cdr lst) rdx))\n"
 "((char=? (car lst) #\\-)\n"
 "(let ((r (conv (cdr lst) rdx)))\n"
 "(if r (- r) #f)))\n"
 "(else\n"
 "(conv lst rdx)))))\n"
 "(get-radix\n"
 "(lambda ()\n"
 "(cond ((null? radix) 10)\n"
 "((<= 2 (car radix) 17) (car radix))\n"
 "(else (wrong \"string->number: invalid radix\" radix))))))\n"
 "(sconv (string->list str) (get-radix))))\n"
 "(define-macro quasiquote\n"
 "(lambda (form)\n"
 "(letrec\n"
 "((qq-cons\n"
 "(lambda (a b)\n"
 "(cond ((and (pair? a)\n"
 "(eq? 'unquote-splicing (car a)))\n"
 "(if (and (pair? b)\n"
 "(eq? 'quote (car b))\n"
 "(null? (cadr b)))\n"
 "(cadr a)\n"
 "(list 'append (cadr a) b)))\n"
 "(else\n"
 "(list 'cons a b)))))\n"
 "(qq-expand\n"
 "(lambda (x)\n"
 "(cond ((not (pair? x))\n"
 "(list 'quote x))\n"
 "((and (eq? 'unquote (car x))\n"
 "(pair? (cdr x)))\n"
 "(cadr x))\n"
 "((and (eq? 'unquote-splicing (car x))\n"
 "(pair? (cdr x)))\n"
 "(list 'unquote-splicing (cadr x)))\n"
 "((and (eq? 'quasiquote (car x))\n"
 "(pair? (cdr x)))\n"
 "(error \"quasiquote: may not be nested\"))\n"
 "(else\n"
 "(qq-cons (qq-expand (car x))\n"
 "(qq-expand (cdr x))))))))\n"
 "(qq-expand form))))\n"
 "(define-macro do\n"
 "(lambda (vars test . body)\n"
 "(let ((v (map car vars))\n"
 "(i (map cadr vars))\n"
 "(s (map (lambda (x)\n"
 "(if (null? (cddr x))\n"
 "(car x)\n"
 "(caddr x)))\n"
 "vars))\n"
 "(o (gensym)))\n"
 "`(letrec\n"
 "((,o (lambda ,v\n"
 "(if ,(car test)\n"
 "(begin ,@(cdr test))\n"
 "(begin ,@body (,o ,@s))))))\n"
 "(,o ,@i)))))\n"
 "(define-macro delay\n"
 "(lambda (expr)\n"
 "`(let ((value #f))\n"
 "(lambda ()\n"
 "(if value\n"
 "(car value)\n"
 "(let ((x ,expr))\n"
 "(if value\n"
 "(car value)\n"
 "(begin (set! value (cons x '()))\n"
 "(car value)))))))))\n"
 "(define (force x) (x))\n"
;
