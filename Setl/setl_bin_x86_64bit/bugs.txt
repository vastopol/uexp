$Id: BUGS,v 1.14 2009/03/17 09:32:54 setlorg Exp $

Free software (c) dB - see file COPYING for license (GPL).


Known bugs in GNU SETL
----------------------

- PI should probably be built in, so you don't have to put
  "CONST pi = 4 * ATAN 1" or whatever at the top of so many programs.

- It is odd that there is no WRITES or PRINTS to complement READS, but
  not a show-stopper given STR and the semantics of '+' (implicit
  conversion to string whenever at least one operand is a string).

- EXIT may be followed by loop header tokens as in good old CIMS SETL,
  not an expression as in SETL2.

- In a few places, integers are not unbounded, but are limited to the
  range of a C "long int".  I would be very interested to know if any
  of these cases seem unreasonable to anybody - they tend to be things
  like subscripts and replication factors, where memory constraints
  impose a practical limit anyway, but also include the F, N, and L in
  F..L and F,N..L expressions, where ease of implementation and the
  weak demands of efficiency happen to pull in the same direction.
  (You can easily work around this silly restriction, of course, simply
  by iterating in a more moderate range and then mapping upward using
  the regular integer arithmetic, which is unbounded.)

- The LALR(1) parser in 'setltran' tends not to give very helpful error
  diagnostics.

- Run-time error reporting tends to point to the rightmost part of
  larger expression (if any) in which the error occurs, rather than
  pinpointing the true offender.

- Floating-point operations can produce numbers that print or are
  converted by STR to "nan", "inf", or "-inf", but "nan" and "inf" are
  treated as strings on input (by virtue of their having the form of
  identifiers), and "-inf" is treated as an error.  This applies to
  READ, READA, READS, GETB, VAL, and UNSTR.

- There is no direct way to get an effect like sprintf's "g" format
  combined with precision control; FIXED is like "f", FLOATING is like
  "e", and STR is like "g" but without the means to control the number
  of significant digits.

- You can write atoms (created by NEWAT or copied) and convert them to
  strings, but you can't read them nor create them via UNSTR or READS.
  This is actually a deliberate design decision, but may be surprising
  to some.

- FSIZE is not compatible with SETL2.  Also, it should probably be
  extended to allow a stream designator (fd).

- There is no LSTAT, though for a symbolic link f, you can get that
  information via READLINK f.

- Patterns that match long strings can fail to match.  For example,

    s1 := 'abc';
    print(s1('a.*c'));
    s2 := 'a'+9999*'b'+'c';
    print(s2('a.*c'));

  prints abc on a line but then prints * (which stands for OM), rather
  than the appropriate 10001-character string.  This is a deficiency
  inherited from GNU regex-0.12.

- Forms like [-,x] are allowed in "lhs" positions but not in WR-only
  actual arg positions (e.g., READ([-,x])), due to limitations in the
  current LALR(1) parser.  The workaround is to use a variable name
  such as 'dummy' in place of the hyphen (e.g., READ([dummy,x])).

- %s in FDATE format specs (standing for the 3-digit representation of
  milliseconds within the second) conflicts with a (nonstandard) GNU
  extension to strftime() meaning number of seconds since the beginning
  of 1970.  But you can get the latter number directly as TOD DIV 1000.

- The macro processor treats "#" as a very special character (unary # is
  an argument stringifier, and binary ## is a concatenator).  Thus you
  are denied access to the cardinality operator and to radix denotations
  within macro definitions.  For those who are sufficiently hard-core,
  it is still possible to get a # to show up in the code emitted by a
  macro by means of a truly horrible workaround, illustrated by

    #define f(op,arg) op##arg
     ...
    f(#,x)  -- emits #x !

- With some effort, you can nest a tuple deeply enough to cause C stack
  overflow in the garbage collector, e.g.:

    t := [];
    loop
      t := [t];
    end loop;

  Note that the time taken by this program is quadratic in the number
  of loop iterations, in the current implementation.  The interpreter
  will, however, segfault after perhaps half an hour or so, given a
  stack size limit of 8MB.  You can of course change this on most POSIXy
  systems.  For example, in the Bash shell, to make it 64MB, the prior
  command "ulimit -s 65536" does the trick.

  As of this writing, I know of no way other than by creating such a
  pathologically nested structure to get 'setl' to crash (in this case
  with a SIGSEGV or SIGBUS) without issuing its own diagnostic.
