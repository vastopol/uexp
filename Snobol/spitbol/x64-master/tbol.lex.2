; copyright 1987-2012 robert b. k. dewar and mark emmer.
;
; copyright 2012-2015 david shields
;
; this file is part of macro spitbol.
;
;     macro spitbol is free software: you can redistribute it and/or modify
;     it under the terms of the gnu general public license as published by
;     the free software foundation, either version 2 of the license, or
;     (at your option) any later version.
;
;     macro spitbol is distributed in the hope that it will be useful,
;     but without any warranty; without even the implied warranty of
;     merchantability or fitness for a particular purpose.  see the
;     gnu general public license for more details.
;
;     you should have received a copy of the gnu general public license
;     along with macro spitbol.  if not, see <http://www.gnu.org/licenses/>.
;
;      spitbol conditional assembly symbols for use by token.spt
;      ---------------------------------------------------------
;
;      this file of conditional symbols will override the conditional
;      definitions contained in the spitbol minimal file.   in addition,
;      lines beginning with ">" are treated as spitbol statements and
;      immediately executed.
;
;      for linux spitbol-x86
;
;      in the spitbol translator, the following conditional
;      assembly symbols are referred to. to incorporate the
;      features referred to, the minimal source should be
;      prefaced by suitable conditional assembly symbol
;      definitions.
;      in all cases it is permissible to default the definitions
;      in which case the additional features will be omitted
;      from the target code.
;
;
;                            conditional options
;                            since .undef not allowed if symbol not
;                            defined, a full comment line indicates
;                            symbol initially not defined.
;
;      .cavt                 define to include vertical tab
;      .ccmc                 define to include syscm function
;      .ceng                 define to include engine features
;      .cnci                 define to enable sysci routine
;      .cncr                 define to enable syscr routine
;      .cnex                 define to omit exit() code.
;      .cnld                 define to omit load() code.
;      .cnpf                 define to omit profile stuff
;def   .cnra                 define to omit all real arithmetic
;      .cnsr                 define to omit sort, rsort
;      .crpp                 define if return points have odd parity
;      .cs16                 define to initialize stlim to 32767
;      .csn5                 define to pad stmt nos to 5 chars
;      .csn6                 define to pad stmt nos to 6 chars
;      .ctmd                 define if systm unit is decisecond
;      .cusr                 define to have set() use real values
;                             (must also #define setreal 1 in systype.h)
;
||ttl|27,l i c e n s e -- software license for this program||||   96
;
;     copyright 1983-2012 robert b. k. dewar
;     copyright 2012-2015 david shields
;
;     this file is part of macro spitbol.
;
;     macro spitbol is free software: you can redistribute it and/or modify
;     it under the terms of the gnu general public license as published by
;     the free software foundation, either version 2 of the license, or
;     (at your option) any later version.
;
;     macro spitbol is distributed in the hope that it will be useful,
;     but without any warranty; without even the implied warranty of
;     merchantability or fitness for a particular purpose.  see the
;     gnu general public license for more details.
;
;     you should have received a copy of the gnu general public license
;     along with macro spitbol.	 if not, see <http://www.gnu.org/licenses/>.
;
||ttl|27,s p i t b o l -- notes to implementors||||  116
;
;      m a c r o   s p i t b o l     v e r s i o n   13.01
;      ---------------------------------------------------
;
;      date of release	-  january 2013
;
;      macro spitbol is maintained by
;	    dr. david shields
;	    260 garth rd apt 3h4
;	    scarsdale, ny 10583
;      e-mail - thedaveshields at gmail dot com
;
;      version 3.7 was maintained by
;	    mark emmer
;	    catspaw, inc.
;	    p.o. box 1123
;	    salida, colorado 81021
;	    u.s.a
;      e-mail - marke at snobol4 dot com
;
;      versions 2.6 through 3.4 were maintained by
;	    dr. a. p. mccann (deceased)
;	    department of computer studies
;	    university of leeds
;	    leeds ls2 9jt
;	    england.
;
;      from 1979 through early 1983 a number of fixes and
;      enhancements were made by steve duff and robert goldberg.
;
;
||ttl|27,s p i t b o l - revision history||||  148
||ejc|||||  149
;      r e v i s i o n	 h i s t o r y
;      -------------------------------
;
;      version 13.01 (january 2013, david shields)
;
;      this version has the same functionality as the previous release, but with
;      many internal code changes.
;      support for x86-64 has been added, but is not currently working.
;      the description of the minimal language formerly found here as comments
;      is now to be found in the file minimal-reference-manual.html
;
;      version 3.8 (june 2012, david shields)
;      --------------------------------------
;
;      this version is very close to v3.7, with the
;	       same functionality.
;
;	       the source is now maintained using git, so going forward
;	       the detailed revision history will be recorded in the git
;	       commit logs, not in this file.
;
||ttl|27,s p i t b o l  -- basic information||||  171
||ejc|||||  172
;
;      general structure
;      -----------------
;
;      this program is a translator for a version of the snobol4
;      programming language. language details are contained in
;      the manual macro spitbol by dewar and mccann, technical
;      report 90, university of leeds 1976.
;      the implementation is discussed in dewar and mccann,
;      macro spitbol - a snobol4 compiler, software practice and
;      experience, 7, 95-113, 1977.
;      the language is as implemented by the btl translator
;      (griswold, poage and polonsky, prentice hall, 1971)
;      with the following principal exceptions.
;
;      1)   redefinition of standard system functions and
;	    operators is not permitted.
;
;      2)   the value function is not provided.
;
;      3)   access tracing is provided in addition to the
;	    other standard trace modes.
;
;      4)   the keyword stfcount is not provided.
;
;      5)   the keyword fullscan is not provided and all pattern
;	    matching takes place in fullscan mode (i.e. with no
;	    heuristics applied).
;
;      6)   a series of expressions separated by commas may
;	    be grouped within parentheses to provide a selection
;	    capability. the semantics are that the selection
;	    assumes the value of the first expression within it
;	    which succeeds as they are evaluated from the left.
;	    if no expression succeeds the entire statement fails
;
;      7)   an explicit pattern matching operator is provided.
;	    this is the binary query (see gimpel sigplan oct 74)
;
;      8)   the assignment operator is introduced as in the
;	    gimpel reference.
;
;      9)   the exit function is provided for generating load
;	    modules - cf. gimpels sitbol.
;
;
;      the method used in this program is to translate the
;      source code into an internal pseudo-code (see following
;      section). an interpretor is then used to execute this
;      generated pseudo-code. the nature of the snobol4 language
;      is such that the latter task is much more complex than
;      the actual translation phase. accordingly, nearly all the
;      code in the program section is concerned with the actual
;      execution of the snobol4 program.
||ejc|||||  227
;
;      interpretive code format
;      ------------------------
;
;      the interpretive pseudo-code consists of a series of
;      address pointers. the exact format of the code is
;      described in connection with the cdblk format. the
;      purpose of this section is to give general insight into
;      the interpretive approach involved.
;
;      the basic form of the code is related to reverse polish.
;      in other words, the operands precede the operators which
;      are zero address operators. there are some exceptions to
;      these rules, notably the unary not operator and the
;      selection construction which clearly require advance
;      knowledge of the operator involved.
;
;      the operands are moved to the top of the main stack and
;      the operators are applied to the top stack entries. like
;      other versions of spitbol, this processor depends on
;      knowing whether operands are required by name or by value
;      and moves the appropriate object to the stack. thus no
;      name/value checks are included in the operator circuits.
;
;      the actual pointers in the code point to a block whose
;      first word is the address of the interpretor routine
;      to be executed for the code word.
;
;      in the case of operators, the pointer is to a word which
;      contains the address of the operator to be executed. in
;      the case of operands such as constants, the pointer is to
;      the operand itself. accordingly, all operands contain
;      a field which points to the routine to load the value of
;      the operand onto the stack. in the case of a variable,
;      there are three such pointers. one to load the value,
;      one to store the value and a third to jump to the label.
;
;      the handling of failure returns deserves special comment.
;      the location flptr contains the pointer to the location
;      on the main stack which contains the failure return
;      which is in the form of a byte offset in the current
;      code block (cdblk or exblk). when a failure occurs, the
;      stack is popped as indicated by the setting of flptr and
;      control is passed to the appropriate location in the
;      current code block with the stack pointer pointing to the
;      failure offset on the stack and flptr unchanged.
||ejc|||||  274
;
;      internal data representations
;      -----------------------------
;
;      representation of values
;
;      a value is represented by a pointer to a block which
;      describes the type and particulars of the data value.
;      in general, a variable is a location containing such a
;      pointer (although in the case of trace associations this
;      is modified, see description of trblk).
;
;      the following is a list of possible datatypes showing the
;      type of block used to hold the value. the details of
;      each block format are given later.
;
;      datatype		     block type
;      --------		     ----------
;
;      array		     arblk or vcblk
;
;      code		     cdblk
;
;      expression	     exblk or seblk
;
;      integer		     icblk
;
;      name		     nmblk
;
;      pattern		     p0blk or p1blk or p2blk
;
;      real		     rcblk
;
;      string		     scblk
;
;      table		     tbblk
;
;      program datatype	     pdblk
||ejc|||||  313
;
;      representation of variables
;      ---------------------------
;
;      during the course of evaluating expressions, it is
;      necessary to generate names of variables (for example
;      on the left side of a binary equals operator). these are
;      not to be confused with objects of datatype name which
;      are in fact values.
;
;      from a logical point of view, such names could be simply
;      represented by a pointer to the appropriate value cell.
;      however in the case of arrays and program defined
;      datatypes, this would violate the rule that there must be
;      no pointers into the middle of a block in dynamic store.
;      accordingly, a name is always represented by a base and
;      offset. the base points to the start of the block
;      containing the variable value and the offset is the
;      offset within this block in bytes. thus the address
;      of the actual variable is determined by adding the base
;      and offset values.
;
;      the following are the instances of variables represented
;      in this manner.
;
;      1)   natural variable base is ptr to vrblk
;			     offset is *vrval
;
;      2)   table element    base is ptr to teblk
;			     offset is *teval
;
;      3)   array element    base is ptr to arblk
;			     offset is offset to element
;
;      4)   vector element   base is ptr to vcblk
;			     offset is offset to element
;
;      5)   prog def dtp     base is ptr to pdblk
;			     offset is offset to field value
;
;      in addition there are two cases of objects which are
;      like variables but cannot be handled in this manner.
;      these are called pseudo-variables and are represented
;      with a special base pointer as follows=
;
;      expression variable   ptr to evblk (see evblk)
;
;      keyword variable	     ptr to kvblk (see kvblk)
;
;      pseudo-variables are handled as special cases by the
;      access procedure (acess) and the assignment procedure
;      (asign). see these two procedures for details.
||ejc|||||  366
;
;      organization of data area
;      -------------------------
;
;      the data area is divided into two regions.
;
;      static area
;
;      the static area builds up from the bottom and contains
;      data areas which are allocated dynamically but are never
;      deleted or moved around. the macro-program itself
;      uses the static area for the following.
;
;      1)   all variable blocks (vrblk).
;
;      2)   the hash table for variable blocks.
;
;      3)   miscellaneous buffers and work areas (see program
;	    initialization section).
;
;      in addition, the system procedures may use this area for
;      input/output buffers, external functions etc. space in
;      the static region is allocated by calling procedure alost
;
;      the following global variables define the current
;      location and size of the static area.
;
;      statb		     address of start of static area
;      state		     address+1 of last word in area.
;
;      the minimum size of static is given approximately by
;	    12 + *e_hnb + *e_sts + space for alphabet string
;	    and standard print buffer.
||ejc|||||  400
;      dynamic area
;
;      the dynamic area is built upwards in memory after the
;      static region. data in this area must all be in standard
;      block formats so that it can be processed by the garbage
;      collector (procedure gbcol). gbcol compacts blocks down
;      in this region as required by space exhaustion and can
;      also move all blocks up to allow for expansion of the
;      static region.
;      with the exception of tables and arrays, no spitbol
;      object once built in dynamic memory is ever subsequently
;      modified. observing this rule necessitates a copying
;      action during string and pattern concatenation.
;
;      garbage collection is fundamental to the allocation of
;      space for values. spitbol uses a very efficient garbage
;      collector which insists that pointers into dynamic store
;      should be identifiable without use of bit tables,
;      marker bits etc. to satisfy this requirement, dynamic
;      memory must not start at too low an address and lengths
;      of arrays, tables, strings, code and expression blocks
;      may not exceed the numerical value of the lowest dynamic
;      address.
;
;      to avoid either penalizing users with modest
;      requirements or restricting those with greater needs on
;      host systems where dynamic memory is allocated in low
;      addresses, the minimum dynamic address may be specified
;      sufficiently high to permit arbitrarily large spitbol
;      objects to be created (with the possibility in extreme
;      cases of wasting large amounts of memory below the
;      start address). this minimum value is made available
;      in variable mxlen by a system routine, sysmx.
;      alternatively sysmx may indicate that a
;      default may be used in which dynamic is placed
;      at the lowest possible address following static.
;
;      the following global work cells define the location and
;      length of the dynamic area.
;
;      dnamb		     start of dynamic area
;      dnamp		     next available location
;      dname		     last available location + 1
;
;      dnamb is always higher than state since the alost
;      procedure maintains some expansion space above state.
;      *** dnamb must never be permitted to have a value less
;      than that in mxlen ***
;
;      space in the dynamic region is allocated by the alloc
;      procedure. the dynamic region may be used by system
;      procedures provided that all the rules are obeyed.
;      some of the rules are subtle so it is preferable for
;      osint to manage its own memory needs. spitbol procs
;      obey rules to ensure that no action can cause a garbage
;      collection except at such times as contents of xl, xr
;      and the stack are +clean+ (see comment before utility
;      procedures and in gbcol for more detail). note
;      that calls of alost may cause garbage collection (shift
;      of memory to free space). spitbol procs which call
;      system routines assume that they cannot precipitate
;      collection and this must be respected.
||ejc|||||  463
;
;      register usage
;      --------------
;
;      (cp)		     code pointer register. used to
;			     hold a pointer to the current
;			     location in the interpretive pseudo
;			     code (i.e. ptr into a cdblk).
;
;      (xl,xr)		     general index registers. usually
;			     used to hold pointers to blocks in
;			     dynamic storage. an important
;			     restriction is that the value in
;			     xl must be collectable for
;			     a garbage collect call. a value
;			     is collectable if it either points
;			     outside the dynamic area, or if it
;			     points to the start of a block in
;			     the dynamic area.
;
;      (xs)		     stack pointer. used to point to
;			     the stack front. the stack may
;			     build up or down and is used
;			     to stack subroutine return points
;			     and other recursively saved data.
;
;      (xt)		     an alternative name for xl during
;			     its use in accessing stacked items.
;
;      (wa,wb,wc)	     general work registers. cannot be
;			     used for indexing, but may hold
;			     various types of data.
;
;      (ia)		     used for all signed integer
;			     arithmetic, both that used by the
;			     translator and that arising from
;			     use of snobol4 arithmetic operators
;
;      (ra)		     real accumulator. used for all
;			     floating point arithmetic.
||ejc|||||  504
;
;      spitbol conditional assembly symbols
;      ------------------------------------
;
;      in the spitbol translator, the following conditional
;      assembly symbols are referred to. to incorporate the
;      features referred to, the minimal source should be
;      prefaced by suitable conditional assembly symbol
;      definitions.
;      in all cases it is permissible to default the definitions
;      in which case the additional features will be omitted
;      from the target code.
;
;      .caex		     define to allow up arrow for expon.
;      .caht		     define to include horizontal tab
;      .casl		     define to include 26 shifted lettrs
;      .cavt		     define to include vertical tab
;      .cbyt		     define for statistics in bytes
;      .ccmc		     define to include syscm function
;      .ccmk		     define to include compare keyword
;      .cepp		     define if entrys have odd parity
;      .cera		     define to include sysea function
;      .cexp		     define if spitbol pops sysex args
;      .cgbc		     define to include sysgc function
;      .cicc		     define to ignore bad control cards
;      .cinc		     define to add -include control card
;      .ciod		     define to not use default delimiter
;			       in processing 3rd arg of input()
;			       and output()
;      .cmth		     define to include math functions
;      .cnbf		     define to omit buffer extension
;      .cnbt		     define to omit batch initialisation
;      .cnci		     define to enable sysci routine
;      .cncr		     define to enable syscr routine
;      .cnex		     define to omit exit() code.
;      .cnld		     define to omit load() code.
;      .cnlf		     define to add file type for load()
;      .cnpf		     define to omit profile stuff
;      .cnra		     define to omit all real arithmetic
;      .cnsc		     define to no numeric-string compare
;      .cnsr		     define to omit sort, rsort
;      .cpol		     define if interface polling desired
;      .crel		     define to include reloc routines
;      .crpp		     define if returns have odd parity
;      .cs16		     define to initialize stlim to 32767
;      .cs32		     define to init stlim to 2147483647
;			     omit to take default of 50000
;      .csax		     define if sysax is to be called
;      .csed		     define to use sediment in gbcol
;      .csfn		     define to track source file names
;      .csln		     define if line number in code block
;      .csn5		     define to pad stmt nos to 5 chars
;      .csn6		     define to pad stmt nos to 6 chars
;      .csn8		     define to pad stmt nos to 8 chars
;      .csou		     define if output, terminal to sysou
;      .ctet		     define to table entry trace wanted
;      .ctmd		     define if systm unit is decisecond
;      .cucf		     define to include cfp_u
;      .cuej		     define to suppress needless ejects
;      .culk		     define to include &l/ucase keywords
;      .culc		     define to include &case (lc names)
;			     if cucl defined, must support
;			     minimal op flc wreg that folds
;			     argument to lower case
;      .cust		     define to include set() code
;
;			     conditional options
;			     since .undef not allowed if symbol
;			     not defined, a full comment line
;			     indicates symbol initially not
;			     defined.
;
;      .cbyt		     define for statistics in bytes
;      .ccmc		     define to include syscm function
;      .ccmk		     define to include compare keyword
;      .cepp		     define if entrys have odd parity
;      .cera		     define to include sysea function
;      .cexp		     define if spitbol pops sysex args
;      .cicc		     define to ignore bad control cards
;      .cinc		     define to add -include control card
;			     in processing 3rd arg of input()
;			     and output()
;      .cmth		     define to include math functions
;      .cnci		     define to enable sysci routine
;      .cncr		     define to enable syscr routine
;      .cnex		     define to omit exit() code.
;      .cnlf		     define to add file type to load()
;      .cnpf		     define to omit profile stuff
;      .cnra		     define to omit all real arithmetic
;      .cnsc		     define if no numeric-string compare
;      .cnsr		     define to omit sort, rsort
;      .cpol		     define if interface polling desired
;      .crel		     define to include reloc routines
;      .crpp		     define if returns have odd parity
;      .cs16		     define to initialize stlim to 32767
;      .cs32		     define to init stlim to 2147483647
;      .csed		     define to use sediment in gbcol
;      .csfn		     define to track source file names
;      .csln		     define if line number in code block
;      .csn5		     define to pad stmt nos to 5 chars
;      .csn6		     define to pad stmt nos to 6 chars
;      .csou		     define if output, terminal to sysou
;      .ctmd		     define if systm unit is decisecond
;
;      force definition of .ccmk if .ccmc is defined
;
||ttl|27,s p i t b o l -- procedures section||||  631
;
;      this section starts with descriptions of the operating
;      system dependent procedures which are used by the spitbol
;      translator. all such procedures have five letter names
;      beginning with sys. they are listed in alphabetical
;      order.
;      all procedures have a  specification consisting of a
;      model call, preceded by a possibly empty list of register
;      contents giving parameters available to the procedure and
;      followed by a possibly empty list of register contents
;      required on return from the call or which may have had
;      their contents destroyed. only those registers explicitly
;      mentioned in the list after the call may have their
;      values changed.
;      the segment of code providing the external procedures is
;      conveniently referred to as osint (operating system
;      interface). the sysxx procedures it contains provide
;      facilities not usually available as primitives in
;      assembly languages. for particular target machines,
;      implementors may choose for some minimal opcodes which
;      do not have reasonably direct translations, to use calls
;      of additional procedures which they provide in osint.
;      e.g. mwb or trc might be translated as jsr sysmb,
;      jsr systc in some implementations.
;
;      in the descriptions, reference is made to --blk
;      formats (-- = a pair of letters). see the spitbol
;      definitions section for detailed descriptions of all
;      such block formats except fcblk for which sysfc should
;      be consulted.
;
;      section 0 contains inp,inr specifications of internal
;      procedures,routines. this gives a single pass translator
;      information making it easy to generate alternative calls
;      in the translation of jsr-s for procedures of different
;      types if this proves necessary.
;
||sec||||; start of procedures section|  669
||ejc|||||  671
;
;      sysax -- after execution
;
|sysax|exp|1,0|||; define external entry point|  675
;
;      if the conditional assembly symbol .csax is defined,
;      this routine is called immediately after execution and
;      before printing of execution statistics or dump output.
;      purpose of call is for implementor to determine and
;      if the call is not required it will be omitted if .csax
;      is undefined. in this case sysax need not be coded.
;
;      jsr  sysax	     call after execution
||ejc|||||  687
;
;      sysbs -- backspace file
;
|sysbs|exp|1,3|||; define external entry point|  692
;
;      sysbs is used to implement the snobol4 function backspace
;      if the conditional assembly symbol .cbsp is defined.
;      the meaning is system dependent.	 in general, backspace
;      repositions the file one record closer to the beginning
;      of file, such that a subsequent read or write will
;      operate on the previous record.
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     backspace argument (scblk ptr)
;      jsr  sysbs	     call to backspace
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if backspace not allowed
;      ppm  loc		     return here if i/o error
;      (wa,wb)		     destroyed
;
;      the second error return is used for files for which
;      backspace is not permitted. for example, it may be expected
;      files on character devices are in this category.
||ejc|||||  712
;
;      sysbx -- before execution
;
|sysbx|exp|1,0|||; define external entry point|  717
;
;      called after initial spitbol compilation and before
;      commencing execution in case osint needs
;      to assign files or perform other necessary services.
;      osint may also choose to send a message to online
;      terminal (if any) indicating that execution is starting.
;
;      jsr  sysbx	     call before execution starts
||ejc|||||  726
;
;      sysdc -- date check
;
|sysdc|exp|1,0|||; define external entry point|  820
;
;      sysdc is called to check that the expiry date for a trial
;      version of spitbol is unexpired.
;
;      jsr  sysdc	     call to check date
;      return only if date is ok
||ejc|||||  827
;
;      sysdm  -- dump core
;
|sysdm|exp|1,0|||; define external entry point|  831
;
;      sysdm is called by a spitbol program call of dump(n) with
;      n ge 4.	its purpose is to provide a core dump.
;      n could hold an encoding of the start adrs for dump and
;      amount to be dumped e.g.	 n = 256*a + s , s = start adrs
;      in kilowords,  a = kilowords to dump
;
;      (xr)		     parameter n of call dump(n)
;      jsr  sysdm	     call to enter routine
||ejc|||||  841
;
;      sysdt -- get current date
;
|sysdt|exp|1,0|||; define external entry point|  845
;
;      sysdt is used to obtain the current date. the date is
;      returned as a character string in any format appropriate
;      to the operating system in use. it may also contain the
;      current time of day. sysdt is used to implement the
;      snobol4 function date().
;
;      (xr)		     parameter n of call date(n)
;      jsr  sysdt	     call to get date
;      (xl)		     pointer to block containing date
;
;      the format of the block is like an scblk except that
;      the first word need not be set. the result is copied
;      into spitbol dynamic memory on return.
||ejc|||||  861
;
;      sysea -- inform osint of compilation and runtime errors
;
|sysea|exp|1,1|||; define external entry point|  865
;
;      provides means for interface to take special actions on
;      errors
;
;      (wa)		     error code
;      (wb)		     line number
;      (wc)		     column number
;      (xr)		     system stage
;      (xl)		     file name (scblk)
;      jsr  sysea	     call to sysea function
;      ppm  loc		     suppress printing of error message
;      (xr)		     message to print (scblk) or 0
;
;      sysea may not return if interface chooses to retain
;      control.	 closing files via the fcb chain will be the
;      responsibility of the interface.
;
;      all registers preserved
||ejc|||||  887
;
;      sysef -- eject file
;
|sysef|exp|1,3|||; define external entry point|  891
;
;      sysef is used to write a page eject to a named file. it
;      may only be used for files where this concept makes
;      sense. note that sysef is not normally used for the
;      standard output file (see sysep).
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     eject argument (scblk ptr)
;      jsr  sysef	     call to eject file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if inappropriate file
;      ppm  loc		     return here if i/o error
||ejc|||||  904
;
;      sysej -- end of job
;
|sysej|exp|1,0|||; define external entry point|  908
;
;      sysej is called once at the end of execution to
;      terminate the run. the significance of the abend and
;      code values is system dependent. in general, the code
;      value should be made available for testing, and the
;      abend value should cause some post-mortem action such as
;      a dump. note that sysej does not return to its caller.
;      see sysxi for details of fcblk chain
;
;      (wa)		     value of abend keyword
;      (wb)		     value of code keyword
;      (xl)		     o or ptr to head of fcblk chain
;      jsr  sysej	     call to end job
;
;      the following special values are used as codes in (wb)
;      999  execution suppressed
;      998  standard output file full or unavailable in a sysxi
;	    load module. in these cases (wa) contains the number
;	    of the statement causing premature termination.
||ejc|||||  928
;
;      sysem -- get error message text
;
|sysem|exp|1,0|||; define external entry point|  932
;
;      sysem is used to obtain the text of err, erb calls in the
;      source program given the error code number. it is allowed
;      to return a null string if this facility is unavailable.
;
;      (wa)		     error code number
;      jsr  sysem	     call to get text
;      (xr)		     text of message
;
;      the returned value is a pointer to a block in scblk
;      format except that the first word need not be set. the
;      string is copied into dynamic memory on return.
;      if the null string is returned either because sysem does
;      not provide error message texts or because wa is out of
;      range, spitbol will print the string stored in errtext
;      keyword.
||ejc|||||  949
;
;      sysen -- endfile
;
|sysen|exp|1,3|||; define external entry point|  953
;
;      sysen is used to implement the snobol4 function endfile.
;      the meaning is system dependent. in general, endfile
;      implies that no further i/o operations will be performed,
;      but does not guarantee this to be the case. the file
;      should be closed after the call, a subsequent read
;      or write may reopen the file at the start or it may be
;      necessary to reopen the file via sysio.
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     endfile argument (scblk ptr)
;      jsr  sysen	     call to endfile
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if endfile not allowed
;      ppm  loc		     return here if i/o error
;      (wa,wb)		     destroyed
;
;      the second error return is used for files for which
;      endfile is not permitted. for example, it may be expected
;      that the standard input and output files are in this
;      category.
||ejc|||||  975
;
;      sysep -- eject printer page
;
|sysep|exp|1,0|||; define external entry point|  979
;
;      sysep is called to perform a page eject on the standard
;      printer output file (corresponding to syspr output).
;
;      jsr  sysep	     call to eject printer output
||ejc|||||  985
;
;      sysex -- call external function
;
|sysex|exp|1,3|||; define external entry point|  989
;
;      sysex is called to pass control to an external function
;      previously loaded with a call to sysld.
;
;      (xs)		     pointer to arguments on stack
;      (xl)		     pointer to control block (efblk)
;      (wa)		     number of arguments on stack
;      jsr  sysex	     call to pass control to function
;      ppm  loc		     return here if function call fails
;      ppm  loc		     return here if insufficient memory
;      ppm  loc		     return here if bad argument type
;      (xr)		     result returned
;
;      the arguments are stored on the stack with
;      the last argument at 0(xs). on return, xs
;      is popped past the arguments.
;
;      the form of the arguments as passed is that used in the
;      spitbol translator (see definitions and data structures
;      section). the control block format is also described
;      (under efblk) in this section.
;
;      there are two ways of returning a result.
;
;      1)   return a pointer to a block in dynamic storage. this
;	    block must be in exactly correct format, including
;	    the first word. only functions written with intimate
;	    knowledge of the system will return in this way.
;
;      2)   string, integer and real results may be returned by
;	    pointing to a pseudo-block outside dynamic memory.
;	    this block is in icblk, rcblk or scblk format except
;	    that the first word will be overwritten
;	    by a type word on return and so need not
;	    be correctly set. such a result is
;	    copied into main storage before proceeding.
;	    unconverted results may similarly be returned in a
;	    pseudo-block which is in correct format including
;	    type word recognisable by garbage collector since
;	    block is copied into dynamic memory.
||ejc||||| 1034
;
;      sysfc -- file control block routine
;
|sysfc|exp|1,2|||; define external entry point| 1038
;
;      see also sysio
;      input and output have 3 arguments referred to as shown
;	    input(variable name,file arg1,file arg2)
;	    output(variable name,file arg1,file arg2)
;      file arg1 may be an integer or string used to identify
;      an i/o channel. it is converted to a string for checking.
;      the exact significance of file arg2
;      is not rigorously prescribed but to improve portability,
;      the scheme described in the spitbol user manual
;      should be adopted when possible. the preferred form is
;      a string _f_,r_r_,c_c_,i_i_,...,z_z_  where
;      _f_ is an optional file name which is placed first.
;	remaining items may be omitted or included in any order.
;      _r_ is maximum record length
;      _c_ is a carriage control character or character string
;      _i_ is some form of channel identification used in the
;	  absence of _f_ to associate the variable
;	  with a file allocated dynamically by jcl commands at
;	  spitbol load time.
;      ,...,z_z_ are additional fields.
;      if , (comma) cannot be used as a delimiter, .ciod
;      should be defined to introduce by conditional assembly
;      another delimiter (see
;	 iodel	equ  *
;      early in definitions section).
;      sysfc is called when a variable is input or output
;      associated to check file arg1 and file arg2 and
;      to  report whether an fcblk (file control
;      block) is necessary and if so what size it should be.
;      this makes it possible for spitbol rather than osint to
;      allocate such a block in dynamic memory if required
;      or alternatively in static memory.
;      the significance of an fcblk , if one is requested, is
;      entirely up to the system interface. the only restriction
;      is that if the fcblk should appear to lie in dynamic
;      memory, pointers to it should be proper pointers to
;      the start of a recognisable and garbage collectable
;      block (this condition will be met if sysfc requests
;      spitbol to provide an fcblk).
;      an option is provided for osint to return a pointer in
;      xl to an fcblk which it privately allocated. this ptr
;      will be made available when i/o occurs later.
;      private fcblks may have arbitrary contents and spitbol
;      stores nothing in them.
||ejc||||| 1084
;      the requested size for an fcblk in dynamic memory
;      should allow a 2 word overhead for block type and
;      length fields. information subsequently stored in the
;      remaining words may be arbitrary if an xnblk (external
;      non-relocatable block) is requested. if the request is
;      for an xrblk (external relocatable block) the
;      contents of words should be collectable (i.e. any
;      apparent pointers into dynamic should be genuine block
;      pointers). these restrictions do not apply if an fcblk
;      is allocated outside dynamic or is not allocated at all.
;      if an fcblk is requested, its fields will be initialised
;      to zero before entry to sysio with the exception of
;      words 0 and 1 in which the block type and length
;      fields are placed for fcblks in dynamic memory only.
;      for the possible use of sysej and sysxi, if fcblks
;      are used, a chain is built so that they may all be
;      found - see sysxi for details.
;      if both file arg1 and file arg2 are null, calls of sysfc
;      and sysio are omitted.
;      if file arg1 is null (standard input/output file), sysfc
;      is called to check non-null file arg2 but any request
;      for an fcblk will be ignored, since spitbol handles the
;      standard files specially and cannot readily keep fcblk
;      pointers for them.
;      filearg1 is type checked by spitbol so further checking
;      may be unneccessary in many implementations.
;      file arg2 is passed so that sysfc may analyse and
;      check it. however to assist in this, spitbol also passes
;      on the stack the components of this argument with
;      file name, _f_ (otherwise null) extracted and stacked
;      first.
;      the other fields, if any, are extracted as substrings,
;      pointers to them are stacked and a count of all items
;      stacked is placed in wc. if an fcblk was earlier
;      allocated and pointed to via file arg1, sysfc is also
;      passed a pointer to this fcblk.
;
;      (xl)		     file arg1 scblk ptr (2nd arg)
;      (xr)		     filearg2 (3rd arg) or null
;      -(xs)...-(xs)	     scblks for _f_,_r_,_c_,...
;      (wc)		     no. of stacked scblks above
;      (wa)		     existing file arg1 fcblk ptr or 0
;      (wb)		     0/3 for input/output assocn
;      jsr  sysfc	     call to check need for fcblk
;      ppm  loc		     invalid file argument
;      ppm  loc		     fcblk already in use
;      (xs)		     popped (wc) times
;      (wa non zero)	     byte size of requested fcblk
;      (wa=0,xl non zero)    private fcblk ptr in xl
;      (wa=xl=0)	     no fcblk wanted, no private fcblk
;      (wc)		     0/1/2 request alloc of xrblk/xnblk
;			     /static block for use as fcblk
;      (wb)		     destroyed
||ejc||||| 1139
;
;      sysgc -- inform interface of garbage collections
;
|sysgc|exp|1,0|||; define external entry point| 1143
;
;      provides means for interface to take special actions
;      prior to and after a garbage collection.
;
;      possible usages-
;      1. provide visible screen icon of garbage collection
;	  in progress
;      2. inform virtual memory manager to ignore page access
;	  patterns during garbage collection.  such accesses
;	  typically destroy the page working set accumulated
;	  by the program.
;      3. inform virtual memory manager that contents of memory
;	  freed by garbage collection can be discarded.
;
;      (xr)		     non-zero if beginning gc
;			     =0 if completing gc
;      (wa)		     dnamb=start of dynamic area
;      (wb)		     dnamp=next available location
;      (wc)		     dname=last available location + 1
;      jsr  sysgc	     call to sysgc function
;      all registers preserved
||ejc||||| 1167
;
;      syshs -- give access to host computer features
;
|syshs|exp|1,8|||; define external entry point| 1171
;
;      provides means for implementing special features
;      on different host computers. the only defined entry is
;      that where all arguments are null in which case syshs
;      returns an scblk containing name of computer,
;      name of operating system and name of site separated by
;      colons. the scblk need not have a correct first field
;      as this is supplied on copying string to dynamic memory.
;      spitbol does no argument checking but does provide a
;      single error return for arguments checked as erroneous
;      by osint. it also provides a single execution error
;      return. if these are inadequate, use may be made of the
;      minimal error section direct as described in minimal
;      documentation, section 10.
;      several non-error returns are provided. the first
;      corresponds to the defined entry or, for implementation
;      defined entries, any string may be returned. the others
;      permit respectively,  return a null result, return with a
;      result to be stacked which is pointed at by xr, and a
;      return causing spitbol statement failure. if a returned
;      result is in dynamic memory it must obey garbage
;      collector rules. the only results copied on return
;      are strings returned via ppm loc3 return.
;
;      (wa)		     argument 1
;      (xl)		     argument 2
;      (xr)		     argument 3
;      (wb)		     argument 4
;      (wc)		     argument 5
;      jsr  syshs	     call to get host information
;      ppm  loc1	     erroneous arg
;      ppm  loc2	     execution error
;      ppm  loc3	     scblk ptr in xl or 0 if unavailable
;      ppm  loc4	     return a null result
;      ppm  loc5	     return result in xr
;      ppm  loc6	     cause statement failure
;      ppm  loc7	     return string at xl, length wa
;      ppm  loc8	     return copy of result in xr
||ejc||||| 1210
;
;      sysid -- return system identification
;
|sysid|exp|1,0|||; define external entry point| 1214
;
;      this routine should return strings to head the standard
;      printer output. the first string will be appended to
;      a heading line of the form
;	    macro spitbol version v.v
;      supplied by spitbol itself. v.v are digits giving the
;      major version number and generally at least a minor
;      version number relating to osint should be supplied to
;      give say
;	    macro spitbol version v.v(m.m)
;      the second string should identify at least the machine
;      and operating system.  preferably it should include
;      the date and time of the run.
;      optionally the strings may include site name of the
;      the implementor and/or machine on which run takes place,
;      unique site or copy number and other information as
;      appropriate without making it so long as to be a
;      nuisance to users.
;      the first words of the scblks pointed at need not be
;      correctly set.
;
;      jsr  sysid	     call for system identification
;      (xr)		     scblk ptr for addition to header
;      (xl)		     scblk ptr for second header
||ejc||||| 1239
;
;      sysif -- switch to new include file
;
|sysif|exp|1,1|||; define external entry point| 1244
;
;      sysif is used for include file processing, both to inform
;      the interface when a new include file is desired, and
;      when the end of file of an include file has been reached
;      and it is desired to return to reading from the previous
;      nested file.
;
;      it is the responsibility of sysif to remember the file
;      access path to the present input file before switching to
;      the new include file.
;
;      (xl)		     ptr to scblk or zero
;      (xr)		     ptr to vacant scblk of length cswin
;			     (xr not used if xl is zero)
;      jsr  sysif	     call to change files
;      ppm  loc		     unable to open file
;      (xr)		     scblk with full path name of file
;			     (xr not used if input xl is zero)
;
;      register xl points to an scblk containing the name of the
;      include file to which the interface should switch.  data
;      is fetched from the file upon the next call to sysrd.
;
;      sysif may have the ability to search multiple libraries
;      for the include file named in (xl).  it is therefore
;      required that the full path name of the file where the
;      file was finally located be returned in (xr).  it is this
;      name that is recorded along with the source statements,
;      and will accompany subsequent error messages.
;
;      register xl is zero to mark conclusion of use of an
;      include file.
||ejc||||| 1277
;
;      sysil -- get input record length
;
|sysil|exp|1,0|||; define external entry point| 1282
;
;      sysil is used to get the length of the next input record
;      from a file previously input associated with a sysio
;      call. the length returned is used to establish a buffer
;      for a subsequent sysin call.  sysil also indicates to the
;      caller if this is a binary or text file.
;
;      (wa)		     ptr to fcblk or zero
;      jsr  sysil	     call to get record length
;      (wa)		     length or zero if file closed
;      (wc)		     zero if binary, non-zero if text
;
;      no harm is done if the value returned is too long since
;      unused space will be reclaimed after the sysin call.
;
;      note that it is the sysil call (not the sysio call) which
;      causes the file to be opened as required for the first
;      record input from the file.
||ejc||||| 1301
;
;      sysin -- read input record
;
|sysin|exp|1,3|||; define external entry point| 1305
;
;      sysin is used to read a record from the file which was
;      referenced in a prior call to sysil (i.e. these calls
;      always occur in pairs). the buffer provided is an
;      scblk for a string of length set from the sysil call.
;      if the actual length read is less than this, the length
;      field of the scblk must be modified before returning
;      unless buffer is right padded with zeroes.
;      it is also permissible to take any of the alternative
;      returns after scblk length has been modified.
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     pointer to buffer (scblk ptr)
;      jsr  sysin	     call to read record
;      ppm  loc		     endfile or no i/p file after sysxi
;      ppm  loc		     return here if i/o error
;      ppm  loc		     return here if record format error
;      (wa,wb,wc)	     destroyed
||ejc||||| 1324
;
;      sysio -- input/output file association
;
|sysio|exp|1,2|||; define external entry point| 1328
;
;      see also sysfc.
;      sysio is called in response to a snobol4 input or output
;      function call except when file arg1 and file arg2
;      are both null.
;      its call always follows immediately after a call
;      of sysfc. if sysfc requested allocation
;      of an fcblk, its address will be in wa.
;      for input files, non-zero values of _r_ should be
;      copied to wc for use in allocating input buffers. if _r_
;      is defaulted or not implemented, wc should be zeroised.
;      once a file has been opened, subsequent input(),output()
;      calls in which the second argument is identical with that
;      in a previous call, merely associate the additional
;      variable name (first argument) to the file and do not
;      result in re-opening the file.
;      in subsequent associated accesses to the file a pointer
;      to any fcblk allocated will be made available.
;
;      (xl)		     file arg1 scblk ptr (2nd arg)
;      (xr)		     file arg2 scblk ptr (3rd arg)
;      (wa)		     fcblk ptr (0 if none)
;      (wb)		     0 for input, 3 for output
;      jsr  sysio	     call to associate file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return if input/output not allowed
;      (xl)		     fcblk pointer (0 if none)
;      (wc)		     0 (for default) or max record lngth
;      (wa,wb)		     destroyed
;
;      the second error return is used if the file named exists
;      but input/output from the file is not allowed. for
;      example, the standard output file may be in this category
;      as regards input association.
||ejc||||| 1363
;
;      sysld -- load external function
;
|sysld|exp|1,3|||; define external entry point| 1367
;
;      sysld is called in response to the use of the snobol4
;      load function. the named function is loaded (whatever
;      this means), and a pointer is returned. the pointer will
;      be used on subsequent calls to the function (see sysex).
;
;      (xr)		     pointer to function name (scblk)
;      (xl)		     pointer to library name (scblk)
;      jsr  sysld	     call to load function
;      ppm  loc		     return here if func does not exist
;      ppm  loc		     return here if i/o error
;      ppm  loc		     return here if insufficient memory
;      (xr)		     pointer to loaded code
;
;      the significance of the pointer returned is up to the
;      system interface routine. the only restriction is that
;      if the pointer is within dynamic storage, it must be
;      a proper block pointer.
||ejc||||| 1386
;
;      sysmm -- get more memory
;
|sysmm|exp|1,0|||; define external entry point| 1390
;
;      sysmm is called in an attempt to allocate more dynamic
;      memory. this memory must be allocated contiguously with
;      the current dynamic data area.
;
;      the amount allocated is up to the system to decide. any
;      value is acceptable including zero if allocation is
;      impossible.
;
;      jsr  sysmm	     call to get more memory
;      (xr)		     number of additional words obtained
||ejc||||| 1402
;
;      sysmx -- supply mxlen
;
|sysmx|exp|1,0|||; define external entry point| 1406
;
;      because of the method of garbage collection, no spitbol
;      object is allowed to occupy more bytes of memory than
;      the integer giving the lowest address of dynamic
;      (garbage collectable) memory. mxlen is the name used to
;      refer to this maximum length of an object and for most
;      users of most implementations, provided dynamic memory
;      starts at an address of at least a few thousand words,
;      there is no problem.
;      if the default starting address is less than say 10000 or
;      20000, then a load time option should be provided where a
;      user can request that he be able to create larger
;      objects. this routine informs spitbol of this request if
;      any. the value returned is either an integer
;      representing the desired value of mxlen (and hence the
;      minimum dynamic store address which may result in
;      non-use of some store) or zero if a default is acceptable
;      in which mxlen is set to the lowest address allocated
;      to dynamic store before compilation starts.
;      if a non-zero value is returned, this is used for keyword
;      maxlngth. otherwise the initial low address of dynamic
;      memory is used for this keyword.
;
;      jsr  sysmx	     call to get mxlen
;      (wa)		     either mxlen or 0 for default
||ejc||||| 1432
;
;      sysou -- output record
;
|sysou|exp|1,2|||; define external entry point| 1436
;
;      sysou is used to write a record to a file previously
;      associated with a sysio call.
;
;      (wa)		     ptr to fcblk
;			     or 0 for terminal or 1 for output
;      (xr)		     record to be written (scblk)
;      jsr  sysou	     call to output record
;      ppm  loc		     file full or no file after sysxi
;      ppm  loc		     return here if i/o error
;      (wa,wb,wc)	     destroyed
;
;      note that it is the sysou call (not the sysio call) which
;      causes the file to be opened as required for the first
;      record output to the file.
||ejc||||| 1458
;
;      syspi -- print on interactive channel
;
|syspi|exp|1,1|||; define external entry point| 1462
;
;      if spitbol is run from an online terminal, osint can
;      request that messages such as copies of compilation
;      errors be sent to the terminal (see syspp). if relevant
;      reply was made by syspp then syspi is called to send such
;      messages to the interactive channel.
;      syspi is also used for sending output to the terminal
;      through the special variable name, terminal.
;
;      (xr)		     ptr to line buffer (scblk)
;      (wa)		     line length
;      jsr  syspi	     call to print line
;      ppm  loc		     failure return
;      (wa,wb)		     destroyed
||ejc||||| 1478
;
;      syspl -- provide interactive control of spitbol
;
|syspl|exp|1,3|||; define external entry point| 1482
;
;      provides means for interface to take special actions,
;      such as interrupting execution, breakpointing, stepping,
;      and expression evaluation.  these last three options are
;      not presently implemented by the code calling syspl.
;
;
;      (wa)		     opcode as follows-
;			     =0 poll to allow osint to interrupt
;			     =1 breakpoint hit
;			     =2 completion of statement stepping
;			     =3 expression evaluation result
;      (wb)		     statement number
;      r_fcb		     o or ptr to head of fcblk chain
;      jsr  syspl	     call to syspl function
;      ppm  loc		     user interruption
;      ppm  loc		     step one statement
;      ppm  loc		     evaluate expression
;      ---		     resume execution
;			     (wa) = new polling interval
;
||ejc||||| 1505
;
;      syspp -- obtain print parameters
;
|syspp|exp|1,0|||; define external entry point| 1509
;
;      syspp is called once during compilation to obtain
;      parameters required for correct printed output format
;      and to select other options. it may also be called again
;      after sysxi when a load module is resumed. in this
;      case the value returned in wa may be less than or equal
;      to that returned in initial call but may not be
;      greater.
;      the information returned is -
;      1.   line length in chars for standard print file
;      2.   no of lines/page. 0 is preferable for a non-paged
;	    device (e.g. online terminal) in which case listing
;	    page throws are suppressed and page headers
;	    resulting from -title,-stitl lines are kept short.
;      3.   an initial -nolist option to suppress listing unless
;	    the program contains an explicit -list.
;      4.   options to suppress listing of compilation and/or
;	    execution stats (useful for established programs) -
;	    combined with 3. gives possibility of listing
;	    file never being opened.
;      5.   option to have copies of errors sent to an
;	    interactive channel in addition to standard printer.
;      6.   option to keep page headers short (e.g. if listing
;	    to an online terminal).
;      7.   an option to choose extended or compact listing
;	    format. in the former a page eject and in the latter
;	    a few line feeds precede the printing of each
;	    of-- listing, compilation statistics, execution
;	    output and execution statistics.
;      8.   an option to suppress execution as though a
;	    -noexecute card were supplied.
;      9.   an option to request that name /terminal/  be pre-
;	    associated to an online terminal via syspi and sysri
;      10.  an intermediate (standard) listing option requiring
;	    that page ejects occur in source listings. redundant
;	    if extended option chosen but partially extends
;	    compact option.
;      11.  option to suppress sysid identification.
;
;      jsr  syspp	     call to get print parameters
;      (wa)		     print line length in chars
;      (wb)		     number of lines/page
;      (wc)		     bits value ...mlkjihgfedcba where
;			     a = 1 to send error copy to int.ch.
;			     b = 1 means std printer is int. ch.
;			     c = 1 for -nolist option
;			     d = 1 to suppress compiln. stats
;
;			     e = 1 to suppress execn. stats
;			     f = 1/0 for extnded/compact listing
;			     g = 1 for -noexecute
;			     h = 1 pre-associate /terminal/
;
;			     i = 1 for standard listing option.
;			     j = 1 suppresses listing header
;			     k = 1 for -print
;			     l = 1 for -noerrors
;
;			     m = 1 for -case 1
||ejc||||| 1571
;
;      syspr -- print line on standard output file
;
|syspr|exp|1,1|||; define external entry point| 1575
;
;      syspr is used to print a single line on the standard
;      output file.
;
;      (xr)		     pointer to line buffer (scblk)
;      (wa)		     line length
;      jsr  syspr	     call to print line
;      ppm  loc		     too much o/p or no file after sysxi
;      (wa,wb)		     destroyed
;
;      the buffer pointed to is the length obtained from the
;      syspp call and is filled out with trailing blanks. the
;      value in wa is the actual line length which may be less
;      than the maximum line length possible. there is no space
;      control associated with the line, all lines are printed
;      single spaced. note that null lines (wa=0) are possible
;      in which case a blank line is to be printed.
;
;      the error exit is used for systems which limit the amount
;      of printed output. if possible, printing should be
;      permitted after this condition has been signalled once to
;      allow for dump and other diagnostic information.
;      assuming this to be possible, spitbol may make more syspr
;      calls. if the error return occurs another time, execution
;      is terminated by a call of sysej with ending code 998.
||ejc||||| 1601
;
;      sysrd -- read record from standard input file
;
|sysrd|exp|1,1|||; define external entry point| 1605
;
;      sysrd is used to read a record from the standard input
;      file. the buffer provided is an scblk for a string the
;      length of which in characters is given in wc, this
;      corresponding to the maximum length of string which
;      spitbol is prepared to receive. at compile time it
;      corresponds to xxx in the most recent -inxxx card
;      (default 72) and at execution time to the most recent
;      ,r_r_ (record length) in the third arg of an input()
;      statement for the standard input file (default 80).
;      if fewer than (wc) characters are read, the length
;      field of the scblk must be adjusted before returning
;      unless the buffer is right padded with zeroes.
;      it is also permissible to take the alternative return
;      after such an adjustment has been made.
;      spitbol may continue to make calls after an endfile
;      return so this routine should be prepared to make
;      repeated endfile returns.
;
;      (xr)		     pointer to buffer (scblk ptr)
;      (wc)		     length of buffer in characters
;      jsr  sysrd	     call to read line
;      ppm  loc		     endfile or no i/p file after sysxi
;			     or input file name change.	 if
;			     the former, scblk length is zero.
;			     if input file name change, length
;			     is non-zero. caller should re-issue
;			     sysrd to obtain input record.
;      (wa,wb,wc)	     destroyed
||ejc||||| 1637
;
;      sysri -- read record from interactive channel
;
|sysri|exp|1,1|||; define external entry point| 1641
;
;      reads a record from online terminal for spitbol variable,
;      terminal. if online terminal is unavailable then code the
;      endfile return only.
;      the buffer provided is of length 258 characters. sysri
;      should replace the count in the second word of the scblk
;      by the actual character count unless buffer is right
;      padded with zeroes.
;      it is also permissible to take the alternative
;      return after adjusting the count.
;      the end of file return may be used if this makes
;      sense on the target machine (e.g. if there is an
;      eof character.)
;
;      (xr)		     ptr to 258 char buffer (scblk ptr)
;      jsr  sysri	     call to read line from terminal
;      ppm  loc		     end of file return
;      (wa,wb,wc)	     may be destroyed
||ejc||||| 1660
;
;      sysrw -- rewind file
;
|sysrw|exp|1,3|||; define external entry point| 1664
;
;      sysrw is used to rewind a file i.e. reposition the file
;      at the start before the first record. the file should be
;      closed and the next read or write call will open the
;      file at the start.
;
;      (wa)		     ptr to fcblk or zero
;      (xr)		     rewind arg (scblk ptr)
;      jsr  sysrw	     call to rewind file
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if rewind not allowed
;      ppm  loc		     return here if i/o error
||ejc||||| 1677
;
;      sysst -- set file pointer
;
|sysst|exp|1,0|||; define external entry point| 1682
;
;      sysst is called to change the position of a file
;      pointer. this is accomplished in a system dependent
;      manner, and thus the 2nd and 3rd arguments are passed
;      unconverted.
;
;      (wa)		     fcblk pointer
;      (wb)		     2nd argument
;      (wc)		     3rd argument
;      jsr  sysst	     call to set file pointer
;      ppm  loc		     return here if invalid 2nd arg
;      ppm  loc		     return here if invalid 3rd arg
;      ppm  loc		     return here if file does not exist
;      ppm  loc		     return here if set not allowed
;      ppm  loc		     return here if i/o error
;
||ejc||||| 1699
;
;      systm -- get execution time so far
;
|systm|exp|1,0|||; define external entry point| 1704
;
;      systm is used to obtain the amount of execution time
;      used so far since spitbol was given control. the units
;      are described as milliseconds in the spitbol output, but
;      the exact meaning is system dependent. where appropriate,
;      this value should relate to processor rather than clock
;      timing values.
;      if the symbol .ctmd is defined, the units are described
;      as deciseconds (0.1 second).
;
;      jsr  systm	     call to get timer value
;      (ia)		     time so far in milliseconds
;			     (deciseconds if .ctmd defined)
||ejc||||| 1718
;
;      systt -- trace toggle
;
|systt|exp|1,0|||; define external entry point| 1722
;
;      called by spitbol function trace() with no args to
;      toggle the system trace switch.	this permits tracing of
;      labels in spitbol code to be turned on or off.
;
;      jsr  systt	     call to toggle trace switch
||ejc||||| 1729
;
;      sysul -- unload external function
;
|sysul|exp|1,0|||; define external entry point| 1733
;
;      sysul is used to unload a function previously
;      loaded with a call to sysld.
;
;      (xr)		     ptr to control block (efblk)
;      jsr  sysul	     call to unload function
;
;      the function cannot be called following a sysul call
;      until another sysld call is made for the same function.
;
;      the efblk contains the function code pointer and also a
;      pointer to the vrblk containing the function name (see
;      definitions and data structures section).
||ejc||||| 1749
;
;      sysxi -- exit to produce load module
;
|sysxi|exp|1,2|||; define external entry point| 1753
;
;      when sysxi is called, xl contains either a string pointer
;      or zero. in the former case, the string gives the
;      character name of a program. the intention is that
;      spitbol execution should be terminated forthwith and
;      the named program loaded and executed. this type of chain
;      execution is very system dependent and implementors may
;      choose to omit it or find it impossible to provide.
;      if (xl) is zero,ia contains one of the following integers
;
;      -1, -2, -3, -4
;	    create if possible a load module containing only the
;	    impure area of memory which needs to be loaded with
;	    a compatible pure segment for subsequent executions.
;	    version numbers to check compatibility should be
;	    kept in both segments and checked on loading.
;	    to assist with this check, (xr) on entry is a
;	    pointer to an scblk containing the spitbol major
;	    version number v.v (see sysid).  the file thus
;	    created is called a save file.
;
;      0    if possible, return control to job control
;	    command level. the effect if available will be
;	    system dependent.
;
;      +1, +2, +3, +4
;	    create if possible a load module from all of
;	    memory. it should be possible to load and execute
;	    this module directly.
;
;      in the case of saved load modules, the status of open
;      files is not preserved and implementors may choose to
;      offer means of attaching files before execution of load
;      modules starts or leave it to the user to include
;      suitable input(), output() calls in his program.
;      sysxi should make a note that no i/o channels,
;      including standard files, have files attached so that
;      calls of sysin, sysou, syspr, sysrd should fail unless
;      new associations are made for the load module.
;      at least in the case of the standard output file, it is
;      recommended that either the user be required to attach
;      a file or that a default file is attached, since the
;      problem of error messages generated by the load module
;      is otherwise severe. as a last resort, if spitbol
;      attempts to write to the standard output file and gets a
;      reply indicating that such ouput is unacceptable it stops
;      by using an entry to sysej with ending code 998.
;      as described below, passing of some arguments makes it
;      clear that load module will use a standard output file.
;
;      if use is made of fcblks for i/o association, spitbol
;      builds a chain so that those in use may be found in sysxi
;      and sysej. the nodes are 4 words long. third word
;      contains link to next node or 0, fourth word contains
;      fcblk pointer.
||ejc||||| 1809
;
;      sysxi (continued)
;
;      (xl)		     zero or scblk ptr to first argument
;      (xr)		     ptr to v.v scblk
;      (ia)		     signed integer argument
;      (wa)		     scblk ptr to second argument
;      (wb)		     0 or ptr to head of fcblk chain
;      jsr  sysxi	     call to exit
;      ppm  loc		     requested action not possible
;      ppm  loc		     action caused irrecoverable error
;      (wb,wc,ia,xr,xl,cp)   should be preserved over call
;      (wa)		     0 in all cases except sucessful
;			     performance of exit(4) or exit(-4),
;			     in which case 1 should be returned.
;
;      loading and running the load module or returning from
;      jcl command level causes execution to resume at the point
;      after the error returns which follow the call of sysxi.
;      the value passed as exit argument is used to indicate
;      options required on resumption of load module.
;      +1 or -1 require that on resumption, sysid and syspp be
;      called and a heading printed on the standard output file.
;      +2 or -2 indicate that syspp will be called but not sysid
;      and no heading will be put on standard output file.
;      above options have the obvious implication that a
;      standard o/p file must be provided for the load module.
;      +3, +4, -3 or -4 indicate calls of neither sysid nor
;      syspp and no heading will be placed on standard output
;      file.
;      +4 or -4 indicate that execution is to continue after
;      creation of the save file or load module, although all
;      files will be closed by the sysxi action.  this permits
;      the user to checkpoint long-running programs while
;      continuing execution.
;
;      no return from sysxi is possible if another program
;      is loaded and entered.
||ejc||||| 1849
;
;      introduce the internal procedures.
;
|acess|inp|25,r|1,1||;| 1853
|acomp|inp|25,n|1,5||;| 1854
|alloc|inp|25,e|1,0||;| 1855
|alocs|inp|25,e|1,0||;| 1860
|alost|inp|25,e|1,0||;| 1861
|arith|inp|25,n|1,3||;| 1869
|asign|inp|25,r|1,1||;| 1871
|asinp|inp|25,r|1,1||;| 1872
|blkln|inp|25,e|1,0||;| 1873
|cdgcg|inp|25,e|1,0||;| 1874
|cdgex|inp|25,r|1,0||;| 1875
|cdgnm|inp|25,r|1,0||;| 1876
|cdgvl|inp|25,r|1,0||;| 1877
|cdwrd|inp|25,e|1,0||;| 1878
|cmgen|inp|25,r|1,0||;| 1879
|cmpil|inp|25,e|1,0||;| 1880
|cncrd|inp|25,e|1,0||;| 1881
|copyb|inp|25,n|1,1||;| 1882
|dffnc|inp|25,e|1,0||;| 1883
|dtach|inp|25,e|1,0||;| 1884
|dtype|inp|25,e|1,0||;| 1885
|dumpr|inp|25,e|1,0||;| 1886
|ermsg|inp|25,e|1,0||;| 1891
|ertex|inp|25,e|1,0||;| 1892
|evali|inp|25,r|1,4||;| 1893
|evalp|inp|25,r|1,1||;| 1894
|evals|inp|25,r|1,3||;| 1895
|evalx|inp|25,r|1,1||;| 1896
|exbld|inp|25,e|1,0||;| 1897
|expan|inp|25,e|1,0||;| 1898
|expap|inp|25,e|1,1||;| 1899
|expdm|inp|25,n|1,0||;| 1900
|expop|inp|25,n|1,0||;| 1901
|filnm|inp|25,e|1,0||;| 1903
|flstg|inp|25,e|1,0||;| 1906
|gbcol|inp|25,e|1,0||;| 1908
|gbcpf|inp|25,e|1,0||;| 1909
|gtarr|inp|25,e|1,2||;| 1910
||ejc||||| 1911
|gtcod|inp|25,e|1,1||;| 1912
|gtexp|inp|25,e|1,1||;| 1913
|gtint|inp|25,e|1,1||;| 1914
|gtnum|inp|25,e|1,1||;| 1915
|gtnvr|inp|25,e|1,1||;| 1916
|gtpat|inp|25,e|1,1||;| 1917
|gtrea|inp|25,e|1,1||;| 1920
|gtsmi|inp|25,n|1,2||;| 1922
|gtstg|inp|25,n|1,1||;| 1927
|gtvar|inp|25,e|1,1||;| 1928
|hashs|inp|25,e|1,0||;| 1929
|icbld|inp|25,e|1,0||;| 1930
|ident|inp|25,e|1,1||;| 1931
|inout|inp|25,e|1,0||;| 1932
|insta|inp|25,e|1,0||;| 1937
|iofcb|inp|25,n|1,3||;| 1938
|ioppf|inp|25,n|1,0||;| 1939
|ioput|inp|25,n|1,7||;| 1940
|ktrex|inp|25,r|1,0||;| 1941
|kwnam|inp|25,n|1,0||;| 1942
|lcomp|inp|25,n|1,5||;| 1943
|listr|inp|25,e|1,0||;| 1944
|listt|inp|25,e|1,0||;| 1945
|newfn|inp|25,e|1,0||;| 1947
|nexts|inp|25,e|1,0||;| 1949
|patin|inp|25,n|1,2||;| 1950
|patst|inp|25,n|1,1||;| 1951
|pbild|inp|25,e|1,0||;| 1952
|pconc|inp|25,e|1,0||;| 1953
|pcopy|inp|25,n|1,0||;| 1954
|prflr|inp|25,e|1,0||;| 1957
|prflu|inp|25,e|1,0||;| 1958
|prpar|inp|25,e|1,0||;| 1960
|prtch|inp|25,e|1,0||;| 1961
|prtic|inp|25,e|1,0||;| 1962
|prtis|inp|25,e|1,0||;| 1963
|prtin|inp|25,e|1,0||;| 1964
|prtmi|inp|25,e|1,0||;| 1965
|prtmm|inp|25,e|1,0||;| 1966
|prtmx|inp|25,e|1,0||;| 1967
|prtnl|inp|25,r|1,0||;| 1968
|prtnm|inp|25,r|1,0||;| 1969
|prtnv|inp|25,e|1,0||;| 1970
|prtpg|inp|25,e|1,0||;| 1971
|prtps|inp|25,e|1,0||;| 1972
|prtsn|inp|25,e|1,0||;| 1973
|prtst|inp|25,r|1,0||;| 1974
||ejc||||| 1975
|prttr|inp|25,e|1,0||;| 1976
|prtvl|inp|25,r|1,0||;| 1977
|prtvn|inp|25,e|1,0||;| 1978
|rcbld|inp|25,e|1,0||;| 1981
|readr|inp|25,e|1,0||;| 1983
|relaj|inp|25,e|1,0||;| 1985
|relcr|inp|25,e|1,0||;| 1986
|reldn|inp|25,e|1,0||;| 1987
|reloc|inp|25,e|1,0||;| 1988
|relst|inp|25,e|1,0||;| 1989
|relws|inp|25,e|1,0||;| 1990
|rstrt|inp|25,e|1,0||;| 1992
|sbstr|inp|25,e|1,0||;| 1996
|scane|inp|25,e|1,0||;| 1997
|scngf|inp|25,e|1,0||;| 1998
|setvr|inp|25,e|1,0||;| 1999
|sorta|inp|25,n|1,1||;| 2002
|sortc|inp|25,e|1,1||;| 2003
|sortf|inp|25,e|1,0||;| 2004
|sorth|inp|25,n|1,0||;| 2005
|start|inp|25,e|1,0||;| 2007
|stgcc|inp|25,e|1,0||;| 2008
|tfind|inp|25,e|1,1||;| 2009
|tmake|inp|25,e|1,0||;| 2010
|trace|inp|25,n|1,2||;| 2011
|trbld|inp|25,e|1,0||;| 2012
|trimr|inp|25,e|1,0||;| 2013
|trxeq|inp|25,r|1,0||;| 2014
|vmake|inp|25,e|1,1||;| 2015
|xscan|inp|25,e|1,0||;| 2016
|xscni|inp|25,n|1,2||;| 2017
;
;      introduce the internal routines
;
|arref|inr||||| 2021
|cfunc|inr||||| 2022
|exfal|inr||||| 2023
|exint|inr||||| 2024
|exits|inr||||| 2025
|exixr|inr||||| 2026
|exnam|inr||||| 2027
|exnul|inr||||| 2028
|exrea|inr||||| 2031
|exsid|inr||||| 2033
|exvnm|inr||||| 2034
|failp|inr||||| 2035
|flpop|inr||||| 2036
|indir|inr||||| 2037
|match|inr||||| 2038
|retrn|inr||||| 2039
|stcov|inr||||| 2040
|stmgo|inr||||| 2041
|stopr|inr||||| 2042
|succp|inr||||| 2043
|sysab|inr||||| 2044
|systu|inr||||| 2045
||ttl|27,s p i t b o l -- definitions and data structures|||| 2046
;      this section contains all symbol definitions and also
;      pictures of all data structures used in the system.
;
||sec||||; start of definitions section| 2050
;
;      definitions of machine parameters
;
;      the minimal translator should supply appropriate values
;      for the particular target machine for all the
;      equ  *
;      definitions given at the start of this section.
;      note that even if conditional assembly is used to omit
;      some feature (e.g. real arithmetic) a full set of cfp_-
;      values must be supplied. use dummy values if genuine
;      ones are not needed.
;
|cfp_a|equ|24,256|||; number of characters in alphabet| 2063
;
|cfp_b|equ|24,8|||; bytes/word addressing factor| 2065
;
|cfp_c|equ|24,8|||; number of characters per word| 2067
;
|cfp_f|equ|24,16|||; offset in bytes to chars in| 2069
;			     scblk. see scblk format.
;
|cfp_i|equ|24,1|||; number of words in integer constant| 2072
;
|cfp_m|equ|24,9223372036854775807|||; max positive integer in one word| 2074
;
|cfp_n|equ|24,64|||; number of bits in one word| 2076
;
;      the following definitions require the supply of either
;      a single parameter if real arithmetic is omitted or
;      three parameters if real arithmetic is included.
;
;
|cfp_r|equ|24,1|||; number of words in real constant| 2086
;
|cfp_s|equ|24,9|||; number of sig digs for real output| 2088
;
|cfp_x|equ|24,3|||; max digits in real exponent| 2090
;
|mxdgs|equ|24,cfp_s+cfp_x|||; max digits in real number| 2101
;
;
;      max space for real (for +0.e+) needs five more places
;
|nstmx|equ|24,mxdgs+5|||; max space for real| 2106
;
;      the following definition for cfp_u supplies a realistic
;      upper bound on the size of the alphabet.	 cfp_u is used
;      to save space in the scane bsw-iff-esw table and to ease
;      translation storage requirements.
;
|cfp_u|equ|24,128|||; realistic upper bound on alphabet| 2116
||ejc||||| 2118
;
;      environment parameters
;
;      the spitbol program is essentially independent of
;      the definitions of these parameters. however, the
;      efficiency of the system may be affected. consequently,
;      these parameters may require tuning for a given version
;      the values given in comments have been successfully used.
;
;      e_srs is the number of words to reserve at the end of
;      storage for end of run processing. it should be
;      set as small as possible without causing memory overflow
;      in critical situations (e.g. memory overflow termination)
;      and should thus reserve sufficient space at least for
;      an scblk containing say 30 characters.
;
|e_srs|equ|24,100|||; 30 words| 2135
;
;      e_sts is the number of words grabbed in a chunk when
;      storage is allocated in the static region. the minimum
;      permitted value is 256/cfp_b. larger values will lead
;      to increased efficiency at the cost of wasting memory.
;
|e_sts|equ|24,1000|||; 500 words| 2142
;
;      e_cbs is the size of code block allocated initially and
;      the expansion increment if overflow occurs. if this value
;      is too small or too large, excessive garbage collections
;      will occur during compilation and memory may be lost
;      in the case of a too large value.
;
|e_cbs|equ|24,500|||; 500 words| 2150
;
;      e_hnb is the number of bucket headers in the variable
;      hash table. it should always be odd. larger values will
;      speed up compilation and indirect references at the
;      expense of additional storage for the hash table itself.
;
|e_hnb|equ|24,257|||; 127 bucket headers| 2157
;
;      e_hnw is the maximum number of words of a string
;      name which participate in the string hash algorithm.
;      larger values give a better hash at the expense of taking
;      longer to compute the hash. there is some optimal value.
;
|e_hnw|equ|24,3|||; 6 words| 2164
;
;      e_fsp.  if the amount of free space left after a garbage
;      collection is small compared to the total amount of space
;      in use garbage collector thrashing is likely to occur as
;      this space is used up.  e_fsp is a measure of the
;      minimum percentage of dynamic memory left as free space
;      before the system routine sysmm is called to try to
;      obtain more memory.
;
|e_fsp|equ|24,15|||; 15 percent| 2174
;
;      e_sed.  if the amount of free space left in the sediment
;      after a garbage collection is a significant fraction of
;      the new sediment size, the sediment is marked for
;      collection on the next call to the garbage collector.
;
|e_sed|equ|24,25|||; 25 percent| 2182
||ejc||||| 2184
;
;      definitions of codes for letters
;
|ch_la|equ|24,97|||; letter a| 2188
|ch_lb|equ|24,98|||; letter b| 2189
|ch_lc|equ|24,99|||; letter c| 2190
|ch_ld|equ|24,100|||; letter d| 2191
|ch_le|equ|24,101|||; letter e| 2192
|ch_lf|equ|24,102|||; letter f| 2193
|ch_lg|equ|24,103|||; letter g| 2194
|ch_lh|equ|24,104|||; letter h| 2195
|ch_li|equ|24,105|||; letter i| 2196
|ch_lj|equ|24,106|||; letter j| 2197
|ch_lk|equ|24,107|||; letter k| 2198
|ch_ll|equ|24,108|||; letter l| 2199
|ch_lm|equ|24,109|||; letter m| 2200
|ch_ln|equ|24,110|||; letter n| 2201
|ch_lo|equ|24,111|||; letter o| 2202
|ch_lp|equ|24,112|||; letter p| 2203
|ch_lq|equ|24,113|||; letter q| 2204
|ch_lr|equ|24,114|||; letter r| 2205
|ch_ls|equ|24,115|||; letter s| 2206
|ch_lt|equ|24,116|||; letter t| 2207
|ch_lu|equ|24,117|||; letter u| 2208
|ch_lv|equ|24,118|||; letter v| 2209
|ch_lw|equ|24,119|||; letter w| 2210
|ch_lx|equ|24,120|||; letter x| 2211
|ch_ly|equ|24,121|||; letter y| 2212
|ch_l_|equ|24,122|||; letter z| 2213
;
;      definitions of codes for digits
;
|ch_d0|equ|24,48|||; digit 0| 2217
|ch_d1|equ|24,49|||; digit 1| 2218
|ch_d2|equ|24,50|||; digit 2| 2219
|ch_d3|equ|24,51|||; digit 3| 2220
|ch_d4|equ|24,52|||; digit 4| 2221
|ch_d5|equ|24,53|||; digit 5| 2222
|ch_d6|equ|24,54|||; digit 6| 2223
|ch_d7|equ|24,55|||; digit 7| 2224
|ch_d8|equ|24,56|||; digit 8| 2225
|ch_d9|equ|24,57|||; digit 9| 2226
||ejc||||| 2227
;
;      definitions of codes for special characters
;
;      the names of these characters are related to their
;      original representation in the ebcdic set corresponding
;      to the description in standard snobol4 manuals and texts.
;
|ch_am|equ|24,38|||; keyword operator (ampersand)| 2235
|ch_as|equ|24,42|||; multiplication symbol (asterisk)| 2236
|ch_at|equ|24,64|||; cursor position operator (at)| 2237
|ch_bb|equ|24,60|||; left array bracket (less than)| 2238
|ch_bl|equ|24,32|||; blank| 2239
|ch_br|equ|24,124|||; alternation operator (vertical bar)| 2240
|ch_cl|equ|24,58|||; goto symbol (colon)| 2241
|ch_cm|equ|24,44|||; comma| 2242
|ch_dl|equ|24,36|||; indirection operator (dollar)| 2243
|ch_dt|equ|24,46|||; name operator (dot)| 2244
|ch_dq|equ|24,34|||; double quote| 2245
|ch_eq|equ|24,61|||; equal sign| 2246
|ch_ex|equ|24,33|||; exponentiation operator (exclm)| 2247
|ch_mn|equ|24,45|||; minus sign / hyphen| 2248
|ch_nm|equ|24,35|||; number sign| 2249
|ch_nt|equ|24,126|||; negation operator (not)| 2250
|ch_pc|equ|24,37|||; percent| 2251
|ch_pl|equ|24,43|||; plus sign| 2252
|ch_pp|equ|24,40|||; left parenthesis| 2253
|ch_rb|equ|24,62|||; right array bracket (grtr than)| 2254
|ch_rp|equ|24,41|||; right parenthesis| 2255
|ch_qu|equ|24,63|||; interrogation operator (question)| 2256
|ch_sl|equ|24,47|||; slash| 2257
|ch_sm|equ|24,59|||; semicolon| 2258
|ch_sq|equ|24,39|||; single quote| 2259
|ch_u_|equ|24,95|||; special identifier char (underline)| 2260
|ch_ob|equ|24,91|||; opening bracket| 2261
|ch_cb|equ|24,93|||; closing bracket| 2262
||ejc||||| 2263
;
;      remaining chars are optional additions to the standards.
;
;      tab characters - syntactically equivalent to blank
;
|ch_ht|equ|24,9|||; horizontal tab| 2270
;
;      up arrow same as exclamation mark for exponentiation
;
|ch_ey|equ|24,94|||; up arrow| 2279
;
;      lower case or shifted case alphabetic chars
;
|ch_ua|equ|24,65|||; shifted a| 2285
|ch_ub|equ|24,66|||; shifted b| 2286
|ch_uc|equ|24,67|||; shifted c| 2287
|ch_ud|equ|24,68|||; shifted d| 2288
|ch_ue|equ|24,69|||; shifted e| 2289
|ch_uf|equ|24,70|||; shifted f| 2290
|ch_ug|equ|24,71|||; shifted g| 2291
|ch_uh|equ|24,72|||; shifted h| 2292
|ch_ui|equ|24,73|||; shifted i| 2293
|ch_uj|equ|24,74|||; shifted j| 2294
|ch_uk|equ|24,75|||; shifted k| 2295
|ch_ul|equ|24,76|||; shifted l| 2296
|ch_um|equ|24,77|||; shifted m| 2297
|ch_un|equ|24,78|||; shifted n| 2298
|ch_uo|equ|24,79|||; shifted o| 2299
|ch_up|equ|24,80|||; shifted p| 2300
|ch_uq|equ|24,81|||; shifted q| 2301
|ch_ur|equ|24,82|||; shifted r| 2302
|ch_us|equ|24,83|||; shifted s| 2303
|ch_ut|equ|24,84|||; shifted t| 2304
|ch_uu|equ|24,85|||; shifted u| 2305
|ch_uv|equ|24,86|||; shifted v| 2306
|ch_uw|equ|24,87|||; shifted w| 2307
|ch_ux|equ|24,88|||; shifted x| 2308
|ch_uy|equ|24,89|||; shifted y| 2309
|ch_uz|equ|24,90|||; shifted z| 2310
;      if a delimiter other than ch_cm must be used in
;      the third argument of input(),output() then .ciod should
;      be defined and a parameter supplied for iodel.
;
|iodel|equ|24,32|||;| 2317
||ejc||||| 2321
;
;      data block formats and definitions
;
;      the following sections describe the detailed format of
;      all possible data blocks in static and dynamic memory.
;
;      every block has a name of the form xxblk where xx is a
;      unique two character identifier. the first word of every
;      block must contain a pointer to a program location in the
;      interpretor which is immediately preceded by an address
;      constant containing the value bl_xx where xx is the block
;      identifier. this provides a uniform mechanism for
;      distinguishing between the various block types.
;
;      in some cases, the contents of the first word is constant
;      for a given block type and merely serves as a pointer
;      to the identifying address constant. however, in other
;      cases there are several possibilities for the first
;      word in which case each of the several program entry
;      points must be preceded by the appropriate constant.
;
;      in each block, some of the fields are relocatable. this
;      means that they may contain a pointer to another block
;      in the dynamic area. (to be more precise, if they contain
;      a pointer within the dynamic area, then it is a pointer
;      to a block). such fields must be modified by the garbage
;      collector (procedure gbcol) whenever blocks are compacted
;      in the dynamic region. the garbage collector (actually
;      procedure gbcpf) requires that all such relocatable
;      fields in a block must be contiguous.
||ejc||||| 2352
;
;      the description format uses the following scheme.
;
;      1)   block title and two character identifier
;
;      2)   description of basic use of block and indication
;	    of circumstances under which it is constructed.
;
;      3)   picture of the block format. in these pictures low
;	    memory addresses are at the top of the page. fixed
;	    length fields are surrounded by i (letter i). fields
;	    which are fixed length but whose length is dependent
;	    on a configuration parameter are surrounded by *
;	    (asterisk). variable length fields are surrounded
;	    by / (slash).
;
;      4)   definition of symbolic offsets to fields in
;	    block and of the size of the block if fixed length
;	    or of the size of the fixed length fields if the
;	    block is variable length.
;	    note that some routines such as gbcpf assume
;	    certain offsets are equal. the definitions
;	    given here enforce this.  make changes to
;	    them only with due care.
;
;      definitions of common offsets
;
|offs1|equ|24,1|||;| 2380
|offs2|equ|24,2|||;| 2381
|offs3|equ|24,3|||;| 2382
;
;      5)   detailed comments on the significance and formats
;	    of the various fields.
;
;      the order is alphabetical by identification code.
||ejc||||| 2388
;
;      definitions of block codes
;
;      this table provides a unique identification code for
;      each separate block type. the first word of a block in
;      the dynamic area always contains the address of a program
;      entry point. the block code is used as the entry point id
;      the order of these codes dictates the order of the table
;      used by the datatype function (scnmt in the constant sec)
;
;      block codes for accessible datatypes
;
;      note that real and buffer types are always included, even
;      if they are conditionally excluded elsewhere.  this main-
;      tains block type codes across all versions of spitbol,
;      providing consistancy for external functions.  but note
;      that the bcblk is out of alphabetic order, placed at the
;      end of the list so as not to change the block type
;      ordering in use in existing external functions.
;
|bl_ar|equ|24,0|||; arblk	    array| 2409
|bl_cd|equ|24,bl_ar+1|||; cdblk	    code| 2410
|bl_ex|equ|24,bl_cd+1|||; exblk	    expression| 2411
|bl_ic|equ|24,bl_ex+1|||; icblk	    integer| 2412
|bl_nm|equ|24,bl_ic+1|||; nmblk	    name| 2413
|bl_p0|equ|24,bl_nm+1|||; p0blk	    pattern| 2414
|bl_p1|equ|24,bl_p0+1|||; p1blk	    pattern| 2415
|bl_p2|equ|24,bl_p1+1|||; p2blk	    pattern| 2416
|bl_rc|equ|24,bl_p2+1|||; rcblk	    real| 2417
|bl_sc|equ|24,bl_rc+1|||; scblk	    string| 2418
|bl_se|equ|24,bl_sc+1|||; seblk	    expression| 2419
|bl_tb|equ|24,bl_se+1|||; tbblk	    table| 2420
|bl_vc|equ|24,bl_tb+1|||; vcblk	    array| 2421
|bl_xn|equ|24,bl_vc+1|||; xnblk	    external| 2422
|bl_xr|equ|24,bl_xn+1|||; xrblk	    external| 2423
|bl_bc|equ|24,bl_xr+1|||; bcblk	    buffer| 2424
|bl_pd|equ|24,bl_bc+1|||; pdblk	    program defined datatype| 2425
;
|bl__d|equ|24,bl_pd+1|||; number of block codes for data| 2427
;
;      other block codes
;
|bl_tr|equ|24,bl_pd+1|||; trblk| 2431
|bl_bf|equ|24,bl_tr+1|||; bfblk| 2432
|bl_cc|equ|24,bl_bf+1|||; ccblk| 2433
|bl_cm|equ|24,bl_cc+1|||; cmblk| 2434
|bl_ct|equ|24,bl_cm+1|||; ctblk| 2435
|bl_df|equ|24,bl_ct+1|||; dfblk| 2436
|bl_ef|equ|24,bl_df+1|||; efblk| 2437
|bl_ev|equ|24,bl_ef+1|||; evblk| 2438
|bl_ff|equ|24,bl_ev+1|||; ffblk| 2439
|bl_kv|equ|24,bl_ff+1|||; kvblk| 2440
|bl_pf|equ|24,bl_kv+1|||; pfblk| 2441
|bl_te|equ|24,bl_pf+1|||; teblk| 2442
;
|bl__i|equ|24,0|||; default identification code| 2444
|bl__t|equ|24,bl_tr+1|||; code for data or trace block| 2445
|bl___|equ|24,bl_te+1|||; number of block codes| 2446
||ejc||||| 2447
;
;      field references
;
;      references to the fields of data blocks are symbolic
;      (i.e. use the symbolic offsets) with the following
;      exceptions.
;
;      1)   references to the first word are usually not
;	    symbolic since they use the (x) operand format.
;
;      2)   the code which constructs a block is often not
;	    symbolic and should be changed if the corresponding
;	    block format is modified.
;
;      3)   the plc and psc instructions imply an offset
;	    corresponding to the definition of cfp_f.
;
;      4)   there are non-symbolic references (easily changed)
;	    in the garbage collector (procedures gbcpf, blkln).
;
;      5)   the fields idval, fargs appear in several blocks
;	    and any changes must be made in parallel to all
;	    blocks containing the fields. the actual references
;	    to these fields are symbolic with the above
;	    listed exceptions.
;
;      6)   several spots in the code assume that the
;	    definitions of the fields vrval, teval, trnxt are
;	    the same (these are sections of code which search
;	    out along a trblk chain from a variable).
;
;      7)   references to the fields of an array block in the
;	    array reference routine arref are non-symbolic.
;
;      apart from the exceptions listed, references are symbolic
;      as far as possible and modifying the order or number
;      of fields will not require changes.
||ejc||||| 2485
;
;      common fields for function blocks
;
;      blocks which represent callable functions have two
;      common fields at the start of the block as follows.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    /					 /
;	    /	    rest of function block	 /
;	    /					 /
;	    +------------------------------------+
;
|fcode|equ|24,0|||; pointer to code for function| 2502
|fargs|equ|24,1|||; number of arguments| 2503
;
;      fcode is a pointer to the location in the interpretor
;      program which processes this type of function call.
;
;      fargs is the expected number of arguments. the actual
;      number of arguments is adjusted to this amount by
;      deleting extra arguments or supplying trailing nulls
;      for missing ones before transferring though fcode.
;      a value of 999 may be used in this field to indicate a
;      variable number of arguments (see svblk field svnar).
;
;      the block types which follow this scheme are.
;
;      ffblk		     field function
;      dfblk		     datatype function
;      pfblk		     program defined function
;      efblk		     external loaded function
||ejc||||| 2521
;
;      identification field
;
;
;      id   field
;
;      certain program accessible objects (those which contain
;      other data values and can be copied) are given a unique
;      identification number (see exsid). this id value is an
;      address integer value which is always stored in word two.
;
|idval|equ|24,1|||; id value field| 2533
;
;      the blocks containing an idval field are.
;
;      arblk		     array
;      pdblk		     program defined datatype
;      tbblk		     table
;      vcblk		     vector block (array)
;
;      note that a zero idval means that the block is only
;      half built and should not be dumped (see dumpr).
||ejc||||| 2548
;
;      array block (arblk)
;
;      an array block represents an array value other than one
;      with one dimension whose lower bound is one (see vcblk).
;      an arblk is built with a call to the functions convert
;      (s_cnv) or array (s_arr).
;
;	    +------------------------------------+
;	    i		     artyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     arlen		 i
;	    +------------------------------------+
;	    i		     arofs		 i
;	    +------------------------------------+
;	    i		     arndm		 i
;	    +------------------------------------+
;	    *		     arlbd		 *
;	    +------------------------------------+
;	    *		     ardim		 *
;	    +------------------------------------+
;	    *					 *
;	    * above 2 flds repeated for each dim *
;	    *					 *
;	    +------------------------------------+
;	    i		     arpro		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     arvls		 /
;	    /					 /
;	    +------------------------------------+
||ejc||||| 2582
;
;      array block (continued)
;
|artyp|equ|24,0|||; pointer to dummy routine b_art| 2586
|arlen|equ|24,idval+1|||; length of arblk in bytes| 2587
|arofs|equ|24,arlen+1|||; offset in arblk to arpro field| 2588
|arndm|equ|24,arofs+1|||; number of dimensions| 2589
|arlbd|equ|24,arndm+1|||; low bound (first subscript)| 2590
|ardim|equ|24,arlbd+cfp_i|||; dimension (first subscript)| 2591
|arlb2|equ|24,ardim+cfp_i|||; low bound (second subscript)| 2592
|ardm2|equ|24,arlb2+cfp_i|||; dimension (second subscript)| 2593
|arpro|equ|24,ardim+cfp_i|||; array prototype (one dimension)| 2594
|arvls|equ|24,arpro+1|||; start of values (one dimension)| 2595
|arpr2|equ|24,ardm2+cfp_i|||; array prototype (two dimensions)| 2596
|arvl2|equ|24,arpr2+1|||; start of values (two dimensions)| 2597
|arsi_|equ|24,arlbd|||; number of standard fields in block| 2598
|ardms|equ|24,arlb2-arlbd|||; size of info for one set of bounds| 2599
;
;      the bounds and dimension fields are signed integer
;      values and each occupy cfp_i words in the arblk.
;
;      the length of an arblk in bytes may not exceed mxlen.
;      this is required to keep name offsets garbage collectable
;
;      the actual values are arranged in row-wise order and
;      can contain a data pointer or a pointer to a trblk.
||ejc||||| 2685
;
;      code construction block (ccblk)
;
;      at any one moment there is at most one ccblk into
;      which the compiler is currently storing code (cdwrd).
;
;	    +------------------------------------+
;	    i		     cctyp		 i
;	    +------------------------------------+
;	    i		     cclen		 i
;	    +------------------------------------+
;	    i		     ccsln		 i
;	    +------------------------------------+
;	    i		     ccuse		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     cccod		 /
;	    /					 /
;	    +------------------------------------+
;
|cctyp|equ|24,0|||; pointer to dummy routine b_cct| 2708
|cclen|equ|24,cctyp+1|||; length of ccblk in bytes| 2709
|ccsln|equ|24,cclen+1|||; source line number| 2711
|ccuse|equ|24,ccsln+1|||; offset past last used word (bytes)| 2712
|cccod|equ|24,ccuse+1|||; start of generated code in block| 2716
;
;      the reason that the ccblk is a separate block type from
;      the usual cdblk is that the garbage collector must
;      only process those fields which have been set (see gbcpf)
||ejc||||| 2721
;
;      code block (cdblk)
;
;      a code block is built for each statement compiled during
;      the initial compilation or by subsequent calls to code.
;
;	    +------------------------------------+
;	    i		     cdjmp		 i
;	    +------------------------------------+
;	    i		     cdstm		 i
;	    +------------------------------------+
;	    i		     cdsln		 i
;	    +------------------------------------+
;	    i		     cdlen		 i
;	    +------------------------------------+
;	    i		     cdfal		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     cdcod		 /
;	    /					 /
;	    +------------------------------------+
;
|cdjmp|equ|24,0|||; ptr to routine to execute statement| 2746
|cdstm|equ|24,cdjmp+1|||; statement number| 2747
|cdsln|equ|24,cdstm+1|||; source line number| 2749
|cdlen|equ|24,cdsln+1|||; length of cdblk in bytes| 2750
|cdfal|equ|24,cdlen+1|||; failure exit (see below)| 2751
|cdcod|equ|24,cdfal+1|||; executable pseudo-code| 2756
|cdsi_|equ|24,cdcod|||; number of standard fields in cdblk| 2757
;
;      cdstm is the statement number of the current statement.
;
;      cdjmp, cdfal are set as follows.
;
;      1)   if the failure exit is the next statement
;
;	    cdjmp = b_cds
;	    cdfal = ptr to cdblk for next statement
;
;      2)   if the failure exit is a simple label name
;
;	    cdjmp = b_cds
;	    cdfal is a ptr to the vrtra field of the vrblk
;
;      3)   if there is no failure exit (-nofail mode)
;
;	    cdjmp = b_cds
;	    cdfal = o_unf
;
;      4)   if the failure exit is complex or direct
;
;	    cdjmp = b_cdc
;	    cdfal is the offset to the o_gof word
||ejc||||| 2782
;
;      code block (continued)
;
;      cdcod is the start of the actual code. first we describe
;      the code generated for an expression. in an expression,
;      elements are fetched by name or by value. for example,
;      the binary equal operator fetches its left argument
;      by name and its right argument by value. these two
;      cases generate quite different code and are described
;      separately. first we consider the code by value case.
;
;      generation of code by value for expressions elements.
;
;      expression	     pointer to exblk or seblk
;
;      integer constant	     pointer to icblk
;
;      null constant	     pointer to nulls
;
;      pattern		     (resulting from preevaluation)
;			     =o_lpt
;			     pointer to p0blk,p1blk or p2blk
;
;      real constant	     pointer to rcblk
;
;      string constant	     pointer to scblk
;
;      variable		     pointer to vrget field of vrblk
;
;      addition		     value code for left operand
;			     value code for right operand
;			     =o_add
;
;      affirmation	     value code for operand
;			     =o_aff
;
;      alternation	     value code for left operand
;			     value code for right operand
;			     =o_alt
;
;      array reference	     (case of one subscript)
;			     value code for array operand
;			     value code for subscript operand
;			     =o_aov
;
;			     (case of more than one subscript)
;			     value code for array operand
;			     value code for first subscript
;			     value code for second subscript
;			     ...
;			     value code for last subscript
;			     =o_amv
;			     number of subscripts
||ejc||||| 2836
;
;      code block (continued)
;
;      assignment	     (to natural variable)
;			     value code for right operand
;			     pointer to vrsto field of vrblk
;
;			     (to any other variable)
;			     name code for left operand
;			     value code for right operand
;			     =o_ass
;
;      compile error	     =o_cer
;
;
;      complementation	     value code for operand
;			     =o_com
;
;      concatenation	     (case of pred func left operand)
;			     value code for left operand
;			     =o_pop
;			     value code for right operand
;
;			     (all other cases)
;			     value code for left operand
;			     value code for right operand
;			     =o_cnc
;
;      cursor assignment     name code for operand
;			     =o_cas
;
;      division		     value code for left operand
;			     value code for right operand
;			     =o_dvd
;
;      exponentiation	     value code for left operand
;			     value code for right operand
;			     =o_exp
;
;      function call	     (case of call to system function)
;			     value code for first argument
;			     value code for second argument
;			     ...
;			     value code for last argument
;			     pointer to svfnc field of svblk
;
||ejc||||| 2883
;
;      code block (continued)
;
;      function call	     (case of non-system function 1 arg)
;			     value code for argument
;			     =o_fns
;			     pointer to vrblk for function
;
;			     (non-system function, gt 1 arg)
;			     value code for first argument
;			     value code for second argument
;			     ...
;			     value code for last argument
;			     =o_fnc
;			     number of arguments
;			     pointer to vrblk for function
;
;      immediate assignment  value code for left operand
;			     name code for right operand
;			     =o_ima
;
;      indirection	     value code for operand
;			     =o_inv
;
;      interrogation	     value code for operand
;			     =o_int
;
;      keyword reference     name code for operand
;			     =o_kwv
;
;      multiplication	     value code for left operand
;			     value code for right operand
;			     =o_mlt
;
;      name reference	     (natural variable case)
;			     pointer to nmblk for name
;
;			     (all other cases)
;			     name code for operand
;			     =o_nam
;
;      negation		     =o_nta
;			     cdblk offset of o_ntc word
;			     value code for operand
;			     =o_ntb
;			     =o_ntc
||ejc||||| 2930
;
;      code block (continued)
;
;      pattern assignment    value code for left operand
;			     name code for right operand
;			     =o_pas
;
;      pattern match	     value code for left operand
;			     value code for right operand
;			     =o_pmv
;
;      pattern replacement   name code for subject
;			     value code for pattern
;			     =o_pmn
;			     value code for replacement
;			     =o_rpl
;
;      selection	     (for first alternative)
;			     =o_sla
;			     cdblk offset to next o_slc word
;			     value code for first alternative
;			     =o_slb
;			     cdblk offset past alternatives
;
;			     (for subsequent alternatives)
;			     =o_slc
;			     cdblk offset to next o_slc,o_sld
;			     value code for alternative
;			     =o_slb
;			     offset in cdblk past alternatives
;
;			     (for last alternative)
;			     =o_sld
;			     value code for last alternative
;
;      subtraction	     value code for left operand
;			     value code for right operand
;			     =o_sub
||ejc||||| 2969
;
;      code block (continued)
;
;      generation of code by name for expression elements.
;
;      variable		     =o_lvn
;			     pointer to vrblk
;
;      expression	     (case of *natural variable)
;			     =o_lvn
;			     pointer to vrblk
;
;			     (all other cases)
;			     =o_lex
;			     pointer to exblk
;
;
;      array reference	     (case of one subscript)
;			     value code for array operand
;			     value code for subscript operand
;			     =o_aon
;
;			     (case of more than one subscript)
;			     value code for array operand
;			     value code for first subscript
;			     value code for second subscript
;			     ...
;			     value code for last subscript
;			     =o_amn
;			     number of subscripts
;
;      compile error	     =o_cer
;
;      function call	     (same code as for value call)
;			     =o_fne
;
;      indirection	     value code for operand
;			     =o_inn
;
;      keyword reference     name code for operand
;			     =o_kwn
;
;      any other operand is an error in a name position
;
;      note that in this description, =o_xxx refers to the
;      generation of a word containing the address of another
;      word which contains the entry point address o_xxx.
||ejc||||| 3017
;
;      code block (continued)
;
;      now we consider the overall structure of the code block
;      for a statement with possible goto fields.
;
;      first comes the code for the statement body.
;      the statement body is an expression to be evaluated
;      by value although the value is not actually required.
;      normal value code is generated for the body of the
;      statement except in the case of a pattern match by
;      value, in which case the following is generated.
;
;			     value code for left operand
;			     value code for right operand
;			     =o_pms
;
;      next we have the code for the success goto. there are
;      several cases as follows.
;
;      1)   no success goto  ptr to cdblk for next statement
;
;      2)   simple label     ptr to vrtra field of vrblk
;
;      3)   complex goto     (code by name for goto operand)
;			     =o_goc
;
;      4)   direct goto	     (code by value for goto operand)
;			     =o_god
;
;      following this we generate code for the failure goto if
;      it is direct or if it is complex, simple failure gotos
;      having been handled by an appropriate setting of the
;      cdfal field of the cdblk. the generated code is one
;      of the following.
;
;      1)   complex fgoto    =o_fif
;			     =o_gof
;			     name code for goto operand
;			     =o_goc
;
;      2)   direct fgoto     =o_fif
;			     =o_gof
;			     value code for goto operand
;			     =o_god
;
;      an optimization occurs if the success and failure gotos
;      are identical and either complex or direct. in this case,
;      no code is generated for the success goto and control
;      is allowed to fall into the failure goto on success.
||ejc||||| 3068
;
;      compiler block (cmblk)
;
;      a compiler block (cmblk) is built by expan to represent
;      one node of a tree structured expression representation.
;
;	    +------------------------------------+
;	    i		     cmidn		 i
;	    +------------------------------------+
;	    i		     cmlen		 i
;	    +------------------------------------+
;	    i		     cmtyp		 i
;	    +------------------------------------+
;	    i		     cmopn		 i
;	    +------------------------------------+
;	    /		cmvls or cmrop		 /
;	    /					 /
;	    /		     cmlop		 /
;	    /					 /
;	    +------------------------------------+
;
|cmidn|equ|24,0|||; pointer to dummy routine b_cmt| 3090
|cmlen|equ|24,cmidn+1|||; length of cmblk in bytes| 3091
|cmtyp|equ|24,cmlen+1|||; type (c_xxx, see list below)| 3092
|cmopn|equ|24,cmtyp+1|||; operand pointer (see below)| 3093
|cmvls|equ|24,cmopn+1|||; operand value pointers (see below)| 3094
|cmrop|equ|24,cmvls|||; right (only) operator operand| 3095
|cmlop|equ|24,cmvls+1|||; left operator operand| 3096
|cmsi_|equ|24,cmvls|||; number of standard fields in cmblk| 3097
|cmus_|equ|24,cmsi_+1|||; size of unary operator cmblk| 3098
|cmbs_|equ|24,cmsi_+2|||; size of binary operator cmblk| 3099
|cmar1|equ|24,cmvls+1|||; array subscript pointers| 3100
;
;      the cmopn and cmvls fields are set as follows
;
;      array reference	     cmopn = ptr to array operand
;			     cmvls = ptrs to subscript operands
;
;      function call	     cmopn = ptr to vrblk for function
;			     cmvls = ptrs to argument operands
;
;      selection	     cmopn = zero
;			     cmvls = ptrs to alternate operands
;
;      unary operator	     cmopn = ptr to operator dvblk
;			     cmrop = ptr to operand
;
;      binary operator	     cmopn = ptr to operator dvblk
;			     cmrop = ptr to right operand
;			     cmlop = ptr to left operand
||ejc||||| 3119
;
;      cmtyp is set to indicate the type of expression element
;      as shown by the following table of definitions.
;
|c_arr|equ|24,0|||; array reference| 3124
|c_fnc|equ|24,c_arr+1|||; function call| 3125
|c_def|equ|24,c_fnc+1|||; deferred expression (unary *)| 3126
|c_ind|equ|24,c_def+1|||; indirection (unary _)| 3127
|c_key|equ|24,c_ind+1|||; keyword reference (unary ampersand)| 3128
|c_ubo|equ|24,c_key+1|||; undefined binary operator| 3129
|c_uuo|equ|24,c_ubo+1|||; undefined unary operator| 3130
|c_uo_|equ|24,c_uuo+1|||; test value (=c_uuo+1=c_ubo+2)| 3131
|c__nm|equ|24,c_uuo+1|||; number of codes for name operands| 3132
;
;      the remaining types indicate expression elements which
;      can only be evaluated by value (not by name).
;
|c_bvl|equ|24,c_uuo+1|||; binary op with value operands| 3137
|c_uvl|equ|24,c_bvl+1|||; unary operator with value operand| 3138
|c_alt|equ|24,c_uvl+1|||; alternation (binary bar)| 3139
|c_cnc|equ|24,c_alt+1|||; concatenation| 3140
|c_cnp|equ|24,c_cnc+1|||; concatenation, not pattern match| 3141
|c_unm|equ|24,c_cnp+1|||; unary op with name operand| 3142
|c_bvn|equ|24,c_unm+1|||; binary op (operands by value, name)| 3143
|c_ass|equ|24,c_bvn+1|||; assignment| 3144
|c_int|equ|24,c_ass+1|||; interrogation| 3145
|c_neg|equ|24,c_int+1|||; negation (unary not)| 3146
|c_sel|equ|24,c_neg+1|||; selection| 3147
|c_pmt|equ|24,c_sel+1|||; pattern match| 3148
;
|c_pr_|equ|24,c_bvn|||; last preevaluable code| 3150
|c__nv|equ|24,c_pmt+1|||; number of different cmblk types| 3151
||ejc||||| 3152
;
;      character table block (ctblk)
;
;      a character table block is used to hold logical character
;      tables for use with any,notany,span,break,breakx
;      patterns. each character table can be used to store
;      cfp_n distinct tables as bit columns. a bit column
;      allocated for each argument of more than one character
;      in length to one of the above listed pattern primitives.
;
;	    +------------------------------------+
;	    i		     cttyp		 i
;	    +------------------------------------+
;	    *					 *
;	    *					 *
;	    *		     ctchs		 *
;	    *					 *
;	    *					 *
;	    +------------------------------------+
;
|cttyp|equ|24,0|||; pointer to dummy routine b_ctt| 3173
|ctchs|equ|24,cttyp+1|||; start of character table words| 3174
|ctsi_|equ|24,ctchs+cfp_a|||; number of words in ctblk| 3175
;
;      ctchs is cfp_a words long and consists of a one word
;      bit string value for each possible character in the
;      internal alphabet. each of the cfp_n possible bits in
;      a bitstring is used to form a column of bit indicators.
;      a bit is set on if the character is in the table and off
;      if the character is not present.
||ejc||||| 3183
;
;      datatype function block (dfblk)
;
;      a datatype function is used to control the construction
;      of a program defined datatype object. a call to the
;      system function data builds a dfblk for the datatype name
;
;      note that these blocks are built in static because pdblk
;      length is got from dflen field.	if dfblk was in dynamic
;      store this would cause trouble during pass two of garbage
;      collection.  scblk referred to by dfnam field is also put
;      in static so that there are no reloc. fields. this cuts
;      garbage collection task appreciably for pdblks which are
;      likely to be present in large numbers.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     dflen		 i
;	    +------------------------------------+
;	    i		     dfpdl		 i
;	    +------------------------------------+
;	    i		     dfnam		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     dffld		 /
;	    /					 /
;	    +------------------------------------+
;
|dflen|equ|24,fargs+1|||; length of dfblk in bytes| 3215
|dfpdl|equ|24,dflen+1|||; length of corresponding pdblk| 3216
|dfnam|equ|24,dfpdl+1|||; pointer to scblk for datatype name| 3217
|dffld|equ|24,dfnam+1|||; start of vrblk ptrs for field names| 3218
|dfflb|equ|24,dffld-1|||; offset behind dffld for field func| 3219
|dfsi_|equ|24,dffld|||; number of standard fields in dfblk| 3220
;
;      the fcode field points to the routine b_dfc
;
;      fargs (the number of arguments) is the number of fields.
||ejc||||| 3225
;
;      dope vector block (dvblk)
;
;      a dope vector is assembled for each possible operator in
;      the snobol4 language as part of the constant section.
;
;	    +------------------------------------+
;	    i		     dvopn		 i
;	    +------------------------------------+
;	    i		     dvtyp		 i
;	    +------------------------------------+
;	    i		     dvlpr		 i
;	    +------------------------------------+
;	    i		     dvrpr		 i
;	    +------------------------------------+
;
|dvopn|equ|24,0|||; entry address (ptr to o_xxx)| 3242
|dvtyp|equ|24,dvopn+1|||; type code (c_xxx, see cmblk)| 3243
|dvlpr|equ|24,dvtyp+1|||; left precedence (llxxx, see below)| 3244
|dvrpr|equ|24,dvlpr+1|||; right precedence (rrxxx, see below)| 3245
|dvus_|equ|24,dvlpr+1|||; size of unary operator dv| 3246
|dvbs_|equ|24,dvrpr+1|||; size of binary operator dv| 3247
|dvubs|equ|24,dvus_+dvbs_|||; size of unop + binop (see scane)| 3248
;
;      the contents of the dvtyp field is copied into the cmtyp
;      field of the cmblk for the operator if it is used.
;
;      the cmopn field of an operator cmblk points to the dvblk
;      itself, providing the required entry address pointer ptr.
;
;      for normally undefined operators, the dvopn (and cmopn)
;      fields contain a word offset from r_uba of the function
;      block pointer for the operator (instead of o_xxx ptr).
;      for certain special operators, the dvopn field is not
;      required at all and is assembled as zero.
;
;      the left precedence is used in comparing an operator to
;      the left of some other operator. it therefore governs the
;      precedence of the operator towards its right operand.
;
;      the right precedence is used in comparing an operator to
;      the right of some other operator. it therefore governs
;      the precedence of the operator towards its left operand.
;
;      higher precedence values correspond to a tighter binding
;      capability. thus we have the left precedence lower
;      (higher) than the right precedence for right (left)
;      associative binary operators.
;
;      the left precedence of unary operators is set to an
;      arbitrary high value. the right value is not required and
;      consequently the dvrpr field is omitted for unary ops.
||ejc||||| 3278
;
;      table of operator precedence values
;
|rrass|equ|24,10|||; right	    equal| 3282
|llass|equ|24,00|||; left	    equal| 3283
|rrpmt|equ|24,20|||; right	    question mark| 3284
|llpmt|equ|24,30|||; left	    question mark| 3285
|rramp|equ|24,40|||; right	    ampersand| 3286
|llamp|equ|24,50|||; left	    ampersand| 3287
|rralt|equ|24,70|||; right	    vertical bar| 3288
|llalt|equ|24,60|||; left	    vertical bar| 3289
|rrcnc|equ|24,90|||; right	    blank| 3290
|llcnc|equ|24,80|||; left	    blank| 3291
|rrats|equ|24,110|||; right	    at| 3292
|llats|equ|24,100|||; left	    at| 3293
|rrplm|equ|24,120|||; right	    plus, minus| 3294
|llplm|equ|24,130|||; left	    plus, minus| 3295
|rrnum|equ|24,140|||; right	    number| 3296
|llnum|equ|24,150|||; left	    number| 3297
|rrdvd|equ|24,160|||; right	    slash| 3298
|lldvd|equ|24,170|||; left	    slash| 3299
|rrmlt|equ|24,180|||; right	    asterisk| 3300
|llmlt|equ|24,190|||; left	    asterisk| 3301
|rrpct|equ|24,200|||; right	    percent| 3302
|llpct|equ|24,210|||; left	    percent| 3303
|rrexp|equ|24,230|||; right	    exclamation| 3304
|llexp|equ|24,220|||; left	    exclamation| 3305
|rrdld|equ|24,240|||; right	    dollar, dot| 3306
|lldld|equ|24,250|||; left	    dollar, dot| 3307
|rrnot|equ|24,270|||; right	    not| 3308
|llnot|equ|24,260|||; left	    not| 3309
|lluno|equ|24,999|||; left	    all unary operators| 3310
;
;      precedences are the same as in btl snobol4 with the
;      following exceptions.
;
;      1)   binary question mark is lowered and made left assoc-
;	    iative to reflect its new use for pattern matching.
;
;      2)   alternation and concatenation are made right
;	    associative for greater efficiency in pattern
;	    construction and matching respectively. this change
;	    is transparent to the snobol4 programmer.
;
;      3)   the equal sign has been added as a low precedence
;	    operator which is right associative to reflect its
;	    more general usage in this version of snobol4.
||ejc||||| 3326
;
;      external function block (efblk)
;
;      an external function block is used to control the calling
;      of an external function. it is built by a call to load.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     eflen		 i
;	    +------------------------------------+
;	    i		     efuse		 i
;	    +------------------------------------+
;	    i		     efcod		 i
;	    +------------------------------------+
;	    i		     efvar		 i
;	    +------------------------------------+
;	    i		     efrsl		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     eftar		 /
;	    /					 /
;	    +------------------------------------+
;
|eflen|equ|24,fargs+1|||; length of efblk in bytes| 3353
|efuse|equ|24,eflen+1|||; use count (for opsyn)| 3354
|efcod|equ|24,efuse+1|||; ptr to code (from sysld)| 3355
|efvar|equ|24,efcod+1|||; ptr to associated vrblk| 3356
|efrsl|equ|24,efvar+1|||; result type (see below)| 3357
|eftar|equ|24,efrsl+1|||; argument types (see below)| 3358
|efsi_|equ|24,eftar|||; number of standard fields in efblk| 3359
;
;      the fcode field points to the routine b_efc.
;
;      efuse is used to keep track of multiple use when opsyn
;      is employed. the function is automatically unloaded
;      when there are no more references to the function.
;
;      efrsl and eftar are type codes as follows.
;
;	    0		     type is unconverted
;	    1		     type is string
;	    2		     type is integer
;	    3		     type is real
;	    4		     type is file
||ejc||||| 3382
;
;      expression variable block (evblk)
;
;      in this version of spitbol, an expression can be used in
;      any position which would normally expect a name (for
;      example on the left side of equals or as the right
;      argument of binary dot). this corresponds to the creation
;      of a pseudo-variable which is represented by a pointer to
;      an expression variable block as follows.
;
;	    +------------------------------------+
;	    i		     evtyp		 i
;	    +------------------------------------+
;	    i		     evexp		 i
;	    +------------------------------------+
;	    i		     evvar		 i
;	    +------------------------------------+
;
|evtyp|equ|24,0|||; pointer to dummy routine b_evt| 3401
|evexp|equ|24,evtyp+1|||; pointer to exblk for expression| 3402
|evvar|equ|24,evexp+1|||; pointer to trbev dummy trblk| 3403
|evsi_|equ|24,evvar+1|||; size of evblk| 3404
;
;      the name of an expression variable is represented by a
;      base pointer to the evblk and an offset of evvar. this
;      value appears to be trapped by the dummy trbev block.
;
;      note that there is no need to allow for the case of an
;      expression variable which references an seblk since a
;      variable which is of the form *var is equivalent to var.
||ejc||||| 3413
;
;      expression block (exblk)
;
;      an expression block is built for each expression
;      referenced in a program or created by eval or convert
;      during execution of a program.
;
;	    +------------------------------------+
;	    i		     extyp		 i
;	    +------------------------------------+
;	    i		     exstm		 i
;	    +------------------------------------+
;	    i		     exsln		 i
;	    +------------------------------------+
;	    i		     exlen		 i
;	    +------------------------------------+
;	    i		     exflc		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     excod		 /
;	    /					 /
;	    +------------------------------------+
;
|extyp|equ|24,0|||; ptr to routine b_exl to load expr| 3439
|exstm|equ|24,cdstm|||; stores stmnt no. during evaluation| 3440
|exsln|equ|24,exstm+1|||; stores line no. during evaluation| 3442
|exlen|equ|24,exsln+1|||; length of exblk in bytes| 3443
|exflc|equ|24,exlen+1|||; failure code (=o_fex)| 3447
|excod|equ|24,exflc+1|||; pseudo-code for expression| 3448
|exsi_|equ|24,excod|||; number of standard fields in exblk| 3449
;
;      there are two cases for excod depending on whether the
;      expression can be evaluated by name (see description
;      of cdblk for details of code for expressions).
;
;      if the expression can be evaluated by name we have.
;
;			     (code for expr by name)
;			     =o_rnm
;
;      if the expression can only be evaluated by value.
;
;			     (code for expr by value)
;			     =o_rvl
||ejc||||| 3464
;
;      field function block (ffblk)
;
;      a field function block is used to control the selection
;      of a field from a program defined datatype block.
;      a call to data creates an ffblk for each field.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     ffdfp		 i
;	    +------------------------------------+
;	    i		     ffnxt		 i
;	    +------------------------------------+
;	    i		     ffofs		 i
;	    +------------------------------------+
;
|ffdfp|equ|24,fargs+1|||; pointer to associated dfblk| 3484
|ffnxt|equ|24,ffdfp+1|||; ptr to next ffblk on chain or zero| 3485
|ffofs|equ|24,ffnxt+1|||; offset (bytes) to field in pdblk| 3486
|ffsi_|equ|24,ffofs+1|||; size of ffblk in words| 3487
;
;      the fcode field points to the routine b_ffc.
;
;      fargs always contains one.
;
;      ffdfp is used to verify that the correct program defined
;      datatype is being accessed by this call.
;      ffdfp is non-reloc. because dfblk is in static
;
;      ffofs is used to select the appropriate field. note that
;      it is an actual offset (not a field number)
;
;      ffnxt is used to point to the next ffblk of the same name
;      in the case where there are several fields of the same
;      name for different datatypes. zero marks the end of chain
||ejc||||| 3503
;
;      integer constant block (icblk)
;
;      an icblk is created for every integer referenced or
;      created by a program. note however that certain internal
;      integer values are stored as addresses (e.g. the length
;      field in a string constant block)
;
;	    +------------------------------------+
;	    i		     icget		 i
;	    +------------------------------------+
;	    *		     icval		 *
;	    +------------------------------------+
;
|icget|equ|24,0|||; ptr to routine b_icl to load int| 3518
|icval|equ|24,icget+1|||; integer value| 3519
|icsi_|equ|24,icval+cfp_i|||; size of icblk| 3520
;
;      the length of the icval field is cfp_i.
||ejc||||| 3523
;
;      keyword variable block (kvblk)
;
;      a kvblk is used to represent a keyword pseudo-variable.
;      a kvblk is built for each keyword reference (kwnam).
;
;	    +------------------------------------+
;	    i		     kvtyp		 i
;	    +------------------------------------+
;	    i		     kvvar		 i
;	    +------------------------------------+
;	    i		     kvnum		 i
;	    +------------------------------------+
;
|kvtyp|equ|24,0|||; pointer to dummy routine b_kvt| 3538
|kvvar|equ|24,kvtyp+1|||; pointer to dummy block trbkv| 3539
|kvnum|equ|24,kvvar+1|||; keyword number| 3540
|kvsi_|equ|24,kvnum+1|||; size of kvblk| 3541
;
;      the name of a keyword variable is represented by a
;      base pointer to the kvblk and an offset of kvvar. the
;      value appears to be trapped by the pointer to trbkv.
||ejc||||| 3546
;
;      name block (nmblk)
;
;      a name block is used wherever a name must be stored as
;      a value following use of the unary dot operator.
;
;	    +------------------------------------+
;	    i		     nmtyp		 i
;	    +------------------------------------+
;	    i		     nmbas		 i
;	    +------------------------------------+
;	    i		     nmofs		 i
;	    +------------------------------------+
;
|nmtyp|equ|24,0|||; ptr to routine b_nml to load name| 3561
|nmbas|equ|24,nmtyp+1|||; base pointer for variable| 3562
|nmofs|equ|24,nmbas+1|||; offset for variable| 3563
|nmsi_|equ|24,nmofs+1|||; size of nmblk| 3564
;
;      the actual field representing the contents of the name
;      is found nmofs bytes past the address in nmbas.
;
;      the name is split into base and offset form to avoid
;      creation of a pointer into the middle of a block which
;      could not be handled properly by the garbage collector.
;
;      a name may be built for any variable (see section on
;      representations of variables) this includes the
;      cases of pseudo-variables.
||ejc||||| 3576
;
;      pattern block, no parameters (p0blk)
;
;      a p0blk is used to represent pattern nodes which do
;      not require the use of any parameter values.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;
|pcode|equ|24,0|||; ptr to match routine (p_xxx)| 3589
|pthen|equ|24,pcode+1|||; pointer to subsequent node| 3590
|pasi_|equ|24,pthen+1|||; size of p0blk| 3591
;
;      pthen points to the pattern block for the subsequent
;      node to be matched. this is a pointer to the pattern
;      block ndnth if there is no subsequent (end of pattern)
;
;      pcode is a pointer to the match routine for the node.
||ejc||||| 3598
;
;      pattern block (one parameter)
;
;      a p1blk is used to represent pattern nodes which
;      require one parameter value.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;
|parm1|equ|24,pthen+1|||; first parameter value| 3613
|pbsi_|equ|24,parm1+1|||; size of p1blk in words| 3614
;
;      see p0blk for definitions of pcode, pthen
;
;      parm1 contains a parameter value used in matching the
;      node. for example, in a len pattern, it is the integer
;      argument to len. the details of the use of the parameter
;      field are included in the description of the individual
;      match routines. parm1 is always an address pointer which
;      is processed by the garbage collector.
||ejc||||| 3624
;
;      pattern block (two parameters)
;
;      a p2blk is used to represent pattern nodes which
;      require two parameter values.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;	    i		     parm2		 i
;	    +------------------------------------+
;
|parm2|equ|24,parm1+1|||; second parameter value| 3641
|pcsi_|equ|24,parm2+1|||; size of p2blk in words| 3642
;
;      see p1blk for definitions of pcode, pthen, parm1
;
;      parm2 is a parameter which performs the same sort of
;      function as parm1 (see description of p1blk).
;
;      parm2 is a non-relocatable field and is not
;      processed by the garbage collector. accordingly, it may
;      not contain a pointer to a block in dynamic memory.
||ejc||||| 3652
;
;      program-defined datatype block
;
;      a pdblk represents the data item formed by a call to a
;      datatype function as defined by the system function data.
;
;	    +------------------------------------+
;	    i		     pdtyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     pddfp		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     pdfld		 /
;	    /					 /
;	    +------------------------------------+
;
|pdtyp|equ|24,0|||; ptr to dummy routine b_pdt| 3671
|pddfp|equ|24,idval+1|||; ptr to associated dfblk| 3672
|pdfld|equ|24,pddfp+1|||; start of field value pointers| 3673
|pdfof|equ|24,dffld-pdfld|||; difference in offset to field ptrs| 3674
|pdsi_|equ|24,pdfld|||; size of standard fields in pdblk| 3675
|pddfs|equ|24,dfsi_-pdsi_|||; difference in dfblk, pdblk sizes| 3676
;
;      the pddfp pointer may be used to determine the datatype
;      and the names of the fields if required. the dfblk also
;      contains the length of the pdblk in bytes (field dfpdl).
;      pddfp is non-reloc. because dfblk is in static
;
;      pdfld values are stored in order from left to right.
;      they contain values or pointers to trblk chains.
||ejc||||| 3685
;
;      program defined function block (pfblk)
;
;      a pfblk is created for each call to the define function
;      and a pointer to the pfblk placed in the proper vrblk.
;
;	    +------------------------------------+
;	    i		     fcode		 i
;	    +------------------------------------+
;	    i		     fargs		 i
;	    +------------------------------------+
;	    i		     pflen		 i
;	    +------------------------------------+
;	    i		     pfvbl		 i
;	    +------------------------------------+
;	    i		     pfnlo		 i
;	    +------------------------------------+
;	    i		     pfcod		 i
;	    +------------------------------------+
;	    i		     pfctr		 i
;	    +------------------------------------+
;	    i		     pfrtr		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     pfarg		 /
;	    /					 /
;	    +------------------------------------+
;
|pflen|equ|24,fargs+1|||; length of pfblk in bytes| 3714
|pfvbl|equ|24,pflen+1|||; pointer to vrblk for function name| 3715
|pfnlo|equ|24,pfvbl+1|||; number of locals| 3716
|pfcod|equ|24,pfnlo+1|||; ptr to vrblk for entry label| 3717
|pfctr|equ|24,pfcod+1|||; trblk ptr if call traced else 0| 3718
|pfrtr|equ|24,pfctr+1|||; trblk ptr if return traced else 0| 3719
|pfarg|equ|24,pfrtr+1|||; vrblk ptrs for arguments and locals| 3720
|pfagb|equ|24,pfarg-1|||; offset behind pfarg for arg, local| 3721
|pfsi_|equ|24,pfarg|||; number of standard fields in pfblk| 3722
;
;      the fcode field points to the routine b_pfc.
;
;      pfarg is stored in the following order.
;
;	    arguments (left to right)
;	    locals (left to right)
||ejc||||| 3732
;
;      real constant block (rcblk)
;
;      an rcblk is created for every real referenced or
;      created by a program.
;
;	    +------------------------------------+
;	    i		     rcget		 i
;	    +------------------------------------+
;	    *		     rcval		 *
;	    +------------------------------------+
;
|rcget|equ|24,0|||; ptr to routine b_rcl to load real| 3745
|rcval|equ|24,rcget+1|||; real value| 3746
|rcsi_|equ|24,rcval+cfp_r|||; size of rcblk| 3747
;
;      the length of the rcval field is cfp_r.
||ejc||||| 3751
;
;      string constant block (scblk)
;
;      an scblk is built for every string referenced or created
;      by a program.
;
;	    +------------------------------------+
;	    i		     scget		 i
;	    +------------------------------------+
;	    i		     sclen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     schar		 /
;	    /					 /
;	    +------------------------------------+
;
|scget|equ|24,0|||; ptr to routine b_scl to load string| 3768
|sclen|equ|24,scget+1|||; length of string in characters| 3769
|schar|equ|24,sclen+1|||; characters of string| 3770
|scsi_|equ|24,schar|||; size of standard fields in scblk| 3771
;
;      the characters of the string are stored left justified.
;      the final word is padded on the right with zeros.
;      (i.e. the character whose internal code is zero).
;
;      the value of sclen may not exceed mxlen. this ensures
;      that character offsets (e.g. the pattern match cursor)
;      can be correctly processed by the garbage collector.
;
;      note that the offset to the characters of the string
;      is given in bytes by cfp_f and that this value is
;      automatically allowed for in plc, psc.
;      note that for a spitbol scblk, the value of cfp_f
;      is given by cfp_b*schar.
||ejc||||| 3786
;
;      simple expression block (seblk)
;
;      an seblk is used to represent an expression of the form
;      *(natural variable). all other expressions are exblks.
;
;	    +------------------------------------+
;	    i		     setyp		 i
;	    +------------------------------------+
;	    i		     sevar		 i
;	    +------------------------------------+
;
|setyp|equ|24,0|||; ptr to routine b_sel to load expr| 3799
|sevar|equ|24,setyp+1|||; ptr to vrblk for variable| 3800
|sesi_|equ|24,sevar+1|||; length of seblk in words| 3801
||ejc||||| 3802
;
;      standard variable block (svblk)
;
;      an svblk is assembled in the constant section for each
;      variable which satisfies one of the following conditions.
;
;      1)   it is the name of a system function
;      2)   it has an initial value
;      3)   it has a keyword association
;      4)   it has a standard i/o association
;      6)   it has a standard label association
;
;      if vrblks are constructed for any of these variables,
;      then the vrsvp field points to the svblk (see vrblk)
;
;	    +------------------------------------+
;	    i		     svbit		 i
;	    +------------------------------------+
;	    i		     svlen		 i
;	    +------------------------------------+
;	    /		     svchs		 /
;	    +------------------------------------+
;	    i		     svknm		 i
;	    +------------------------------------+
;	    i		     svfnc		 i
;	    +------------------------------------+
;	    i		     svnar		 i
;	    +------------------------------------+
;	    i		     svlbl		 i
;	    +------------------------------------+
;	    i		     svval		 i
;	    +------------------------------------+
||ejc||||| 3835
;
;      standard variable block (continued)
;
|svbit|equ|24,0|||; bit string indicating attributes| 3839
|svlen|equ|24,1|||; (=sclen) length of name in chars| 3840
|svchs|equ|24,2|||; (=schar) characters of name| 3841
|svsi_|equ|24,2|||; number of standard fields in svblk| 3842
|svpre|equ|24,1|||; set if preevaluation permitted| 3843
|svffc|equ|24,svpre+svpre|||; set on if fast call permitted| 3844
|svckw|equ|24,svffc+svffc|||; set on if keyword value constant| 3845
|svprd|equ|24,svckw+svckw|||; set on if predicate function| 3846
|svnbt|equ|24,4|||; number of bits to right of svknm| 3847
|svknm|equ|24,svprd+svprd|||; set on if keyword association| 3848
|svfnc|equ|24,svknm+svknm|||; set on if system function| 3849
|svnar|equ|24,svfnc+svfnc|||; set on if system function| 3850
|svlbl|equ|24,svnar+svnar|||; set on if system label| 3851
|svval|equ|24,svlbl+svlbl|||; set on if predefined value| 3852
;
;      note that the last five bits correspond in order
;      to the fields which are present (see procedure gtnvr).
;
;      the following definitions are used in the svblk table
;
|svfnf|equ|24,svfnc+svnar|||; function with no fast call| 3859
|svfnn|equ|24,svfnf+svffc|||; function with fast call, no preeval| 3860
|svfnp|equ|24,svfnn+svpre|||; function allowing preevaluation| 3861
|svfpr|equ|24,svfnn+svprd|||; predicate function| 3862
|svfnk|equ|24,svfnn+svknm|||; no preeval func + keyword| 3863
|svkwv|equ|24,svknm+svval|||; keyword + value| 3864
|svkwc|equ|24,svckw+svknm|||; keyword with constant value| 3865
|svkvc|equ|24,svkwv+svckw|||; constant keyword + value| 3866
|svkvl|equ|24,svkvc+svlbl|||; constant keyword + value + label| 3867
|svfpk|equ|24,svfnp+svkvc|||; preeval fcn + const keywd + val| 3868
;
;      the svpre bit allows the compiler to preevaluate a call
;      to the associated system function if all the arguments
;      are themselves constants. functions in this category
;      must have no side effects and must never cause failure.
;      the call may generate an error condition.
;
;      the svffc bit allows the compiler to generate the special
;      fast call after adjusting the number of arguments. only
;      the item and apply functions fall outside this category.
;
;      the svckw bit is set if the associated keyword value is
;      a constant, thus allowing preevaluation for a value call.
;
;      the svprd bit is set on for all predicate functions to
;      enable the special concatenation code optimization.
||ejc||||| 3885
;
;      svblk (continued)
;
;      svknm		     keyword number
;
;	    svknm is present only for a standard keyword assoc.
;	    it contains a keyword number as defined by the
;	    keyword number table given later on.
;
;      svfnc		     system function pointer
;
;	    svfnc is present only for a system function assoc.
;	    it is a pointer to the actual code for the system
;	    function. the generated code for a fast call is a
;	    pointer to the svfnc field of the svblk for the
;	    function. the vrfnc field of the vrblk points to
;	    this same field, in which case, it serves as the
;	    fcode field for the function call.
;
;      svnar		     number of function arguments
;
;	    svnar is present only for a system function assoc.
;	    it is the number of arguments required for a call
;	    to the system function. the compiler uses this
;	    value to adjust the number of arguments in a fast
;	    call and in the case of a function called through
;	    the vrfnc field of the vrblk, the svnar field
;	    serves as the fargs field for o_fnc. a special
;	    case occurs if this value is set to 999. this is
;	    used to indicate that the function has a variable
;	    number of arguments and causes o_fnc to pass control
;	    without adjusting the argument count. the only
;	    predefined functions using this are apply and item.
;
;      svlbl		     system label pointer
;
;	    svlbl is present only for a standard label assoc.
;	    it is a pointer to a system label routine (l_xxx).
;	    the vrlbl field of the corresponding vrblk points to
;	    the svlbl field of the svblk.
;
;      svval		     system value pointer
;
;	    svval is present only for a standard value.
;	    it is a pointer to the pattern node (ndxxx) which
;	    is the standard initial value of the variable.
;	    this value is copied to the vrval field of the vrblk
||ejc||||| 3933
;
;      svblk (continued)
;
;      keyword number table
;
;      the following table gives symbolic names for keyword
;      numbers. these values are stored in the svknm field of
;      svblks and in the kvnum field of kvblks. see also
;      procedures asign, acess and kwnam.
;
;      unprotected keywords with one word integer values
;
|k_abe|equ|24,0|||; abend| 3946
|k_anc|equ|24,k_abe+cfp_b|||; anchor| 3947
|k_cas|equ|24,k_anc+cfp_b|||; case| 3949
|k_cod|equ|24,k_cas+cfp_b|||; code| 3950
|k_com|equ|24,k_cod+cfp_b|||; compare| 3955
|k_dmp|equ|24,k_com+cfp_b|||; dump| 3956
|k_erl|equ|24,k_dmp+cfp_b|||; errlimit| 3960
|k_ert|equ|24,k_erl+cfp_b|||; errtype| 3961
|k_ftr|equ|24,k_ert+cfp_b|||; ftrace| 3962
|k_fls|equ|24,k_ftr+cfp_b|||; fullscan| 3963
|k_inp|equ|24,k_fls+cfp_b|||; input| 3964
|k_mxl|equ|24,k_inp+cfp_b|||; maxlength| 3965
|k_oup|equ|24,k_mxl+cfp_b|||; output| 3966
|k_pfl|equ|24,k_oup+cfp_b|||; profile| 3970
|k_tra|equ|24,k_pfl+cfp_b|||; trace| 3971
|k_trm|equ|24,k_tra+cfp_b|||; trim| 3973
;
;      protected keywords with one word integer values
;
|k_fnc|equ|24,k_trm+cfp_b|||; fnclevel| 3977
|k_lst|equ|24,k_fnc+cfp_b|||; lastno| 3978
|k_lln|equ|24,k_lst+cfp_b|||; lastline| 3980
|k_lin|equ|24,k_lln+cfp_b|||; line| 3981
|k_stn|equ|24,k_lin+cfp_b|||; stno| 3982
;
;      keywords with constant pattern values
;
|k_abo|equ|24,k_stn+cfp_b|||; abort| 3989
|k_arb|equ|24,k_abo+pasi_|||; arb| 3990
|k_bal|equ|24,k_arb+pasi_|||; bal| 3991
|k_fal|equ|24,k_bal+pasi_|||; fail| 3992
|k_fen|equ|24,k_fal+pasi_|||; fence| 3993
|k_rem|equ|24,k_fen+pasi_|||; rem| 3994
|k_suc|equ|24,k_rem+pasi_|||; succeed| 3995
||ejc||||| 3996
;
;      keyword number table (continued)
;
;      special keywords
;
|k_alp|equ|24,k_suc+1|||; alphabet| 4002
|k_rtn|equ|24,k_alp+1|||; rtntype| 4003
|k_stc|equ|24,k_rtn+1|||; stcount| 4004
|k_etx|equ|24,k_stc+1|||; errtext| 4005
|k_fil|equ|24,k_etx+1|||; file| 4007
|k_lfl|equ|24,k_fil+1|||; lastfile| 4008
|k_stl|equ|24,k_lfl+1|||; stlimit| 4009
|k_lcs|equ|24,k_stl+1|||; lcase| 4014
|k_ucs|equ|24,k_lcs+1|||; ucase| 4015
;
;      relative offsets of special keywords
;
|k__al|equ|24,k_alp-k_alp|||; alphabet| 4020
|k__rt|equ|24,k_rtn-k_alp|||; rtntype| 4021
|k__sc|equ|24,k_stc-k_alp|||; stcount| 4022
|k__et|equ|24,k_etx-k_alp|||; errtext| 4023
|k__fl|equ|24,k_fil-k_alp|||; file| 4025
|k__lf|equ|24,k_lfl-k_alp|||; lastfile| 4026
|k__sl|equ|24,k_stl-k_alp|||; stlimit| 4028
|k__lc|equ|24,k_lcs-k_alp|||; lcase| 4030
|k__uc|equ|24,k_ucs-k_alp|||; ucase| 4031
|k__n_|equ|24,k__uc+1|||; number of special cases| 4032
;
;      symbols used in asign and acess procedures
;
|k_p__|equ|24,k_fnc|||; first protected keyword| 4039
|k_v__|equ|24,k_abo|||; first keyword with constant value| 4040
|k_s__|equ|24,k_alp|||; first keyword with special acess| 4041
||ejc||||| 4042
;
;      format of a table block (tbblk)
;
;      a table block is used to represent a table value.
;      it is built by a call to the table or convert functions.
;
;	    +------------------------------------+
;	    i		     tbtyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     tblen		 i
;	    +------------------------------------+
;	    i		     tbinv		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     tbbuk		 /
;	    /					 /
;	    +------------------------------------+
;
|tbtyp|equ|24,0|||; pointer to dummy routine b_tbt| 4063
|tblen|equ|24,offs2|||; length of tbblk in bytes| 4064
|tbinv|equ|24,offs3|||; default initial lookup value| 4065
|tbbuk|equ|24,tbinv+1|||; start of hash bucket pointers| 4066
|tbsi_|equ|24,tbbuk|||; size of standard fields in tbblk| 4067
|tbnbk|equ|24,11|||; default no. of buckets| 4068
;
;      the table block is a hash table which points to chains
;      of table element blocks representing the elements
;      in the table which hash into the same bucket.
;
;      tbbuk entries either point to the first teblk on the
;      chain or they point to the tbblk itself to indicate the
;      end of the chain.
||ejc||||| 4077
;
;      table element block (teblk)
;
;      a table element is used to represent a single entry in
;      a table (see description of tbblk format for hash table)
;
;	    +------------------------------------+
;	    i		     tetyp		 i
;	    +------------------------------------+
;	    i		     tesub		 i
;	    +------------------------------------+
;	    i		     teval		 i
;	    +------------------------------------+
;	    i		     tenxt		 i
;	    +------------------------------------+
;
|tetyp|equ|24,0|||; pointer to dummy routine b_tet| 4094
|tesub|equ|24,tetyp+1|||; subscript value| 4095
|teval|equ|24,tesub+1|||; (=vrval) table element value| 4096
|tenxt|equ|24,teval+1|||; link to next teblk| 4097
;      see s_cnv where relation is assumed with tenxt and tbbuk
|tesi_|equ|24,tenxt+1|||; size of teblk in words| 4099
;
;      tenxt points to the next teblk on the hash chain from the
;      tbbuk chain for this hash index. at the end of the chain,
;      tenxt points back to the start of the tbblk.
;
;      teval contains a data pointer or a trblk pointer.
;
;      tesub contains a data pointer.
||ejc||||| 4108
;
;      trap block (trblk)
;
;      a trap block is used to represent a trace or input or
;      output association in response to a call to the trace
;      input or output system functions. see below for details
;
;	    +------------------------------------+
;	    i		     tridn		 i
;	    +------------------------------------+
;	    i		     trtyp		 i
;	    +------------------------------------+
;	    i  trval or trlbl or trnxt or trkvr	 i
;	    +------------------------------------+
;	    i	    trtag or trter or trtrf	 i
;	    +------------------------------------+
;	    i		 trfnc or trfpt		 i
;	    +------------------------------------+
;
|tridn|equ|24,0|||; pointer to dummy routine b_trt| 4128
|trtyp|equ|24,tridn+1|||; trap type code| 4129
|trval|equ|24,trtyp+1|||; value of trapped variable (=vrval)| 4130
|trnxt|equ|24,trval|||; ptr to next trblk on trblk chain| 4131
|trlbl|equ|24,trval|||; ptr to actual label (traced label)| 4132
|trkvr|equ|24,trval|||; vrblk pointer for keyword trace| 4133
|trtag|equ|24,trval+1|||; trace tag| 4134
|trter|equ|24,trtag|||; ptr to terminal vrblk or null| 4135
|trtrf|equ|24,trtag|||; ptr to trblk holding fcblk ptr| 4136
|trfnc|equ|24,trtag+1|||; trace function vrblk (zero if none)| 4137
|trfpt|equ|24,trfnc|||; fcblk ptr for sysio| 4138
|trsi_|equ|24,trfnc+1|||; number of words in trblk| 4139
;
|trtin|equ|24,0|||; trace type for input association| 4141
|trtac|equ|24,trtin+1|||; trace type for access trace| 4142
|trtvl|equ|24,trtac+1|||; trace type for value trace| 4143
|trtou|equ|24,trtvl+1|||; trace type for output association| 4144
|trtfc|equ|24,trtou+1|||; trace type for fcblk identification| 4145
||ejc||||| 4146
;
;      trap block (continued)
;
;      variable input association
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtin
;	    trnxt points to next trblk or trval has variable val
;	    trter is a pointer to svblk if association is
;	    for input, terminal, else it is null.
;	    trtrf points to the trap block which in turn points
;	    to an fcblk used for i/o association.
;	    trfpt is the fcblk ptr returned by sysio.
;
;      variable access trace association
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtac
;	    trnxt points to next trblk or trval has variable val
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      variable value trace association
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtvl
;	    trnxt points to next trblk or trval has variable val
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
||ejc||||| 4188
;      trap block (continued)
;
;      variable output association
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case
;	    of a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv to activate the check.
;
;	    trtyp is set to trtou
;	    trnxt points to next trblk or trval has variable val
;	    trter is a pointer to svblk if association is
;	    for output, terminal, else it is null.
;	    trtrf points to the trap block which in turn points
;	    to an fcblk used for i/o association.
;	    trfpt is the fcblk ptr returned by sysio.
;
;      function call trace
;
;	    the pfctr field of the corresponding pfblk is set
;	    to point to a trblk.
;
;	    trtyp is set to trtin
;	    trnxt is zero
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      function return trace
;
;	    the pfrtr field of the corresponding pfblk is set
;	    to point to a trblk
;
;	    trtyp is set to trtin
;	    trnxt is zero
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      label trace
;
;	    the vrlbl of the vrblk for the label is
;	    changed to point to a trblk and the vrtra field is
;	    set to b_vrt to activate the check.
;
;	    trtyp is set to trtin
;	    trlbl points to the actual label (cdblk) value
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
||ejc||||| 4236
;
;      trap block (continued)
;
;      keyword trace
;
;	    keywords which can be traced possess a unique
;	    location which is zero if there is no trace and
;	    points to a trblk if there is a trace. the locations
;	    are as follows.
;
;	    r_ert	     errtype
;	    r_fnc	     fnclevel
;	    r_stc	     stcount
;
;	    the format of the trblk is as follows.
;
;	    trtyp is set to trtin
;	    trkvr is a pointer to the vrblk for the keyword
;	    trtag is the trace tag (0 if none)
;	    trfnc is the trace function vrblk ptr (0 if none)
;
;      input/output file arg1 trap block
;
;	    the value field of the variable points to a trblk
;	    instead of containing the data value. in the case of
;	    a natural variable, the vrget and vrsto fields
;	    contain =b_vra and =b_vrv. this trap block is used
;	    to hold a pointer to the fcblk which an
;	    implementation may request to hold information
;	    about a file.
;
;	    trtyp is set to trtfc
;	    trnext points to next trblk or trval is variable val
;	    trfnm is 0
;	    trfpt is the fcblk pointer.
;
;      note that when multiple traps are set on a variable
;      the order is in ascending value of trtyp field.
;
;      input association (if present)
;      access trace (if present)
;      value trace (if present)
;      output association (if present)
;
;      the actual value of the variable is stored in the trval
;      field of the last trblk on the chain.
;
;      this implementation does not permit trace or i/o
;      associations to any of the pseudo-variables.
||ejc||||| 4286
;
;      vector block (vcblk)
;
;      a vcblk is used to represent an array value which has
;      one dimension whose lower bound is one. all other arrays
;      are represented by arblks. a vcblk is created by the
;      system function array (s_arr) when passed an integer arg.
;
;	    +------------------------------------+
;	    i		     vctyp		 i
;	    +------------------------------------+
;	    i		     idval		 i
;	    +------------------------------------+
;	    i		     vclen		 i
;	    +------------------------------------+
;	    i		     vcvls		 i
;	    +------------------------------------+
;
|vctyp|equ|24,0|||; pointer to dummy routine b_vct| 4305
|vclen|equ|24,offs2|||; length of vcblk in bytes| 4306
|vcvls|equ|24,offs3|||; start of vector values| 4307
|vcsi_|equ|24,vcvls|||; size of standard fields in vcblk| 4308
|vcvlb|equ|24,vcvls-1|||; offset one word behind vcvls| 4309
|vctbd|equ|24,tbsi_-vcsi_|||; difference in sizes - see prtvl| 4310
;
;      vcvls are either data pointers or trblk pointers
;
;      the dimension can be deduced from vclen.
||ejc||||| 4315
;
;      variable block (vrblk)
;
;      a variable block is built in the static memory area
;      for every variable referenced or created by a program.
;      the order of fields is assumed in the model vrblk stnvr.
;
;      note that since these blocks only occur in the static
;      region, it is permissible to point to any word in
;      the block and this is used to provide three distinct
;      access points from the generated code as follows.
;
;      1)   point to vrget (first word of vrblk) to load the
;	    value of the variable onto the main stack.
;
;      2)   point to vrsto (second word of vrblk) to store the
;	    top stack element as the value of the variable.
;
;      3)   point to vrtra (fourth word of vrblk) to jump to
;	    the label associated with the variable name.
;
;	    +------------------------------------+
;	    i		     vrget		 i
;	    +------------------------------------+
;	    i		     vrsto		 i
;	    +------------------------------------+
;	    i		     vrval		 i
;	    +------------------------------------+
;	    i		     vrtra		 i
;	    +------------------------------------+
;	    i		     vrlbl		 i
;	    +------------------------------------+
;	    i		     vrfnc		 i
;	    +------------------------------------+
;	    i		     vrnxt		 i
;	    +------------------------------------+
;	    i		     vrlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		 vrchs = vrsvp		 /
;	    /					 /
;	    +------------------------------------+
||ejc||||| 4358
;
;      variable block (continued)
;
|vrget|equ|24,0|||; pointer to routine to load value| 4362
|vrsto|equ|24,vrget+1|||; pointer to routine to store value| 4363
|vrval|equ|24,vrsto+1|||; variable value| 4364
|vrvlo|equ|24,vrval-vrsto|||; offset to value from store field| 4365
|vrtra|equ|24,vrval+1|||; pointer to routine to jump to label| 4366
|vrlbl|equ|24,vrtra+1|||; pointer to code for label| 4367
|vrlbo|equ|24,vrlbl-vrtra|||; offset to label from transfer field| 4368
|vrfnc|equ|24,vrlbl+1|||; pointer to function block| 4369
|vrnxt|equ|24,vrfnc+1|||; pointer to next vrblk on hash chain| 4370
|vrlen|equ|24,vrnxt+1|||; length of name (or zero)| 4371
|vrchs|equ|24,vrlen+1|||; characters of name (vrlen gt 0)| 4372
|vrsvp|equ|24,vrlen+1|||; ptr to svblk (vrlen eq 0)| 4373
|vrsi_|equ|24,vrchs+1|||; number of standard fields in vrblk| 4374
|vrsof|equ|24,vrlen-sclen|||; offset to dummy scblk for name| 4375
|vrsvo|equ|24,vrsvp-vrsof|||; pseudo-offset to vrsvp field| 4376
;
;      vrget = b_vrl if not input associated or access traced
;      vrget = b_vra if input associated or access traced
;
;      vrsto = b_vrs if not output associated or value traced
;      vrsto = b_vrv if output associated or value traced
;      vrsto = b_vre if value is protected pattern value
;
;      vrval points to the appropriate value unless the
;      variable is i/o/trace associated in which case, vrval
;      points to an appropriate trblk (trap block) chain.
;
;      vrtra = b_vrg if the label is not traced
;      vrtra = b_vrt if the label is traced
;
;      vrlbl points to a cdblk if there is a label
;      vrlbl points to the svblk svlbl field for a system label
;      vrlbl points to stndl for an undefined label
;      vrlbl points to a trblk if the label is traced
;
;      vrfnc points to a ffblk for a field function
;      vrfnc points to a dfblk for a datatype function
;      vrfnc points to a pfblk for a program defined function
;      vrfnc points to a efblk for an external loaded function
;      vrfnc points to svfnc (svblk) for a system function
;      vrfnc points to stndf if the function is undefined
;
;      vrnxt points to the next vrblk on this chain unless
;      this is the end of the chain in which case it is zero.
;
;      vrlen is the name length for a non-system variable.
;      vrlen is zero for a system variable.
;
;      vrchs is the name (ljrz) if vrlen is non-zero.
;      vrsvp is a ptr to the svblk if vrlen is zero.
||ejc||||| 4412
;
;      format of a non-relocatable external block (xnblk)
;
;      an xnblk is a block representing an unknown (external)
;      data value. the block contains no pointers to other
;      relocatable blocks. an xnblk is used by external function
;      processing or possibly for system i/o routines etc.
;      the macro-system itself does not use xnblks.
;      this type of block may be used as a file control block.
;      see sysfc,sysin,sysou,s_inp,s_oup for details.
;
;	    +------------------------------------+
;	    i		     xntyp		 i
;	    +------------------------------------+
;	    i		     xnlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     xndta		 /
;	    /					 /
;	    +------------------------------------+
;
|xntyp|equ|24,0|||; pointer to dummy routine b_xnt| 4434
|xnlen|equ|24,xntyp+1|||; length of xnblk in bytes| 4435
|xndta|equ|24,xnlen+1|||; data words| 4436
|xnsi_|equ|24,xndta|||; size of standard fields in xnblk| 4437
;
;      note that the term non-relocatable refers to the contents
;      and not the block itself. an xnblk can be moved around if
;      it is built in the dynamic memory area.
||ejc||||| 4442
;
;      relocatable external block (xrblk)
;
;      an xrblk is a block representing an unknown (external)
;      data value. the data area in this block consists only
;      of address values and any addresses pointing into the
;      dynamic memory area must point to the start of other
;      data blocks. see also description of xnblk.
;      this type of block may be used as a file control block.
;      see sysfc,sysin,sysou,s_inp,s_oup for details.
;
;	    +------------------------------------+
;	    i		     xrtyp		 i
;	    +------------------------------------+
;	    i		     xrlen		 i
;	    +------------------------------------+
;	    /					 /
;	    /		     xrptr		 /
;	    /					 /
;	    +------------------------------------+
;
|xrtyp|equ|24,0|||; pointer to dummy routine b_xrt| 4464
|xrlen|equ|24,xrtyp+1|||; length of xrblk in bytes| 4465
|xrptr|equ|24,xrlen+1|||; start of address pointers| 4466
|xrsi_|equ|24,xrptr|||; size of standard fields in xrblk| 4467
||ejc||||| 4468
;
;      s_cnv (convert) function switch constants.  the values
;      are tied to the order of the entries in the svctb table
;      and hence to the branch table in s_cnv.
;
|cnvst|equ|24,8|||; max standard type code for convert| 4474
|cnvrt|equ|24,cnvst+1|||; convert code for reals| 4478
|cnvbt|equ|24,cnvrt|||; no buffers - same as real code| 4481
|cnvtt|equ|24,cnvbt+1|||; bsw code for convert| 4485
;
;      input image length
;
|iniln|equ|24,1024|||; default image length for compiler| 4489
|inils|equ|24,1024|||; image length if -sequ in effect| 4490
;
|ionmb|equ|24,2|||; name base used for iochn in sysio| 4492
|ionmo|equ|24,4|||; name offset used for iochn in sysio| 4493
;
;      minimum value for keyword maxlngth
;      should be larger than iniln
;
|mnlen|equ|24,1024|||; min value allowed keyword maxlngth| 4498
|mxern|equ|24,329|||; err num inadequate startup memory| 4499
;
;      in general, meaningful mnemonics should be used for
;      offsets. however for small integers used often in
;      literals the following general definitions are provided.
;
|num01|equ|24,1|||;| 4505
|num02|equ|24,2|||;| 4506
|num03|equ|24,3|||;| 4507
|num04|equ|24,4|||;| 4508
|num05|equ|24,5|||;| 4509
|num06|equ|24,6|||;| 4510
|num07|equ|24,7|||;| 4511
|num08|equ|24,8|||;| 4512
|num09|equ|24,9|||;| 4513
|num10|equ|24,10|||;| 4514
|num25|equ|24,25|||;| 4515
|nm320|equ|24,320|||;| 4516
|nm321|equ|24,321|||;| 4517
|nini8|equ|24,998|||;| 4518
|nini9|equ|24,999|||;| 4519
|thsnd|equ|24,1000|||;| 4520
||ejc||||| 4521
;
;      numbers of undefined spitbol operators
;
|opbun|equ|24,5|||; no. of binary undefined ops| 4525
|opuun|equ|24,6|||; no of unary undefined ops| 4526
;
;      offsets used in prtsn, prtmi and acess
;
|prsnf|equ|24,13|||; offset used in prtsn| 4530
|prtmf|equ|24,21|||; offset to col 21 (prtmi)| 4531
|rilen|equ|24,1024|||; buffer length for sysri| 4532
;
;      codes for stages of processing
;
|stgic|equ|24,0|||; initial compile| 4536
|stgxc|equ|24,stgic+1|||; execution compile (code)| 4537
|stgev|equ|24,stgxc+1|||; expression eval during execution| 4538
|stgxt|equ|24,stgev+1|||; execution time| 4539
|stgce|equ|24,stgxt+1|||; initial compile after end line| 4540
|stgxe|equ|24,stgce+1|||; exec. compile after end line| 4541
|stgnd|equ|24,stgce-stgic|||; difference in stage after end| 4542
|stgee|equ|24,stgxe+1|||; eval evaluating expression| 4543
|stgno|equ|24,stgee+1|||; number of codes| 4544
||ejc||||| 4545
;
;
;      statement number pad count for listr
;
|stnpd|equ|24,8|||; statement no. pad count| 4554
;
;      syntax type codes
;
;      these codes are returned from the scane procedure.
;
;      they are spaced 3 apart for the benefit of expan.
;
|t_uop|equ|24,0|||; unary operator| 4566
|t_lpr|equ|24,t_uop+3|||; left paren| 4567
|t_lbr|equ|24,t_lpr+3|||; left bracket| 4568
|t_cma|equ|24,t_lbr+3|||; comma| 4569
|t_fnc|equ|24,t_cma+3|||; function call| 4570
|t_var|equ|24,t_fnc+3|||; variable| 4571
|t_con|equ|24,t_var+3|||; constant| 4572
|t_bop|equ|24,t_con+3|||; binary operator| 4573
|t_rpr|equ|24,t_bop+3|||; right paren| 4574
|t_rbr|equ|24,t_rpr+3|||; right bracket| 4575
|t_col|equ|24,t_rbr+3|||; colon| 4576
|t_smc|equ|24,t_col+3|||; semi-colon| 4577
;
;      the following definitions are used only in the goto field
;
|t_fgo|equ|24,t_smc+1|||; failure goto| 4581
|t_sgo|equ|24,t_fgo+1|||; success goto| 4582
;
;      the above codes are grouped so that codes for elements
;      which can legitimately immediately precede a unary
;      operator come first to facilitate operator syntax check.
;
|t_uok|equ|24,t_fnc|||; last code ok before unary operator| 4588
||ejc||||| 4589
;
;      definitions of values for expan jump table
;
|t_uo0|equ|24,t_uop+0|||; unary operator, state zero| 4593
|t_uo1|equ|24,t_uop+1|||; unary operator, state one| 4594
|t_uo2|equ|24,t_uop+2|||; unary operator, state two| 4595
|t_lp0|equ|24,t_lpr+0|||; left paren, state zero| 4596
|t_lp1|equ|24,t_lpr+1|||; left paren, state one| 4597
|t_lp2|equ|24,t_lpr+2|||; left paren, state two| 4598
|t_lb0|equ|24,t_lbr+0|||; left bracket, state zero| 4599
|t_lb1|equ|24,t_lbr+1|||; left bracket, state one| 4600
|t_lb2|equ|24,t_lbr+2|||; left bracket, state two| 4601
|t_cm0|equ|24,t_cma+0|||; comma, state zero| 4602
|t_cm1|equ|24,t_cma+1|||; comma, state one| 4603
|t_cm2|equ|24,t_cma+2|||; comma, state two| 4604
|t_fn0|equ|24,t_fnc+0|||; function call, state zero| 4605
|t_fn1|equ|24,t_fnc+1|||; function call, state one| 4606
|t_fn2|equ|24,t_fnc+2|||; function call, state two| 4607
|t_va0|equ|24,t_var+0|||; variable, state zero| 4608
|t_va1|equ|24,t_var+1|||; variable, state one| 4609
|t_va2|equ|24,t_var+2|||; variable, state two| 4610
|t_co0|equ|24,t_con+0|||; constant, state zero| 4611
|t_co1|equ|24,t_con+1|||; constant, state one| 4612
|t_co2|equ|24,t_con+2|||; constant, state two| 4613
|t_bo0|equ|24,t_bop+0|||; binary operator, state zero| 4614
|t_bo1|equ|24,t_bop+1|||; binary operator, state one| 4615
|t_bo2|equ|24,t_bop+2|||; binary operator, state two| 4616
|t_rp0|equ|24,t_rpr+0|||; right paren, state zero| 4617
|t_rp1|equ|24,t_rpr+1|||; right paren, state one| 4618
|t_rp2|equ|24,t_rpr+2|||; right paren, state two| 4619
|t_rb0|equ|24,t_rbr+0|||; right bracket, state zero| 4620
|t_rb1|equ|24,t_rbr+1|||; right bracket, state one| 4621
|t_rb2|equ|24,t_rbr+2|||; right bracket, state two| 4622
|t_cl0|equ|24,t_col+0|||; colon, state zero| 4623
|t_cl1|equ|24,t_col+1|||; colon, state one| 4624
|t_cl2|equ|24,t_col+2|||; colon, state two| 4625
|t_sm0|equ|24,t_smc+0|||; semicolon, state zero| 4626
|t_sm1|equ|24,t_smc+1|||; semicolon, state one| 4627
|t_sm2|equ|24,t_smc+2|||; semicolon, state two| 4628
;
|t_nes|equ|24,t_sm2+1|||; number of entries in branch table| 4630
||ejc||||| 4631
;
;	definition of offsets used in control card processing
;
|cc_ca|equ|24,0|||; -case| 4636
|cc_do|equ|24,cc_ca+1|||; -double| 4637
|cc_co|equ|24,cc_do+1|||; -compare| 4642
|cc_du|equ|24,cc_co+1|||; -dump| 4643
|cc_cp|equ|24,cc_du+1|||; -copy| 4648
|cc_ej|equ|24,cc_cp+1|||; -eject| 4649
|cc_er|equ|24,cc_ej+1|||; -errors| 4653
|cc_ex|equ|24,cc_er+1|||; -execute| 4654
|cc_fa|equ|24,cc_ex+1|||; -fail| 4655
|cc_in|equ|24,cc_fa+1|||; -include| 4657
|cc_ln|equ|24,cc_in+1|||; -line| 4659
|cc_li|equ|24,cc_ln+1|||; -list| 4660
|cc_nr|equ|24,cc_li+1|||; -noerrors| 4672
|cc_nx|equ|24,cc_nr+1|||; -noexecute| 4673
|cc_nf|equ|24,cc_nx+1|||; -nofail| 4674
|cc_nl|equ|24,cc_nf+1|||; -nolist| 4675
|cc_no|equ|24,cc_nl+1|||; -noopt| 4676
|cc_np|equ|24,cc_no+1|||; -noprint| 4677
|cc_op|equ|24,cc_np+1|||; -optimise| 4678
|cc_pr|equ|24,cc_op+1|||; -print| 4679
|cc_si|equ|24,cc_pr+1|||; -single| 4680
|cc_sp|equ|24,cc_si+1|||; -space| 4681
|cc_st|equ|24,cc_sp+1|||; -stitl| 4682
|cc_ti|equ|24,cc_st+1|||; -title| 4683
|cc_tr|equ|24,cc_ti+1|||; -trace| 4684
|cc_nc|equ|24,cc_tr+1|||; number of control cards| 4685
|ccnoc|equ|24,4|||; no. of chars included in match| 4686
|ccofs|equ|24,7|||; offset to start of title/subtitle| 4687
|ccinm|equ|24,9|||; max depth of include file nesting| 4689
||ejc||||| 4691
;
;      definitions of stack offsets used in cmpil procedure
;
;      see description at start of cmpil procedure for details
;      of use of these locations on the stack.
;
|cmstm|equ|24,0|||; tree for statement body| 4698
|cmsgo|equ|24,cmstm+1|||; tree for success goto| 4699
|cmfgo|equ|24,cmsgo+1|||; tree for fail goto| 4700
|cmcgo|equ|24,cmfgo+1|||; conditional goto flag| 4701
|cmpcd|equ|24,cmcgo+1|||; previous cdblk pointer| 4702
|cmffp|equ|24,cmpcd+1|||; failure fill in flag for previous| 4703
|cmffc|equ|24,cmffp+1|||; failure fill in flag for current| 4704
|cmsop|equ|24,cmffc+1|||; success fill in offset for previous| 4705
|cmsoc|equ|24,cmsop+1|||; success fill in offset for current| 4706
|cmlbl|equ|24,cmsoc+1|||; ptr to vrblk for current label| 4707
|cmtra|equ|24,cmlbl+1|||; ptr to entry cdblk| 4708
;
|cmnen|equ|24,cmtra+1|||; count of stack entries for cmpil| 4710
;
;      a few constants used by the profiler
|pfpd1|equ|24,8|||; pad positions ...| 4715
|pfpd2|equ|24,20|||; ... for profile ...| 4716
|pfpd3|equ|24,32|||; ... printout| 4717
|pf_i2|equ|24,cfp_i+cfp_i|||; size of table entry (2 ints)| 4718
||ejc||||| 4721
;
;      definition of limits and adjustments that are built by
;      relcr for use by the routines that relocate pointers
;      after a save file is reloaded.  see reloc etc. for usage.
;
;      a block of information is built that is used in
;      relocating pointers.  there are rnsi_ instances
;      of a rssi_ word structure.  each instance corresponds
;      to one of the regions that a pointer might point into.
;
;      each structure takes the form:
;
;	    +------------------------------------+
;	    i	 address past end of section	 i
;	    +------------------------------------+
;	    i  adjustment from old to new adrs	 i
;	    +------------------------------------+
;	    i	 address of start of section	 i
;	    +------------------------------------+
;
;      the instances are ordered thusly:
;
;	    +------------------------------------+
;	    i		dynamic storage		 i
;	    +------------------------------------+
;	    i		static storage		 i
;	    +------------------------------------+
;	    i	    working section globals	 i
;	    +------------------------------------+
;	    i	       constant section		 i
;	    +------------------------------------+
;	    i		 code section		 i
;	    +------------------------------------+
;
;      symbolic names for these locations as offsets from
;      the first entry are provided here.
;
;      definitions within a section
;
|rlend|equ|24,0|||; end| 4761
|rladj|equ|24,rlend+1|||; adjustment| 4762
|rlstr|equ|24,rladj+1|||; start| 4763
|rssi_|equ|24,rlstr+1|||; size of section| 4764
|rnsi_|equ|24,5|||; number of structures| 4765
;
;      overall definitions of all structures
;
|rldye|equ|24,0|||; dynamic region end| 4769
|rldya|equ|24,rldye+1|||; dynamic region adjustment| 4770
|rldys|equ|24,rldya+1|||; dynamic region start| 4771
|rlste|equ|24,rldys+1|||; static region end| 4772
|rlsta|equ|24,rlste+1|||; static region adjustment| 4773
|rlsts|equ|24,rlsta+1|||; static region start| 4774
|rlwke|equ|24,rlsts+1|||; working section globals end| 4775
|rlwka|equ|24,rlwke+1|||; working section globals adjustment| 4776
|rlwks|equ|24,rlwka+1|||; working section globals start| 4777
|rlcne|equ|24,rlwks+1|||; constants section end| 4778
|rlcna|equ|24,rlcne+1|||; constants section adjustment| 4779
|rlcns|equ|24,rlcna+1|||; constants section start| 4780
|rlcde|equ|24,rlcns+1|||; code section end| 4781
|rlcda|equ|24,rlcde+1|||; code section adjustment| 4782
|rlcds|equ|24,rlcda+1|||; code section start| 4783
|rlsi_|equ|24,rlcds+1|||; number of fields in structure| 4784
;
||ttl|27,s p i t b o l -- constant section|||| 4787
;
;      this section consists entirely of assembled constants.
;
;      all label names are five letters. the order is
;      approximately alphabetical, but in some cases (always
;      documented), constants must be placed in some special
;      order which must not be disturbed.
;
;      it must also be remembered that there is a requirement
;      for no forward references which also disturbs the
;      alphabetical order in some cases.
;
||sec||||; start of constant section| 4800
;
;      start of constant section
;
|c_aaa|dac|1,0|||; first location of constant section| 4804
;
;      free store percentage (used by alloc)
;
|alfsp|dac|2,e_fsp|||; free store percentage| 4808
;
;      bit constants for general use
;
|bits0|dbc|1,0|||; all zero bits| 4812
|bits1|dbc|1,1|||; one bit in low order position| 4813
|bits2|dbc|1,2|||; bit in position 2| 4814
|bits3|dbc|1,4|||; bit in position 3| 4815
|bits4|dbc|1,8|||; bit in position 4| 4816
|bits5|dbc|1,16|||; bit in position 5| 4817
|bits6|dbc|1,32|||; bit in position 6| 4818
|bits7|dbc|1,64|||; bit in position 7| 4819
|bits8|dbc|1,128|||; bit in position 8| 4820
|bits9|dbc|1,256|||; bit in position 9| 4821
|bit10|dbc|1,512|||; bit in position 10| 4822
|bit11|dbc|1,1024|||; bit in position 11| 4823
|bit12|dbc|1,2048|||; bit in position 12| 4824
;bitsm	dbc  cfp_m	      mask for max integer
|bitsm|dbc|1,0|||; mask for max integer (value filled in at runtime)| 4826
;
;      bit constants for svblk (svbit field) tests
;
|btfnc|dbc|2,svfnc|||; bit to test for function| 4830
|btknm|dbc|2,svknm|||; bit to test for keyword number| 4831
|btlbl|dbc|2,svlbl|||; bit to test for label| 4832
|btffc|dbc|2,svffc|||; bit to test for fast call| 4833
|btckw|dbc|2,svckw|||; bit to test for constant keyword| 4834
|btkwv|dbc|2,svkwv|||; bits to test for keword with value| 4835
|btprd|dbc|2,svprd|||; bit to test for predicate function| 4836
|btpre|dbc|2,svpre|||; bit to test for preevaluation| 4837
|btval|dbc|2,svval|||; bit to test for value| 4838
||ejc||||| 4839
;
;      list of names used for control card processing
;
|ccnms|dtc|27,/case/|||| 4844
||dtc|27,/doub/|||| 4845
||dtc|27,/comp/|||| 4850
||dtc|27,/dump/|||| 4852
||dtc|27,/copy/|||| 4854
||dtc|27,/ejec/|||| 4856
||dtc|27,/erro/|||| 4857
||dtc|27,/exec/|||| 4858
||dtc|27,/fail/|||| 4859
||dtc|27,/incl/|||| 4861
||dtc|27,/line/|||| 4864
||dtc|27,/list/|||| 4866
||dtc|27,/noer/|||| 4867
||dtc|27,/noex/|||| 4868
||dtc|27,/nofa/|||| 4869
||dtc|27,/noli/|||| 4870
||dtc|27,/noop/|||| 4871
||dtc|27,/nopr/|||| 4872
||dtc|27,/opti/|||| 4873
||dtc|27,/prin/|||| 4874
||dtc|27,/sing/|||| 4875
||dtc|27,/spac/|||| 4876
||dtc|27,/stit/|||| 4877
||dtc|27,/titl/|||| 4878
||dtc|27,/trac/|||| 4879
;
;      header messages for dumpr procedure (scblk format)
;
|dmhdk|dac|6,b_scl|||; dump of keyword values| 4883
||dac|1,22|||;| 4884
||dtc|27,/dump of keyword values/|||| 4885
;
|dmhdv|dac|6,b_scl|||; dump of natural variables| 4887
||dac|1,25|||;| 4888
||dtc|27,/dump of natural variables/|||| 4889
||ejc||||| 4890
;
;      message text for compilation statistics
;
|encm1|dac|6,b_scl|||;| 4894
||dac|1,19|||;| 4896
||dtc|27,/memory used (bytes)/|||| 4897
;
|encm2|dac|6,b_scl|||;| 4899
||dac|1,19|||;| 4900
||dtc|27,/memory left (bytes)/|||| 4901
;
|encm3|dac|6,b_scl|||;| 4911
||dac|1,11|||;| 4912
||dtc|27,/comp errors/|||| 4913
;
|encm4|dac|6,b_scl|||;| 4915
||dac|1,20|||;| 4920
||dtc|27,/comp time (millisec)/|||| 4921
;
|encm5|dac|6,b_scl|||; execution suppressed| 4924
||dac|1,20|||;| 4925
||dtc|27,/execution suppressed/|||| 4926
;
;      string constant for abnormal end
;
|endab|dac|6,b_scl|||;| 4930
||dac|1,12|||;| 4931
||dtc|27,/abnormal end/|||| 4932
||ejc||||| 4933
;
;      memory overflow during initialisation
;
|endmo|dac|6,b_scl|||;| 4937
|endml|dac|1,15|||;| 4938
||dtc|27,/memory overflow/|||| 4939
;
;      string constant for message issued by l_end
;
|endms|dac|6,b_scl|||;| 4943
||dac|1,10|||;| 4944
||dtc|27,/normal end/|||| 4945
;
;      fail message for stack fail section
;
|endso|dac|6,b_scl|||; stack overflow in garbage collector| 4949
||dac|1,36|||;| 4950
||dtc|27,/stack overflow in garbage collection/|||| 4951
;
;      string constant for time up
;
|endtu|dac|6,b_scl|||;| 4955
||dac|1,15|||;| 4956
||dtc|27,/error - time up/|||| 4957
||ejc||||| 4958
;
;      string constant for error message (error section)
;
|ermms|dac|6,b_scl|||; error| 4962
||dac|1,5|||;| 4963
||dtc|27,/error/|||| 4964
;
|ermns|dac|6,b_scl|||; string / -- /| 4966
||dac|1,4|||;| 4967
||dtc|27,/ -- /|||| 4968
;
;      string constant for page numbering
;
|lstms|dac|6,b_scl|||; page| 4972
||dac|1,5|||;| 4973
||dtc|27,/page /|||| 4974
;
;      listing header message
;
|headr|dac|6,b_scl|||;| 4978
||dac|1,27|||;| 4979
||dtc|27,/macro spitbol version 15.01/|||| 4980
;
|headv|dac|6,b_scl|||; for exit() version no. check| 4982
||dac|1,5|||;| 4983
||dtc|27,/15.01/|||| 4984
;      free store percentage (used by gbcol)
;
|gbsdp|dac|2,e_sed|||; sediment percentage| 4988
;
;      integer constants for general use
;      icbld optimisation uses the first three.
;
|int_r|dac|6,b_icl|||;| 4994
|intv0|dic|16,+0|||; 0| 4995
|inton|dac|6,b_icl|||;| 4996
|intv1|dic|16,+1|||; 1| 4997
|inttw|dac|6,b_icl|||;| 4998
|intv2|dic|16,+2|||; 2| 4999
|intvt|dic|16,+10|||; 10| 5000
|intvh|dic|16,+100|||; 100| 5001
|intth|dic|16,+1000|||; 1000| 5002
;
;      table used in icbld optimisation
;
|intab|dac|4,int_r|||; pointer to 0| 5006
||dac|4,inton|||; pointer to 1| 5007
||dac|4,inttw|||; pointer to 2| 5008
||ejc||||| 5009
;
;      special pattern nodes. the following pattern nodes
;      consist simply of a pcode pointer, see match routines
;      (p_xxx) for full details of their use and format).
;
|ndabb|dac|6,p_abb|||; arbno| 5015
|ndabd|dac|6,p_abd|||; arbno| 5016
|ndarc|dac|6,p_arc|||; arb| 5017
|ndexb|dac|6,p_exb|||; expression| 5018
|ndfnb|dac|6,p_fnb|||; fence()| 5019
|ndfnd|dac|6,p_fnd|||; fence()| 5020
|ndexc|dac|6,p_exc|||; expression| 5021
|ndimb|dac|6,p_imb|||; immediate assignment| 5022
|ndimd|dac|6,p_imd|||; immediate assignment| 5023
|ndnth|dac|6,p_nth|||; pattern end (null pattern)| 5024
|ndpab|dac|6,p_pab|||; pattern assignment| 5025
|ndpad|dac|6,p_pad|||; pattern assignment| 5026
|nduna|dac|6,p_una|||; anchor point movement| 5027
;
;      keyword constant pattern nodes. the following nodes are
;      used as the values of pattern keywords and the initial
;      values of the corresponding natural variables. all
;      nodes are in p0blk format and the order is tied to the
;      definitions of corresponding k_xxx symbols.
;
|ndabo|dac|6,p_abo|||; abort| 5035
||dac|4,ndnth|||;| 5036
|ndarb|dac|6,p_arb|||; arb| 5037
||dac|4,ndnth|||;| 5038
|ndbal|dac|6,p_bal|||; bal| 5039
||dac|4,ndnth|||;| 5040
|ndfal|dac|6,p_fal|||; fail| 5041
||dac|4,ndnth|||;| 5042
|ndfen|dac|6,p_fen|||; fence| 5043
||dac|4,ndnth|||;| 5044
|ndrem|dac|6,p_rem|||; rem| 5045
||dac|4,ndnth|||;| 5046
|ndsuc|dac|6,p_suc|||; succeed| 5047
||dac|4,ndnth|||;| 5048
;
;      null string. all null values point to this string. the
;      svchs field contains a blank to provide for easy default
;      processing in trace, stoptr, lpad and rpad.
;      nullw contains 10 blanks which ensures an all blank word
;      but for very exceptional machines.
;
|nulls|dac|6,b_scl|||; null string value| 5056
||dac|1,0|||; sclen = 0| 5057
|nullw|dtc|27,/          /|||| 5058
;
;
;      constant strings for lcase and ucase keywords
;
|lcase|dac|6,b_scl|||;| 5064
||dac|1,26|||;| 5065
||dtc|27,/abcdefghijklmnopqrstuvwxyz/|||| 5066
;
|ucase|dac|6,b_scl|||;| 5068
||dac|1,26|||;| 5069
||dtc|27,/ABCDEFGHIJKLMNOPQRSTUVWXYZ/|||| 5070
||ejc||||| 5072
;
;      operator dope vectors (see dvblk format)
;
|opdvc|dac|6,o_cnc|||; concatenation| 5076
||dac|2,c_cnc|||;| 5077
||dac|2,llcnc|||;| 5078
||dac|2,rrcnc|||;| 5079
;
;      opdvs is used when scanning below the top level to
;      insure that the concatenation will not be later
;      mistaken for pattern matching
;
|opdvp|dac|6,o_cnc|||; concatenation - not pattern match| 5085
||dac|2,c_cnp|||;| 5086
||dac|2,llcnc|||;| 5087
||dac|2,rrcnc|||;| 5088
;
;      note that the order of the remaining entries is tied to
;      the order of the coding in the scane procedure.
;
|opdvs|dac|6,o_ass|||; assignment| 5093
||dac|2,c_ass|||;| 5094
||dac|2,llass|||;| 5095
||dac|2,rrass|||;| 5096
;
||dac|1,6|||; unary equal| 5098
||dac|2,c_uuo|||;| 5099
||dac|2,lluno|||;| 5100
;
||dac|6,o_pmv|||; pattern match| 5102
||dac|2,c_pmt|||;| 5103
||dac|2,llpmt|||;| 5104
||dac|2,rrpmt|||;| 5105
;
||dac|6,o_int|||; interrogation| 5107
||dac|2,c_uvl|||;| 5108
||dac|2,lluno|||;| 5109
;
||dac|1,1|||; binary ampersand| 5111
||dac|2,c_ubo|||;| 5112
||dac|2,llamp|||;| 5113
||dac|2,rramp|||;| 5114
;
||dac|6,o_kwv|||; keyword reference| 5116
||dac|2,c_key|||;| 5117
||dac|2,lluno|||;| 5118
;
||dac|6,o_alt|||; alternation| 5120
||dac|2,c_alt|||;| 5121
||dac|2,llalt|||;| 5122
||dac|2,rralt|||;| 5123
||ejc||||| 5124
;
;      operator dope vectors (continued)
;
||dac|1,5|||; unary vertical bar| 5128
||dac|2,c_uuo|||;| 5129
||dac|2,lluno|||;| 5130
;
||dac|1,0|||; binary at| 5132
||dac|2,c_ubo|||;| 5133
||dac|2,llats|||;| 5134
||dac|2,rrats|||;| 5135
;
||dac|6,o_cas|||; cursor assignment| 5137
||dac|2,c_unm|||;| 5138
||dac|2,lluno|||;| 5139
;
||dac|1,2|||; binary number sign| 5141
||dac|2,c_ubo|||;| 5142
||dac|2,llnum|||;| 5143
||dac|2,rrnum|||;| 5144
;
||dac|1,7|||; unary number sign| 5146
||dac|2,c_uuo|||;| 5147
||dac|2,lluno|||;| 5148
;
||dac|6,o_dvd|||; division| 5150
||dac|2,c_bvl|||;| 5151
||dac|2,lldvd|||;| 5152
||dac|2,rrdvd|||;| 5153
;
||dac|1,9|||; unary slash| 5155
||dac|2,c_uuo|||;| 5156
||dac|2,lluno|||;| 5157
;
||dac|6,o_mlt|||; multiplication| 5159
||dac|2,c_bvl|||;| 5160
||dac|2,llmlt|||;| 5161
||dac|2,rrmlt|||;| 5162
||ejc||||| 5163
;
;      operator dope vectors (continued)
;
||dac|1,0|||; deferred expression| 5167
||dac|2,c_def|||;| 5168
||dac|2,lluno|||;| 5169
;
||dac|1,3|||; binary percent| 5171
||dac|2,c_ubo|||;| 5172
||dac|2,llpct|||;| 5173
||dac|2,rrpct|||;| 5174
;
||dac|1,8|||; unary percent| 5176
||dac|2,c_uuo|||;| 5177
||dac|2,lluno|||;| 5178
;
||dac|6,o_exp|||; exponentiation| 5180
||dac|2,c_bvl|||;| 5181
||dac|2,llexp|||;| 5182
||dac|2,rrexp|||;| 5183
;
||dac|1,10|||; unary exclamation| 5185
||dac|2,c_uuo|||;| 5186
||dac|2,lluno|||;| 5187
;
||dac|6,o_ima|||; immediate assignment| 5189
||dac|2,c_bvn|||;| 5190
||dac|2,lldld|||;| 5191
||dac|2,rrdld|||;| 5192
;
||dac|6,o_inv|||; indirection| 5194
||dac|2,c_ind|||;| 5195
||dac|2,lluno|||;| 5196
;
||dac|1,4|||; binary not| 5198
||dac|2,c_ubo|||;| 5199
||dac|2,llnot|||;| 5200
||dac|2,rrnot|||;| 5201
;
||dac|1,0|||; negation| 5203
||dac|2,c_neg|||;| 5204
||dac|2,lluno|||;| 5205
||ejc||||| 5206
;
;      operator dope vectors (continued)
;
||dac|6,o_sub|||; subtraction| 5210
||dac|2,c_bvl|||;| 5211
||dac|2,llplm|||;| 5212
||dac|2,rrplm|||;| 5213
;
||dac|6,o_com|||; complementation| 5215
||dac|2,c_uvl|||;| 5216
||dac|2,lluno|||;| 5217
;
||dac|6,o_add|||; addition| 5219
||dac|2,c_bvl|||;| 5220
||dac|2,llplm|||;| 5221
||dac|2,rrplm|||;| 5222
;
||dac|6,o_aff|||; affirmation| 5224
||dac|2,c_uvl|||;| 5225
||dac|2,lluno|||;| 5226
;
||dac|6,o_pas|||; pattern assignment| 5228
||dac|2,c_bvn|||;| 5229
||dac|2,lldld|||;| 5230
||dac|2,rrdld|||;| 5231
;
||dac|6,o_nam|||; name reference| 5233
||dac|2,c_unm|||;| 5234
||dac|2,lluno|||;| 5235
;
;      special dvs for goto operators (see procedure scngf)
;
|opdvd|dac|6,o_god|||; direct goto| 5239
||dac|2,c_uvl|||;| 5240
||dac|2,lluno|||;| 5241
;
|opdvn|dac|6,o_goc|||; complex normal goto| 5243
||dac|2,c_unm|||;| 5244
||dac|2,lluno|||;| 5245
||ejc||||| 5246
;
;      operator entry address pointers, used in code
;
|oamn_|dac|6,o_amn|||; array ref (multi-subs by value)| 5250
|oamv_|dac|6,o_amv|||; array ref (multi-subs by value)| 5251
|oaon_|dac|6,o_aon|||; array ref (one sub by name)| 5252
|oaov_|dac|6,o_aov|||; array ref (one sub by value)| 5253
|ocer_|dac|6,o_cer|||; compilation error| 5254
|ofex_|dac|6,o_fex|||; failure in expression evaluation| 5255
|ofif_|dac|6,o_fif|||; failure during goto evaluation| 5256
|ofnc_|dac|6,o_fnc|||; function call (more than one arg)| 5257
|ofne_|dac|6,o_fne|||; function name error| 5258
|ofns_|dac|6,o_fns|||; function call (single argument)| 5259
|ogof_|dac|6,o_gof|||; set goto failure trap| 5260
|oinn_|dac|6,o_inn|||; indirection by name| 5261
|okwn_|dac|6,o_kwn|||; keyword reference by name| 5262
|olex_|dac|6,o_lex|||; load expression by name| 5263
|olpt_|dac|6,o_lpt|||; load pattern| 5264
|olvn_|dac|6,o_lvn|||; load variable name| 5265
|onta_|dac|6,o_nta|||; negation, first entry| 5266
|ontb_|dac|6,o_ntb|||; negation, second entry| 5267
|ontc_|dac|6,o_ntc|||; negation, third entry| 5268
|opmn_|dac|6,o_pmn|||; pattern match by name| 5269
|opms_|dac|6,o_pms|||; pattern match (statement)| 5270
|opop_|dac|6,o_pop|||; pop top stack item| 5271
|ornm_|dac|6,o_rnm|||; return name from expression| 5272
|orpl_|dac|6,o_rpl|||; pattern replacement| 5273
|orvl_|dac|6,o_rvl|||; return value from expression| 5274
|osla_|dac|6,o_sla|||; selection, first entry| 5275
|oslb_|dac|6,o_slb|||; selection, second entry| 5276
|oslc_|dac|6,o_slc|||; selection, third entry| 5277
|osld_|dac|6,o_sld|||; selection, fourth entry| 5278
|ostp_|dac|6,o_stp|||; stop execution| 5279
|ounf_|dac|6,o_unf|||; unexpected failure| 5280
||ejc||||| 5281
;
;      table of names of undefined binary operators for opsyn
;
|opsnb|dac|2,ch_at|||; at| 5285
||dac|2,ch_am|||; ampersand| 5286
||dac|2,ch_nm|||; number| 5287
||dac|2,ch_pc|||; percent| 5288
||dac|2,ch_nt|||; not| 5289
;
;      table of names of undefined unary operators for opsyn
;
|opnsu|dac|2,ch_br|||; vertical bar| 5293
||dac|2,ch_eq|||; equal| 5294
||dac|2,ch_nm|||; number| 5295
||dac|2,ch_pc|||; percent| 5296
||dac|2,ch_sl|||; slash| 5297
||dac|2,ch_ex|||; exclamation| 5298
;
;      address const containing profile table entry size
;
|pfi2a|dac|2,pf_i2|||;| 5304
;
;      profiler message strings
;
|pfms1|dac|6,b_scl|||| 5308
||dac|1,15|||| 5309
||dtc|27,/program profile/|||| 5310
|pfms2|dac|6,b_scl|||| 5311
||dac|1,42|||| 5312
||dtc|27,/stmt    number of     -- execution time --/|||| 5313
|pfms3|dac|6,b_scl|||| 5314
||dac|1,47|||| 5315
||dtc|27,/number  executions  total(msec) per excn(mcsec)/|||| 5316
;
;
;      real constants for general use. note that the constants
;      starting at reav1 form a powers of ten table (used in
;      gtnum and gtstg)
;
|reav0|drc|17,+0.0|||; 0.0| 5326
|reap1|drc|17,+0.1|||; 0.1| 5329
|reap5|drc|17,+0.5|||; 0.5| 5330
|reav1|drc|17,+1.0|||; 10**0| 5332
|reavt|drc|17,+1.0e+1|||; 10**1| 5333
||drc|17,+1.0e+2|||; 10**2| 5334
||drc|17,+1.0e+3|||; 10**3| 5335
||drc|17,+1.0e+4|||; 10**4| 5336
||drc|17,+1.0e+5|||; 10**5| 5337
||drc|17,+1.0e+6|||; 10**6| 5338
||drc|17,+1.0e+7|||; 10**7| 5339
||drc|17,+1.0e+8|||; 10**8| 5340
||drc|17,+1.0e+9|||; 10**9| 5341
|reatt|drc|17,+1.0e+10|||; 10**10| 5342
||ejc||||| 5344
;
;      string constants (scblk format) for dtype procedure
;
|scarr|dac|6,b_scl|||; array| 5348
||dac|1,5|||;| 5349
||dtc|27,/array/|||| 5350
;
|sccod|dac|6,b_scl|||; code| 5359
||dac|1,4|||;| 5360
||dtc|27,/code/|||| 5361
;
|scexp|dac|6,b_scl|||; expression| 5363
||dac|1,10|||;| 5364
||dtc|27,/expression/|||| 5365
;
|scext|dac|6,b_scl|||; external| 5367
||dac|1,8|||;| 5368
||dtc|27,/external/|||| 5369
;
|scint|dac|6,b_scl|||; integer| 5371
||dac|1,7|||;| 5372
||dtc|27,/integer/|||| 5373
;
|scnam|dac|6,b_scl|||; name| 5375
||dac|1,4|||;| 5376
||dtc|27,/name/|||| 5377
;
|scnum|dac|6,b_scl|||; numeric| 5379
||dac|1,7|||;| 5380
||dtc|27,/numeric/|||| 5381
;
|scpat|dac|6,b_scl|||; pattern| 5383
||dac|1,7|||;| 5384
||dtc|27,/pattern/|||| 5385
;
|screa|dac|6,b_scl|||; real| 5389
||dac|1,4|||;| 5390
||dtc|27,/real/|||| 5391
;
|scstr|dac|6,b_scl|||; string| 5394
||dac|1,6|||;| 5395
||dtc|27,/string/|||| 5396
;
|sctab|dac|6,b_scl|||; table| 5398
||dac|1,5|||;| 5399
||dtc|27,/table/|||| 5400
|scfil|dac|6,b_scl|||; file (for extended load arguments)| 5402
||dac|1,4|||;| 5403
||dtc|27,/file/|||| 5404
||ejc||||| 5406
;
;      string constants (scblk format) for kvrtn (see retrn)
;
|scfrt|dac|6,b_scl|||; freturn| 5410
||dac|1,7|||;| 5411
||dtc|27,/freturn/|||| 5412
;
|scnrt|dac|6,b_scl|||; nreturn| 5414
||dac|1,7|||;| 5415
||dtc|27,/nreturn/|||| 5416
;
|scrtn|dac|6,b_scl|||; return| 5418
||dac|1,6|||;| 5419
||dtc|27,/return/|||| 5420
;
;      datatype name table for dtype procedure. the order of
;      these entries is tied to the b_xxx definitions for blocks
;
;      note that slots for buffer and real data types are filled
;      even if these data types are conditionalized out of the
;      implementation.	this is done so that the block numbering
;      at bl_ar etc. remains constant in all versions.
;
|scnmt|dac|4,scarr|||; arblk	    array| 5430
||dac|4,sccod|||; cdblk	    code| 5431
||dac|4,scexp|||; exblk	    expression| 5432
||dac|4,scint|||; icblk	    integer| 5433
||dac|4,scnam|||; nmblk	    name| 5434
||dac|4,scpat|||; p0blk	    pattern| 5435
||dac|4,scpat|||; p1blk	    pattern| 5436
||dac|4,scpat|||; p2blk	    pattern| 5437
||dac|4,screa|||; rcblk	    real| 5442
||dac|4,scstr|||; scblk	    string| 5444
||dac|4,scexp|||; seblk	    expression| 5445
||dac|4,sctab|||; tbblk	    table| 5446
||dac|4,scarr|||; vcblk	    array| 5447
||dac|4,scext|||; xnblk	    external| 5448
||dac|4,scext|||; xrblk	    external| 5449
||dac|4,nulls|||; bfblk	    no buffer in this version| 5451
;
;      string constant for real zero
;
|scre0|dac|6,b_scl|||;| 5460
||dac|1,2|||;| 5461
||dtc|27,/0./|||| 5462
||ejc||||| 5464
;
;      used to re-initialise kvstl
;
|stlim|dic|16,+2147483647|||; default statement limit| 5472
;
;      dummy function block used for undefined functions
;
|stndf|dac|6,o_fun|||; ptr to undefined function err call| 5480
||dac|1,0|||; dummy fargs count for call circuit| 5481
;
;      dummy code block used for undefined labels
;
|stndl|dac|6,l_und|||; code ptr points to undefined lbl| 5485
;
;      dummy operator block used for undefined operators
;
|stndo|dac|6,o_oun|||; ptr to undefined operator err call| 5489
||dac|1,0|||; dummy fargs count for call circuit| 5490
;
;      standard variable block. this block is used to initialize
;      the first seven fields of a newly constructed vrblk.
;      its format is tied to the vrblk definitions (see gtnvr).
;
|stnvr|dac|6,b_vrl|||; vrget| 5496
||dac|6,b_vrs|||; vrsto| 5497
||dac|4,nulls|||; vrval| 5498
||dac|6,b_vrg|||; vrtra| 5499
||dac|4,stndl|||; vrlbl| 5500
||dac|4,stndf|||; vrfnc| 5501
||dac|1,0|||; vrnxt| 5502
||ejc||||| 5503
;
;      messages used in end of run processing (stopr)
;
|stpm1|dac|6,b_scl|||; in statement| 5507
||dac|1,12|||;| 5508
||dtc|27,/in statement/|||| 5509
;
|stpm2|dac|6,b_scl|||;| 5511
||dac|1,14|||;| 5512
||dtc|27,/stmts executed/|||| 5513
;
|stpm3|dac|6,b_scl|||;| 5515
||dac|1,19|||;| 5520
||dtc|27,/run time (millisec)/|||| 5521
;
|stpm4|dac|6,b_scl|||;| 5524
||dac|1,12|||;| 5525
||dtc|27,_mcsec / stmt_|||| 5526
;
|stpm5|dac|6,b_scl|||;| 5528
||dac|1,13|||;| 5529
||dtc|27,/regenerations/|||| 5530
;
|stpm6|dac|6,b_scl|||; in line| 5533
||dac|1,7|||;| 5534
||dtc|27,/in line/|||| 5535
;
|stpm7|dac|6,b_scl|||; in file| 5539
||dac|1,7|||;| 5540
||dtc|27,/in file/|||| 5541
;
;      chars for /tu/ ending code
;
|strtu|dtc|27,/tu/|||| 5546
;
;      table used by convert function to check datatype name
;      the entries are ordered to correspond to branch table
;      in s_cnv
;
|svctb|dac|4,scstr|||; string| 5552
||dac|4,scint|||; integer| 5553
||dac|4,scnam|||; name| 5554
||dac|4,scpat|||; pattern| 5555
||dac|4,scarr|||; array| 5556
||dac|4,sctab|||; table| 5557
||dac|4,scexp|||; expression| 5558
||dac|4,sccod|||; code| 5559
||dac|4,scnum|||; numeric| 5560
||dac|4,screa|||; real| 5563
||dac|1,0|||; zero marks end of list| 5569
||ejc||||| 5570
;
;      messages (scblk format) used by trace procedures
;
;
|tmasb|dac|6,b_scl|||; asterisks for trace statement no| 5575
||dac|1,13|||;| 5576
||dtc|27,/************ /|||| 5577
;
|tmbeb|dac|6,b_scl|||; blank-equal-blank| 5580
||dac|1,3|||;| 5581
||dtc|27,/ = /|||| 5582
;
;      dummy trblk for expression variable
;
|trbev|dac|6,b_trt|||; dummy trblk| 5586
;
;      dummy trblk for keyword variable
;
|trbkv|dac|6,b_trt|||; dummy trblk| 5590
;
;      dummy code block to return control to trxeq procedure
;
|trxdr|dac|6,o_txr|||; block points to return routine| 5594
|trxdc|dac|4,trxdr|||; pointer to block| 5595
||ejc||||| 5596
;
;      standard variable blocks
;
;      see svblk format for full details of the format. the
;      vrblks are ordered by length and within each length the
;      order is alphabetical by name of the variable.
;
|v_eqf|dbc|2,svfpr|||; eq| 5604
||dac|1,2|||;| 5605
||dtc|27,/eq/|||| 5606
||dac|6,s_eqf|||;| 5607
||dac|1,2|||;| 5608
;
|v_gef|dbc|2,svfpr|||; ge| 5610
||dac|1,2|||;| 5611
||dtc|27,/ge/|||| 5612
||dac|6,s_gef|||;| 5613
||dac|1,2|||;| 5614
;
|v_gtf|dbc|2,svfpr|||; gt| 5616
||dac|1,2|||;| 5617
||dtc|27,/gt/|||| 5618
||dac|6,s_gtf|||;| 5619
||dac|1,2|||;| 5620
;
|v_lef|dbc|2,svfpr|||; le| 5622
||dac|1,2|||;| 5623
||dtc|27,/le/|||| 5624
||dac|6,s_lef|||;| 5625
||dac|1,2|||;| 5626
;
|v_lnf|dbc|2,svfnp|||; ln| 5629
||dac|1,2|||;| 5630
||dtc|27,/ln/|||| 5631
||dac|6,s_lnf|||;| 5632
||dac|1,1|||;| 5633
;
|v_ltf|dbc|2,svfpr|||; lt| 5636
||dac|1,2|||;| 5637
||dtc|27,/lt/|||| 5638
||dac|6,s_ltf|||;| 5639
||dac|1,2|||;| 5640
;
|v_nef|dbc|2,svfpr|||; ne| 5642
||dac|1,2|||;| 5643
||dtc|27,/ne/|||| 5644
||dac|6,s_nef|||;| 5645
||dac|1,2|||;| 5646
;
|v_any|dbc|2,svfnp|||; any| 5672
||dac|1,3|||;| 5673
||dtc|27,/any/|||| 5674
||dac|6,s_any|||;| 5675
||dac|1,1|||;| 5676
;
|v_arb|dbc|2,svkvc|||; arb| 5678
||dac|1,3|||;| 5679
||dtc|27,/arb/|||| 5680
||dac|2,k_arb|||;| 5681
||dac|4,ndarb|||;| 5682
||ejc||||| 5683
;
;      standard variable blocks (continued)
;
|v_arg|dbc|2,svfnn|||; arg| 5687
||dac|1,3|||;| 5688
||dtc|27,/arg/|||| 5689
||dac|6,s_arg|||;| 5690
||dac|1,2|||;| 5691
;
|v_bal|dbc|2,svkvc|||; bal| 5693
||dac|1,3|||;| 5694
||dtc|27,/bal/|||| 5695
||dac|2,k_bal|||;| 5696
||dac|4,ndbal|||;| 5697
;
|v_cos|dbc|2,svfnp|||; cos| 5700
||dac|1,3|||;| 5701
||dtc|27,/cos/|||| 5702
||dac|6,s_cos|||;| 5703
||dac|1,1|||;| 5704
;
|v_end|dbc|2,svlbl|||; end| 5707
||dac|1,3|||;| 5708
||dtc|27,/end/|||| 5709
||dac|6,l_end|||;| 5710
;
|v_exp|dbc|2,svfnp|||; exp| 5713
||dac|1,3|||;| 5714
||dtc|27,/exp/|||| 5715
||dac|6,s_exp|||;| 5716
||dac|1,1|||;| 5717
;
|v_len|dbc|2,svfnp|||; len| 5720
||dac|1,3|||;| 5721
||dtc|27,/len/|||| 5722
||dac|6,s_len|||;| 5723
||dac|1,1|||;| 5724
;
|v_leq|dbc|2,svfpr|||; leq| 5726
||dac|1,3|||;| 5727
||dtc|27,/leq/|||| 5728
||dac|6,s_leq|||;| 5729
||dac|1,2|||;| 5730
;
|v_lge|dbc|2,svfpr|||; lge| 5732
||dac|1,3|||;| 5733
||dtc|27,/lge/|||| 5734
||dac|6,s_lge|||;| 5735
||dac|1,2|||;| 5736
;
|v_lgt|dbc|2,svfpr|||; lgt| 5738
||dac|1,3|||;| 5739
||dtc|27,/lgt/|||| 5740
||dac|6,s_lgt|||;| 5741
||dac|1,2|||;| 5742
;
|v_lle|dbc|2,svfpr|||; lle| 5744
||dac|1,3|||;| 5745
||dtc|27,/lle/|||| 5746
||dac|6,s_lle|||;| 5747
||dac|1,2|||;| 5748
||ejc||||| 5749
;
;      standard variable blocks (continued)
;
|v_llt|dbc|2,svfpr|||; llt| 5753
||dac|1,3|||;| 5754
||dtc|27,/llt/|||| 5755
||dac|6,s_llt|||;| 5756
||dac|1,2|||;| 5757
;
|v_lne|dbc|2,svfpr|||; lne| 5759
||dac|1,3|||;| 5760
||dtc|27,/lne/|||| 5761
||dac|6,s_lne|||;| 5762
||dac|1,2|||;| 5763
;
|v_pos|dbc|2,svfnp|||; pos| 5765
||dac|1,3|||;| 5766
||dtc|27,/pos/|||| 5767
||dac|6,s_pos|||;| 5768
||dac|1,1|||;| 5769
;
|v_rem|dbc|2,svkvc|||; rem| 5771
||dac|1,3|||;| 5772
||dtc|27,/rem/|||| 5773
||dac|2,k_rem|||;| 5774
||dac|4,ndrem|||;| 5775
;
|v_set|dbc|2,svfnn|||; set| 5778
||dac|1,3|||;| 5779
||dtc|27,/set/|||| 5780
||dac|6,s_set|||;| 5781
||dac|1,3|||;| 5782
;
|v_sin|dbc|2,svfnp|||; sin| 5786
||dac|1,3|||;| 5787
||dtc|27,/sin/|||| 5788
||dac|6,s_sin|||;| 5789
||dac|1,1|||;| 5790
;
|v_tab|dbc|2,svfnp|||; tab| 5793
||dac|1,3|||;| 5794
||dtc|27,/tab/|||| 5795
||dac|6,s_tab|||;| 5796
||dac|1,1|||;| 5797
;
|v_tan|dbc|2,svfnp|||; tan| 5800
||dac|1,3|||;| 5801
||dtc|27,/tan/|||| 5802
||dac|6,s_tan|||;| 5803
||dac|1,1|||;| 5804
;
|v_atn|dbc|2,svfnp|||; atan| 5816
||dac|1,4|||;| 5817
||dtc|27,/atan/|||| 5818
||dac|6,s_atn|||;| 5819
||dac|1,1|||;| 5820
;
|v_cas|dbc|2,svknm|||; case| 5824
||dac|1,4|||;| 5825
||dtc|27,/case/|||| 5826
||dac|2,k_cas|||;| 5827
;
|v_chr|dbc|2,svfnp|||; char| 5830
||dac|1,4|||;| 5831
||dtc|27,/char/|||| 5832
||dac|6,s_chr|||;| 5833
||dac|1,1|||;| 5834
;
;
|v_chp|dbc|2,svfnp|||; chop| 5838
||dac|1,4|||;| 5839
||dtc|27,/chop/|||| 5840
||dac|6,s_chp|||;| 5841
||dac|1,1|||;| 5842
|v_cod|dbc|2,svfnk|||; code| 5844
||dac|1,4|||;| 5845
||dtc|27,/code/|||| 5846
||dac|2,k_cod|||;| 5847
||dac|6,s_cod|||;| 5848
||dac|1,1|||;| 5849
;
|v_cop|dbc|2,svfnn|||; copy| 5851
||dac|1,4|||;| 5852
||dtc|27,/copy/|||| 5853
||dac|6,s_cop|||;| 5854
||dac|1,1|||;| 5855
||ejc||||| 5856
;
;      standard variable blocks (continued)
;
|v_dat|dbc|2,svfnn|||; data| 5860
||dac|1,4|||;| 5861
||dtc|27,/data/|||| 5862
||dac|6,s_dat|||;| 5863
||dac|1,1|||;| 5864
;
|v_dte|dbc|2,svfnn|||; date| 5866
||dac|1,4|||;| 5867
||dtc|27,/date/|||| 5868
||dac|6,s_dte|||;| 5869
||dac|1,1|||;| 5870
;
|v_dmp|dbc|2,svfnk|||; dump| 5872
||dac|1,4|||;| 5873
||dtc|27,/dump/|||| 5874
||dac|2,k_dmp|||;| 5875
||dac|6,s_dmp|||;| 5876
||dac|1,1|||;| 5877
;
|v_dup|dbc|2,svfnn|||; dupl| 5879
||dac|1,4|||;| 5880
||dtc|27,/dupl/|||| 5881
||dac|6,s_dup|||;| 5882
||dac|1,2|||;| 5883
;
|v_evl|dbc|2,svfnn|||; eval| 5885
||dac|1,4|||;| 5886
||dtc|27,/eval/|||| 5887
||dac|6,s_evl|||;| 5888
||dac|1,1|||;| 5889
;
|v_ext|dbc|2,svfnn|||; exit| 5893
||dac|1,4|||;| 5894
||dtc|27,/exit/|||| 5895
||dac|6,s_ext|||;| 5896
||dac|1,2|||;| 5897
;
|v_fal|dbc|2,svkvc|||; fail| 5900
||dac|1,4|||;| 5901
||dtc|27,/fail/|||| 5902
||dac|2,k_fal|||;| 5903
||dac|4,ndfal|||;| 5904
;
|v_fil|dbc|2,svknm|||; file| 5907
||dac|1,4|||;| 5908
||dtc|27,/file/|||| 5909
||dac|2,k_fil|||;| 5910
;
|v_hst|dbc|2,svfnn|||; host| 5913
||dac|1,4|||;| 5914
||dtc|27,/host/|||| 5915
||dac|6,s_hst|||;| 5916
||dac|1,5|||;| 5917
||ejc||||| 5918
;
;      standard variable blocks (continued)
;
|v_itm|dbc|2,svfnf|||; item| 5922
||dac|1,4|||;| 5923
||dtc|27,/item/|||| 5924
||dac|6,s_itm|||;| 5925
||dac|1,999|||;| 5926
;
|v_lin|dbc|2,svknm|||; line| 5929
||dac|1,4|||;| 5930
||dtc|27,/line/|||| 5931
||dac|2,k_lin|||;| 5932
;
|v_lod|dbc|2,svfnn|||; load| 5937
||dac|1,4|||;| 5938
||dtc|27,/load/|||| 5939
||dac|6,s_lod|||;| 5940
||dac|1,2|||;| 5941
;
|v_lpd|dbc|2,svfnp|||; lpad| 5944
||dac|1,4|||;| 5945
||dtc|27,/lpad/|||| 5946
||dac|6,s_lpd|||;| 5947
||dac|1,3|||;| 5948
;
|v_rpd|dbc|2,svfnp|||; rpad| 5950
||dac|1,4|||;| 5951
||dtc|27,/rpad/|||| 5952
||dac|6,s_rpd|||;| 5953
||dac|1,3|||;| 5954
;
|v_rps|dbc|2,svfnp|||; rpos| 5956
||dac|1,4|||;| 5957
||dtc|27,/rpos/|||| 5958
||dac|6,s_rps|||;| 5959
||dac|1,1|||;| 5960
;
|v_rtb|dbc|2,svfnp|||; rtab| 5962
||dac|1,4|||;| 5963
||dtc|27,/rtab/|||| 5964
||dac|6,s_rtb|||;| 5965
||dac|1,1|||;| 5966
;
|v_si_|dbc|2,svfnp|||; size| 5968
||dac|1,4|||;| 5969
||dtc|27,/size/|||| 5970
||dac|6,s_si_|||;| 5971
||dac|1,1|||;| 5972
;
;
|v_srt|dbc|2,svfnn|||; sort| 5977
||dac|1,4|||;| 5978
||dtc|27,/sort/|||| 5979
||dac|6,s_srt|||;| 5980
||dac|1,2|||;| 5981
|v_spn|dbc|2,svfnp|||; span| 5983
||dac|1,4|||;| 5984
||dtc|27,/span/|||| 5985
||dac|6,s_spn|||;| 5986
||dac|1,1|||;| 5987
||ejc||||| 5988
;
;      standard variable blocks (continued)
;
;
|v_sqr|dbc|2,svfnp|||; sqrt| 5994
||dac|1,4|||;| 5995
||dtc|27,/sqrt/|||| 5996
||dac|6,s_sqr|||;| 5997
||dac|1,1|||;| 5998
|v_stn|dbc|2,svknm|||; stno| 6000
||dac|1,4|||;| 6001
||dtc|27,/stno/|||| 6002
||dac|2,k_stn|||;| 6003
;
|v_tim|dbc|2,svfnn|||; time| 6005
||dac|1,4|||;| 6006
||dtc|27,/time/|||| 6007
||dac|6,s_tim|||;| 6008
||dac|1,0|||;| 6009
;
|v_trm|dbc|2,svfnk|||; trim| 6011
||dac|1,4|||;| 6012
||dtc|27,/trim/|||| 6013
||dac|2,k_trm|||;| 6014
||dac|6,s_trm|||;| 6015
||dac|1,1|||;| 6016
;
|v_abe|dbc|2,svknm|||; abend| 6018
||dac|1,5|||;| 6019
||dtc|27,/abend/|||| 6020
||dac|2,k_abe|||;| 6021
;
|v_abo|dbc|2,svkvl|||; abort| 6023
||dac|1,5|||;| 6024
||dtc|27,/abort/|||| 6025
||dac|2,k_abo|||;| 6026
||dac|6,l_abo|||;| 6027
||dac|4,ndabo|||;| 6028
;
|v_app|dbc|2,svfnf|||; apply| 6030
||dac|1,5|||;| 6031
||dtc|27,/apply/|||| 6032
||dac|6,s_app|||;| 6033
||dac|1,999|||;| 6034
;
|v_abn|dbc|2,svfnp|||; arbno| 6036
||dac|1,5|||;| 6037
||dtc|27,/arbno/|||| 6038
||dac|6,s_abn|||;| 6039
||dac|1,1|||;| 6040
;
|v_arr|dbc|2,svfnn|||; array| 6042
||dac|1,5|||;| 6043
||dtc|27,/array/|||| 6044
||dac|6,s_arr|||;| 6045
||dac|1,2|||;| 6046
||ejc||||| 6047
;
;      standard variable blocks (continued)
;
|v_brk|dbc|2,svfnp|||; break| 6051
||dac|1,5|||;| 6052
||dtc|27,/break/|||| 6053
||dac|6,s_brk|||;| 6054
||dac|1,1|||;| 6055
;
|v_clr|dbc|2,svfnn|||; clear| 6057
||dac|1,5|||;| 6058
||dtc|27,/clear/|||| 6059
||dac|6,s_clr|||;| 6060
||dac|1,1|||;| 6061
;
|v_ejc|dbc|2,svfnn|||; eject| 6071
||dac|1,5|||;| 6072
||dtc|27,/eject/|||| 6073
||dac|6,s_ejc|||;| 6074
||dac|1,1|||;| 6075
;
|v_fen|dbc|2,svfpk|||; fence| 6077
||dac|1,5|||;| 6078
||dtc|27,/fence/|||| 6079
||dac|2,k_fen|||;| 6080
||dac|6,s_fnc|||;| 6081
||dac|1,1|||;| 6082
||dac|4,ndfen|||;| 6083
;
|v_fld|dbc|2,svfnn|||; field| 6085
||dac|1,5|||;| 6086
||dtc|27,/field/|||| 6087
||dac|6,s_fld|||;| 6088
||dac|1,2|||;| 6089
;
|v_idn|dbc|2,svfpr|||; ident| 6091
||dac|1,5|||;| 6092
||dtc|27,/ident/|||| 6093
||dac|6,s_idn|||;| 6094
||dac|1,2|||;| 6095
;
|v_inp|dbc|2,svfnk|||; input| 6097
||dac|1,5|||;| 6098
||dtc|27,/input/|||| 6099
||dac|2,k_inp|||;| 6100
||dac|6,s_inp|||;| 6101
||dac|1,3|||;| 6102
;
|v_lcs|dbc|2,svkwc|||; lcase| 6105
||dac|1,5|||;| 6106
||dtc|27,/lcase/|||| 6107
||dac|2,k_lcs|||;| 6108
;
|v_loc|dbc|2,svfnn|||; local| 6111
||dac|1,5|||;| 6112
||dtc|27,/local/|||| 6113
||dac|6,s_loc|||;| 6114
||dac|1,2|||;| 6115
||ejc||||| 6116
;
;      standard variable blocks (continued)
;
|v_ops|dbc|2,svfnn|||; opsyn| 6120
||dac|1,5|||;| 6121
||dtc|27,/opsyn/|||| 6122
||dac|6,s_ops|||;| 6123
||dac|1,3|||;| 6124
;
|v_rmd|dbc|2,svfnp|||; remdr| 6126
||dac|1,5|||;| 6127
||dtc|27,/remdr/|||| 6128
||dac|6,s_rmd|||;| 6129
||dac|1,2|||;| 6130
;
|v_rsr|dbc|2,svfnn|||; rsort| 6134
||dac|1,5|||;| 6135
||dtc|27,/rsort/|||| 6136
||dac|6,s_rsr|||;| 6137
||dac|1,2|||;| 6138
;
|v_tbl|dbc|2,svfnn|||; table| 6141
||dac|1,5|||;| 6142
||dtc|27,/table/|||| 6143
||dac|6,s_tbl|||;| 6144
||dac|1,3|||;| 6145
;
|v_tra|dbc|2,svfnk|||; trace| 6147
||dac|1,5|||;| 6148
||dtc|27,/trace/|||| 6149
||dac|2,k_tra|||;| 6150
||dac|6,s_tra|||;| 6151
||dac|1,4|||;| 6152
;
|v_ucs|dbc|2,svkwc|||; ucase| 6155
||dac|1,5|||;| 6156
||dtc|27,/ucase/|||| 6157
||dac|2,k_ucs|||;| 6158
;
|v_anc|dbc|2,svknm|||; anchor| 6161
||dac|1,6|||;| 6162
||dtc|27,/anchor/|||| 6163
||dac|2,k_anc|||;| 6164
;
|v_bkx|dbc|2,svfnp|||; breakx| 6175
||dac|1,6|||;| 6176
||dtc|27,/breakx/|||| 6177
||dac|6,s_bkx|||;| 6178
||dac|1,1|||;| 6179
;
;
|v_def|dbc|2,svfnn|||; define| 6190
||dac|1,6|||;| 6191
||dtc|27,/define/|||| 6192
||dac|6,s_def|||;| 6193
||dac|1,2|||;| 6194
;
|v_det|dbc|2,svfnn|||; detach| 6196
||dac|1,6|||;| 6197
||dtc|27,/detach/|||| 6198
||dac|6,s_det|||;| 6199
||dac|1,1|||;| 6200
||ejc||||| 6201
;
;      standard variable blocks (continued)
;
|v_dif|dbc|2,svfpr|||; differ| 6205
||dac|1,6|||;| 6206
||dtc|27,/differ/|||| 6207
||dac|6,s_dif|||;| 6208
||dac|1,2|||;| 6209
;
|v_ftr|dbc|2,svknm|||; ftrace| 6211
||dac|1,6|||;| 6212
||dtc|27,/ftrace/|||| 6213
||dac|2,k_ftr|||;| 6214
;
|v_lst|dbc|2,svknm|||; lastno| 6225
||dac|1,6|||;| 6226
||dtc|27,/lastno/|||| 6227
||dac|2,k_lst|||;| 6228
;
|v_nay|dbc|2,svfnp|||; notany| 6230
||dac|1,6|||;| 6231
||dtc|27,/notany/|||| 6232
||dac|6,s_nay|||;| 6233
||dac|1,1|||;| 6234
;
|v_oup|dbc|2,svfnk|||; output| 6236
||dac|1,6|||;| 6237
||dtc|27,/output/|||| 6238
||dac|2,k_oup|||;| 6239
||dac|6,s_oup|||;| 6240
||dac|1,3|||;| 6241
;
|v_ret|dbc|2,svlbl|||; return| 6243
||dac|1,6|||;| 6244
||dtc|27,/return/|||| 6245
||dac|6,l_rtn|||;| 6246
;
|v_rew|dbc|2,svfnn|||; rewind| 6248
||dac|1,6|||;| 6249
||dtc|27,/rewind/|||| 6250
||dac|6,s_rew|||;| 6251
||dac|1,1|||;| 6252
;
|v_stt|dbc|2,svfnn|||; stoptr| 6254
||dac|1,6|||;| 6255
||dtc|27,/stoptr/|||| 6256
||dac|6,s_stt|||;| 6257
||dac|1,2|||;| 6258
||ejc||||| 6259
;
;      standard variable blocks (continued)
;
|v_sub|dbc|2,svfnn|||; substr| 6263
||dac|1,6|||;| 6264
||dtc|27,/substr/|||| 6265
||dac|6,s_sub|||;| 6266
||dac|1,3|||;| 6267
;
|v_unl|dbc|2,svfnn|||; unload| 6269
||dac|1,6|||;| 6270
||dtc|27,/unload/|||| 6271
||dac|6,s_unl|||;| 6272
||dac|1,1|||;| 6273
;
|v_col|dbc|2,svfnn|||; collect| 6275
||dac|1,7|||;| 6276
||dtc|27,/collect/|||| 6277
||dac|6,s_col|||;| 6278
||dac|1,1|||;| 6279
;
|v_com|dbc|2,svknm|||; compare| 6282
||dac|1,7|||;| 6283
||dtc|27,/compare/|||| 6284
||dac|2,k_com|||;| 6285
;
|v_cnv|dbc|2,svfnn|||; convert| 6288
||dac|1,7|||;| 6289
||dtc|27,/convert/|||| 6290
||dac|6,s_cnv|||;| 6291
||dac|1,2|||;| 6292
;
|v_enf|dbc|2,svfnn|||; endfile| 6294
||dac|1,7|||;| 6295
||dtc|27,/endfile/|||| 6296
||dac|6,s_enf|||;| 6297
||dac|1,1|||;| 6298
;
|v_etx|dbc|2,svknm|||; errtext| 6300
||dac|1,7|||;| 6301
||dtc|27,/errtext/|||| 6302
||dac|2,k_etx|||;| 6303
;
|v_ert|dbc|2,svknm|||; errtype| 6305
||dac|1,7|||;| 6306
||dtc|27,/errtype/|||| 6307
||dac|2,k_ert|||;| 6308
;
|v_frt|dbc|2,svlbl|||; freturn| 6310
||dac|1,7|||;| 6311
||dtc|27,/freturn/|||| 6312
||dac|6,l_frt|||;| 6313
;
|v_int|dbc|2,svfpr|||; integer| 6315
||dac|1,7|||;| 6316
||dtc|27,/integer/|||| 6317
||dac|6,s_int|||;| 6318
||dac|1,1|||;| 6319
;
|v_nrt|dbc|2,svlbl|||; nreturn| 6321
||dac|1,7|||;| 6322
||dtc|27,/nreturn/|||| 6323
||dac|6,l_nrt|||;| 6324
||ejc||||| 6325
;
;      standard variable blocks (continued)
;
;
|v_pfl|dbc|2,svknm|||; profile| 6332
||dac|1,7|||;| 6333
||dtc|27,/profile/|||| 6334
||dac|2,k_pfl|||;| 6335
;
|v_rpl|dbc|2,svfnp|||; replace| 6338
||dac|1,7|||;| 6339
||dtc|27,/replace/|||| 6340
||dac|6,s_rpl|||;| 6341
||dac|1,3|||;| 6342
;
|v_rvs|dbc|2,svfnp|||; reverse| 6344
||dac|1,7|||;| 6345
||dtc|27,/reverse/|||| 6346
||dac|6,s_rvs|||;| 6347
||dac|1,1|||;| 6348
;
|v_rtn|dbc|2,svknm|||; rtntype| 6350
||dac|1,7|||;| 6351
||dtc|27,/rtntype/|||| 6352
||dac|2,k_rtn|||;| 6353
;
|v_stx|dbc|2,svfnn|||; setexit| 6355
||dac|1,7|||;| 6356
||dtc|27,/setexit/|||| 6357
||dac|6,s_stx|||;| 6358
||dac|1,1|||;| 6359
;
|v_stc|dbc|2,svknm|||; stcount| 6361
||dac|1,7|||;| 6362
||dtc|27,/stcount/|||| 6363
||dac|2,k_stc|||;| 6364
;
|v_stl|dbc|2,svknm|||; stlimit| 6366
||dac|1,7|||;| 6367
||dtc|27,/stlimit/|||| 6368
||dac|2,k_stl|||;| 6369
;
|v_suc|dbc|2,svkvc|||; succeed| 6371
||dac|1,7|||;| 6372
||dtc|27,/succeed/|||| 6373
||dac|2,k_suc|||;| 6374
||dac|4,ndsuc|||;| 6375
;
|v_alp|dbc|2,svkwc|||; alphabet| 6377
||dac|1,8|||;| 6378
||dtc|27,/alphabet/|||| 6379
||dac|2,k_alp|||;| 6380
;
|v_cnt|dbc|2,svlbl|||; continue| 6382
||dac|1,8|||;| 6383
||dtc|27,/continue/|||| 6384
||dac|6,l_cnt|||;| 6385
||ejc||||| 6386
;
;      standard variable blocks (continued)
;
|v_dtp|dbc|2,svfnp|||; datatype| 6390
||dac|1,8|||;| 6391
||dtc|27,/datatype/|||| 6392
||dac|6,s_dtp|||;| 6393
||dac|1,1|||;| 6394
;
|v_erl|dbc|2,svknm|||; errlimit| 6396
||dac|1,8|||;| 6397
||dtc|27,/errlimit/|||| 6398
||dac|2,k_erl|||;| 6399
;
|v_fnc|dbc|2,svknm|||; fnclevel| 6401
||dac|1,8|||;| 6402
||dtc|27,/fnclevel/|||| 6403
||dac|2,k_fnc|||;| 6404
;
|v_fls|dbc|2,svknm|||; fullscan| 6406
||dac|1,8|||;| 6407
||dtc|27,/fullscan/|||| 6408
||dac|2,k_fls|||;| 6409
;
|v_lfl|dbc|2,svknm|||; lastfile| 6412
||dac|1,8|||;| 6413
||dtc|27,/lastfile/|||| 6414
||dac|2,k_lfl|||;| 6415
;
|v_lln|dbc|2,svknm|||; lastline| 6419
||dac|1,8|||;| 6420
||dtc|27,/lastline/|||| 6421
||dac|2,k_lln|||;| 6422
;
|v_mxl|dbc|2,svknm|||; maxlngth| 6425
||dac|1,8|||;| 6426
||dtc|27,/maxlngth/|||| 6427
||dac|2,k_mxl|||;| 6428
;
|v_ter|dbc|1,0|||; terminal| 6430
||dac|1,8|||;| 6431
||dtc|27,/terminal/|||| 6432
||dac|1,0|||;| 6433
;
|v_bsp|dbc|2,svfnn|||; backspace| 6436
||dac|1,9|||;| 6437
||dtc|27,/backspace/|||| 6438
||dac|6,s_bsp|||;| 6439
||dac|1,1|||;| 6440
;
|v_pro|dbc|2,svfnn|||; prototype| 6443
||dac|1,9|||;| 6444
||dtc|27,/prototype/|||| 6445
||dac|6,s_pro|||;| 6446
||dac|1,1|||;| 6447
;
|v_scn|dbc|2,svlbl|||; scontinue| 6449
||dac|1,9|||;| 6450
||dtc|27,/scontinue/|||| 6451
||dac|6,l_scn|||;| 6452
;
||dbc|1,0|||; dummy entry to end list| 6454
||dac|1,10|||; length gt 9 (scontinue)| 6455
||ejc||||| 6456
;
;      list of svblk pointers for keywords to be dumped. the
;      list is in the order which appears on the dump output.
;
|vdmkw|dac|4,v_anc|||; anchor| 6461
||dac|4,v_cas|||; ccase| 6463
||dac|4,v_cod|||; code| 6465
||dac|1,1|||; compare not printed| 6470
||dac|4,v_dmp|||; dump| 6473
||dac|4,v_erl|||; errlimit| 6474
||dac|4,v_etx|||; errtext| 6475
||dac|4,v_ert|||; errtype| 6476
||dac|4,v_fil|||; file| 6478
||dac|4,v_fnc|||; fnclevel| 6480
||dac|4,v_ftr|||; ftrace| 6481
||dac|4,v_fls|||; fullscan| 6482
||dac|4,v_inp|||; input| 6483
||dac|4,v_lfl|||; lastfile| 6485
||dac|4,v_lln|||; lastline| 6488
||dac|4,v_lst|||; lastno| 6490
||dac|4,v_lin|||; line| 6492
||dac|4,v_mxl|||; maxlength| 6494
||dac|4,v_oup|||; output| 6495
||dac|4,v_pfl|||; profile| 6498
||dac|4,v_rtn|||; rtntype| 6500
||dac|4,v_stc|||; stcount| 6501
||dac|4,v_stl|||; stlimit| 6502
||dac|4,v_stn|||; stno| 6503
||dac|4,v_tra|||; trace| 6504
||dac|4,v_trm|||; trim| 6505
||dac|1,0|||; end of list| 6506
;
;      table used by gtnvr to search svblk lists
;
|vsrch|dac|1,0|||; dummy entry to get proper indexing| 6510
||dac|4,v_eqf|||; start of 1 char variables (none)| 6511
||dac|4,v_eqf|||; start of 2 char variables| 6512
||dac|4,v_any|||; start of 3 char variables| 6513
||dac|4,v_atn|||; start of 4 char variables| 6515
||dac|4,v_abe|||; start of 5 char variables| 6523
||dac|4,v_anc|||; start of 6 char variables| 6524
||dac|4,v_col|||; start of 7 char variables| 6525
||dac|4,v_alp|||; start of 8 char variables| 6526
||dac|4,v_bsp|||; start of 9 char variables| 6528
;
;      last location in constant section
;
|c_yyy|dac|1,0|||; last location in constant section| 6535
||ttl|27,s p i t b o l -- working storage section|||| 6536
;
;      the working storage section contains areas which are
;      changed during execution of the program. the value
;      assembled is the initial value before execution starts.
;
;      all these areas are fixed length areas. variable length
;      data is stored in the static or dynamic regions of the
;      allocated data areas.
;
;      the values in this area are described either as work
;      areas or as global values. a work area is used in an
;      ephemeral manner and the value is not saved from one
;      entry into a routine to another. a global value is a
;      less temporary location whose value is saved from one
;      call to another.
;
;      w_aaa marks the start of the working section whilst
;      w_yyy marks its end.  g_aaa marks the division between
;      temporary and global values.
;
;      global values are further subdivided to facilitate
;      processing by the garbage collector. r_aaa through
;      r_yyy are global values that may point into dynamic
;      storage and hence must be relocated after each garbage
;      collection.  they also serve as root pointers to all
;      allocated data that must be preserved.  pointers between
;      a_aaa and r_aaa may point into code, static storage,
;      or mark the limits of dynamic memory.  these pointers
;      must be adjusted when the working section is saved to a
;      file and subsequently reloaded at a different address.
;
;      a general part of the approach in this program is not
;      to overlap work areas between procedures even though a
;      small amount of space could be saved. such overlap is
;      considered a source of program errors and decreases the
;      information left behind after a system crash of any kind.
;
;      the names of these locations are labels with five letter
;      (a-y,_) names. as far as possible the order is kept
;      alphabetical by these names but in some cases there
;      are slight departures caused by other order requirements.
;
;      unless otherwise documented, the order of work areas
;      does not affect the execution of the spitbol program.
;
||sec||||; start of working storage section| 6582
||ejc||||| 6583
;
;      this area is not cleared by initial code
;
|cmlab|dac|6,b_scl|||; string used to check label legality| 6587
||dac|1,2|||;| 6588
||dtc|27,/  /|||| 6589
;
;      label to mark start of work area
;
|w_aaa|dac|1,0|||;| 6593
;
;      work areas for acess procedure
;
|actrm|dac|1,0|||; trim indicator| 6597
;
;      work areas for alloc procedure
;
|aldyn|dac|1,0|||; amount of dynamic store| 6601
|allia|dic|16,+0|||; dump ia| 6602
|allsv|dac|1,0|||; save wb in alloc| 6603
;
;      work areas for alost procedure
;
|alsta|dac|1,0|||; save wa in alost| 6607
;
;      work areas for array function (s_arr)
;
|arcdm|dac|1,0|||; count dimensions| 6611
|arnel|dic|16,+0|||; count elements| 6612
|arptr|dac|1,0|||; offset ptr into arblk| 6613
|arsvl|dic|16,+0|||; save integer low bound| 6614
||ejc||||| 6615
;
;      work areas for arref routine
;
|arfsi|dic|16,+0|||; save current evolving subscript| 6619
|arfxs|dac|1,0|||; save base stack pointer| 6620
;
;      work areas for b_efc block routine
;
|befof|dac|1,0|||; save offset ptr into efblk| 6624
;
;      work areas for b_pfc block routine
;
|bpfpf|dac|1,0|||; save pfblk pointer| 6628
|bpfsv|dac|1,0|||; save old function value| 6629
|bpfxt|dac|1,0|||; pointer to stacked arguments| 6630
;
;      work area for collect function (s_col)
;
|clsvi|dic|16,+0|||; save integer argument| 6634
;
;      work areas value for cncrd
;
|cnscc|dac|1,0|||; pointer to control card string| 6638
|cnswc|dac|1,0|||; word count| 6639
|cnr_t|dac|1,0|||; pointer to r_ttl or r_stl| 6640
;
;      work areas for convert function (s_cnv)
;
|cnvtp|dac|1,0|||; save ptr into scvtb| 6644
;
;      work areas for data function (s_dat)
;
|datdv|dac|1,0|||; save vrblk ptr for datatype name| 6648
|datxs|dac|1,0|||; save initial stack pointer| 6649
;
;      work areas for define function (s_def)
;
|deflb|dac|1,0|||; save vrblk ptr for label| 6653
|defna|dac|1,0|||; count function arguments| 6654
|defvr|dac|1,0|||; save vrblk ptr for function name| 6655
|defxs|dac|1,0|||; save initial stack pointer| 6656
;
;      work areas for dumpr procedure
;
|dmarg|dac|1,0|||; dump argument| 6660
|dmpsa|dac|1,0|||; preserve wa over prtvl call| 6661
|dmpsb|dac|1,0|||; preserve wb over syscm call| 6663
|dmpsv|dac|1,0|||; general scratch save| 6665
|dmvch|dac|1,0|||; chain pointer for variable blocks| 6666
|dmpch|dac|1,0|||; save sorted vrblk chain pointer| 6667
|dmpkb|dac|1,0|||; dummy kvblk for use in dumpr| 6668
|dmpkt|dac|1,0|||; kvvar trblk ptr (must follow dmpkb)| 6669
|dmpkn|dac|1,0|||; keyword number (must follow dmpkt)| 6670
;
;      work area for dtach
;
|dtcnb|dac|1,0|||; name base| 6674
|dtcnm|dac|1,0|||; name ptr| 6675
;
;      work areas for dupl function (s_dup)
;
|dupsi|dic|16,+0|||; store integer string length| 6679
;
;      work area for endfile (s_enf)
;
|enfch|dac|1,0|||; for iochn chain head| 6683
||ejc||||| 6684
;
;      work areas for ertex
;
|ertwa|dac|1,0|||; save wa| 6688
|ertwb|dac|1,0|||; save wb| 6689
;
;      work areas for evali
;
|evlin|dac|1,0|||; dummy pattern block pcode| 6693
|evlis|dac|1,0|||; then node (must follow evlin)| 6694
|evliv|dac|1,0|||; value of parm1 (must follow evlis)| 6695
|evlio|dac|1,0|||; ptr to original node| 6696
|evlif|dac|1,0|||; flag for simple/complex argument| 6697
;
;      work area for expan
;
|expsv|dac|1,0|||; save op dope vector pointer| 6701
;
;      work areas for gbcol procedure
;
|gbcfl|dac|1,0|||; garbage collector active flag| 6705
|gbclm|dac|1,0|||; pointer to last move block (pass 3)| 6706
|gbcnm|dac|1,0|||; dummy first move block| 6707
|gbcns|dac|1,0|||; rest of dummy block (follows gbcnm)| 6708
|gbcia|dic|16,+0|||; dump ia| 6714
|gbcsd|dac|1,0|||; first address beyond sediment| 6715
|gbcsf|dac|1,0|||; free space within sediment| 6716
|gbsva|dac|1,0|||; save wa| 6718
|gbsvb|dac|1,0|||; save wb| 6719
|gbsvc|dac|1,0|||; save wc| 6720
;
;      work areas for gtnvr procedure
;
|gnvhe|dac|1,0|||; ptr to end of hash chain| 6724
|gnvnw|dac|1,0|||; number of words in string name| 6725
|gnvsa|dac|1,0|||; save wa| 6726
|gnvsb|dac|1,0|||; save wb| 6727
|gnvsp|dac|1,0|||; pointer into vsrch table| 6728
|gnvst|dac|1,0|||; pointer to chars of string| 6729
;
;      work areas for gtarr
;
|gtawa|dac|1,0|||; save wa| 6733
;
;      work areas for gtint
;
|gtina|dac|1,0|||; save wa| 6737
|gtinb|dac|1,0|||; save wb| 6738
||ejc||||| 6739
;
;      work areas for gtnum procedure
;
|gtnnf|dac|1,0|||; zero/nonzero for result +/-| 6743
|gtnsi|dic|16,+0|||; general integer save| 6744
|gtndf|dac|1,0|||; 0/1 for dec point so far no/yes| 6747
|gtnes|dac|1,0|||; zero/nonzero exponent +/-| 6748
|gtnex|dic|16,+0|||; real exponent| 6749
|gtnsc|dac|1,0|||; scale (places after point)| 6750
|gtnsr|drc|17,+0.0|||; general real save| 6751
|gtnrd|dac|1,0|||; flag for ok real number| 6752
;
;      work areas for gtpat procedure
;
|gtpsb|dac|1,0|||; save wb| 6757
;
;      work areas for gtstg procedure
;
|gtssf|dac|1,0|||; 0/1 for result +/-| 6761
|gtsvc|dac|1,0|||; save wc| 6762
|gtsvb|dac|1,0|||; save wb| 6763
|gtses|dac|1,0|||; char + or - for exponent +/-| 6768
|gtsrs|drc|17,+0.0|||; general real save| 6769
;
;      work areas for gtvar procedure
;
|gtvrc|dac|1,0|||; save wc| 6775
;
;      work areas for ioput
;
|ioptt|dac|1,0|||; type of association| 6790
;
;      work areas for load function
;
|lodfn|dac|1,0|||; pointer to vrblk for func name| 6796
|lodna|dac|1,0|||; count number of arguments| 6797
;
;      mxint is value of maximum positive integer. it is computed at runtime to allow
;      the compilation of spitbol on a machine with smaller word size the the target.
;
|mxint|dac|1,0|||;| 6803
;
;      work area for profiler
;
|pfsvw|dac|1,0|||; to save a w-reg| 6809
;
;      work areas for prtnm procedure
;
|prnsi|dic|16,+0|||; scratch integer loc| 6814
;
;      work areas for prtsn procedure
;
|prsna|dac|1,0|||; save wa| 6818
;
;      work areas for prtst procedure
;
|prsva|dac|1,0|||; save wa| 6822
|prsvb|dac|1,0|||; save wb| 6823
|prsvc|dac|1,0|||; save char counter| 6824
;
;      work area for prtnl
;
|prtsa|dac|1,0|||; save wa| 6828
|prtsb|dac|1,0|||; save wb| 6829
;
;      work area for prtvl
;
|prvsi|dac|1,0|||; save idval| 6833
;
;      work areas for pattern match routines
;
|psave|dac|1,0|||; temporary save for current node ptr| 6837
|psavc|dac|1,0|||; save cursor in p_spn, p_str| 6838
;
;      work area for relaj routine
;
|rlals|dac|1,0|||; ptr to list of bounds and adjusts| 6843
;
;      work area for reldn routine
;
|rldcd|dac|1,0|||; save code adjustment| 6847
|rldst|dac|1,0|||; save static adjustment| 6848
|rldls|dac|1,0|||; save list pointer| 6849
;
;      work areas for retrn routine
;
|rtnbp|dac|1,0|||; to save a block pointer| 6854
|rtnfv|dac|1,0|||; new function value (result)| 6855
|rtnsv|dac|1,0|||; old function value (saved value)| 6856
;
;      work areas for substr function (s_sub)
;
|sbssv|dac|1,0|||; save third argument| 6860
;
;      work areas for scan procedure
;
|scnsa|dac|1,0|||; save wa| 6864
|scnsb|dac|1,0|||; save wb| 6865
|scnsc|dac|1,0|||; save wc| 6866
|scnof|dac|1,0|||; save offset| 6867
||ejc||||| 6870
;
;      work area used by sorta, sortc, sortf, sorth
;
|srtdf|dac|1,0|||; datatype field name| 6874
|srtfd|dac|1,0|||; found dfblk address| 6875
|srtff|dac|1,0|||; found field name| 6876
|srtfo|dac|1,0|||; offset to field name| 6877
|srtnr|dac|1,0|||; number of rows| 6878
|srtof|dac|1,0|||; offset within row to sort key| 6879
|srtrt|dac|1,0|||; root offset| 6880
|srts1|dac|1,0|||; save offset 1| 6881
|srts2|dac|1,0|||; save offset 2| 6882
|srtsc|dac|1,0|||; save wc| 6883
|srtsf|dac|1,0|||; sort array first row offset| 6884
|srtsn|dac|1,0|||; save n| 6885
|srtso|dac|1,0|||; offset to a(0)| 6886
|srtsr|dac|1,0|||; 0, non-zero for sort, rsort| 6887
|srtst|dac|1,0|||; stride from one row to next| 6888
|srtwc|dac|1,0|||; dump wc| 6889
;
;      work areas for stopr routine
;
|stpsi|dic|16,+0|||; save value of stcount| 6894
|stpti|dic|16,+0|||; save time elapsed| 6895
;
;      work areas for tfind procedure
;
|tfnsi|dic|16,+0|||; number of headers| 6899
;
;      work areas for xscan procedure
;
|xscrt|dac|1,0|||; save return code| 6903
|xscwb|dac|1,0|||; save register wb| 6904
;
;      start of global values in working section
;
|g_aaa|dac|1,0|||;| 6908
;
;      global value for alloc procedure
;
|alfsf|dic|16,+0|||; factor in free store pcntage check| 6912
;
;      global values for cmpil procedure
;
|cmerc|dac|1,0|||; count of initial compile errors| 6916
|cmpln|dac|1,0|||; line number of first line of stmt| 6917
|cmpxs|dac|1,0|||; save stack ptr in case of errors| 6918
|cmpsn|dac|1,1|||; number of next statement to compile| 6919
;
;      global values for cncrd
;
|cnsil|dac|1,0|||; save scnil during include process.| 6924
|cnind|dac|1,0|||; current include file nest level| 6925
|cnspt|dac|1,0|||; save scnpt during include process.| 6926
|cnttl|dac|1,0|||; flag for -title, -stitl| 6928
;
;      global flag for suppression of compilation statistics.
;
|cpsts|dac|1,0|||; suppress comp. stats if non zero| 6932
;
;      global values for control card switches
;
|cswdb|dac|1,0|||; 0/1 for -single/-double| 6936
|cswer|dac|1,0|||; 0/1 for -errors/-noerrors| 6937
|cswex|dac|1,0|||; 0/1 for -execute/-noexecute| 6938
|cswfl|dac|1,1|||; 0/1 for -nofail/-fail| 6939
|cswin|dac|2,iniln|||; xxx for -inxxx| 6940
|cswls|dac|1,1|||; 0/1 for -nolist/-list| 6941
|cswno|dac|1,0|||; 0/1 for -optimise/-noopt| 6942
|cswpr|dac|1,0|||; 0/1 for -noprint/-print| 6943
;
;      global location used by patst procedure
;
|ctmsk|dbc|1,0|||; last bit position used in r_ctp| 6947
|curid|dac|1,0|||; current id value| 6948
||ejc||||| 6949
;
;      global value for cdwrd procedure
;
|cwcof|dac|1,0|||; next word offset in current ccblk| 6953
;
;      global locations for dynamic storage pointers
;
|dnams|dac|1,0|||; size of sediment in baus| 6958
;
;      global area for error processing.
;
|erich|dac|1,0|||; copy error reports to int.chan if 1| 6963
|erlst|dac|1,0|||; for listr when errors go to int.ch.| 6964
|errft|dac|1,0|||; fatal error flag| 6965
|errsp|dac|1,0|||; error suppression flag| 6966
;
;      global flag for suppression of execution stats
;
|exsts|dac|1,0|||; suppress exec stats if set| 6970
;
;      global values for exfal and return
;
|flprt|dac|1,0|||; location of fail offset for return| 6974
|flptr|dac|1,0|||; location of failure offset on stack| 6975
;
;      global location to count garbage collections (gbcol)
;
|gbsed|dic|16,+0|||; factor in sediment pcntage check| 6980
|gbcnt|dac|1,0|||; count of garbage collections| 6982
;
;      global value for gtcod and gtexp
;
|gtcef|dac|1,0|||; save fail ptr in case of error| 6986
;
;      global locations for gtstg procedure
;
|gtsrn|drc|17,+0.0|||; rounding factor 0.5*10**-cfp_s| 6994
|gtssc|drc|17,+0.0|||; scaling value 10**cfp_s| 6995
|gtswk|dac|1,0|||; ptr to work area for gtstg| 6998
;
;      global flag for header printing
;
|headp|dac|1,0|||; header printed flag| 7002
;
;      global values for variable hash table
;
|hshnb|dic|16,+0|||; number of hash buckets| 7006
;
;      global areas for init
;
|initr|dac|1,0|||; save terminal flag| 7010
||ejc||||| 7011
;
;      global values for keyword values which are stored as one
;      word integers. these values must be assembled in the
;      following order (as dictated by k_xxx definition values).
;
|kvabe|dac|1,0|||; abend| 7017
|kvanc|dac|1,0|||; anchor| 7018
|kvcas|dac|1,0|||; case| 7020
|kvcod|dac|1,0|||; code| 7022
|kvcom|dac|1,0|||; compare| 7024
|kvdmp|dac|1,0|||; dump| 7026
|kverl|dac|1,0|||; errlimit| 7027
|kvert|dac|1,0|||; errtype| 7028
|kvftr|dac|1,0|||; ftrace| 7029
|kvfls|dac|1,1|||; fullscan| 7030
|kvinp|dac|1,1|||; input| 7031
|kvmxl|dac|1,5000|||; maxlength| 7032
|kvoup|dac|1,1|||; output| 7033
|kvpfl|dac|1,0|||; profile| 7036
|kvtra|dac|1,0|||; trace| 7038
|kvtrm|dac|1,0|||; trim| 7039
|kvfnc|dac|1,0|||; fnclevel| 7040
|kvlst|dac|1,0|||; lastno| 7041
|kvlln|dac|1,0|||; lastline| 7043
|kvlin|dac|1,0|||; line| 7044
|kvstn|dac|1,0|||; stno| 7046
;
;      global values for other keywords
;
|kvalp|dac|1,0|||; alphabet| 7050
|kvrtn|dac|4,nulls|||; rtntype (scblk pointer)| 7051
|kvstl|dic|16,+2147483647|||; stlimit| 7057
|kvstc|dic|16,+2147483647|||; stcount (counts down from stlimit)| 7058
;
;      global values for listr procedure
;
|lstid|dac|1,0|||; include depth of current image| 7068
|lstlc|dac|1,0|||; count lines on source list page| 7070
|lstnp|dac|1,0|||; max number of lines on page| 7071
|lstpf|dac|1,1|||; set nonzero if current image listed| 7072
|lstpg|dac|1,0|||; current source list page number| 7073
|lstpo|dac|1,0|||; offset to   page nnn	 message| 7074
|lstsn|dac|1,0|||; remember last stmnum listed| 7075
;
;      global maximum size of spitbol objects
;
|mxlen|dac|1,0|||; initialised by sysmx call| 7079
;
;      global execution control variable
;
|noxeq|dac|1,0|||; set non-zero to inhibit execution| 7083
;
;      global profiler values locations
;
|pfdmp|dac|1,0|||; set non-0 if &profile set non-0| 7089
|pffnc|dac|1,0|||; set non-0 if funct just entered| 7090
|pfstm|dic|16,+0|||; to store starting time of stmt| 7091
|pfetm|dic|16,+0|||; to store ending time of stmt| 7092
|pfnte|dac|1,0|||; nr of table entries| 7093
|pfste|dic|16,+0|||; gets int rep of table entry size| 7094
;
||ejc||||| 7097
;
;      global values used in pattern match routines
;
|pmdfl|dac|1,0|||; pattern assignment flag| 7101
|pmhbs|dac|1,0|||; history stack base pointer| 7102
|pmssl|dac|1,0|||; length of subject string in chars| 7103
;
;      global values for interface polling (syspl)
;
|polcs|dac|1,1|||; poll interval start value| 7108
|polct|dac|1,1|||; poll interval counter| 7109
;
;      global flags used for standard file listing options
;
|prich|dac|1,0|||; printer on interactive channel| 7114
|prstd|dac|1,0|||; tested by prtpg| 7115
|prsto|dac|1,0|||; standard listing option flag| 7116
;
;      global values for print procedures
;
|prbuf|dac|1,0|||; ptr to print bfr in static| 7120
|precl|dac|1,0|||; extended/compact listing flag| 7121
|prlen|dac|1,0|||; length of print buffer in chars| 7122
|prlnw|dac|1,0|||; length of print buffer in words| 7123
|profs|dac|1,0|||; offset to next location in prbuf| 7124
|prtef|dac|1,0|||; endfile flag| 7125
||ejc||||| 7126
;
;      global area for readr
;
|rdcln|dac|1,0|||; current statement line number| 7130
|rdnln|dac|1,0|||; next statement line number| 7131
;
;      global amount of memory reserved for end of execution
;
|rsmem|dac|1,0|||; reserve memory| 7135
;
;      global area for stmgo counters
;
|stmcs|dac|1,1|||; counter startup value| 7139
|stmct|dac|1,1|||; counter active value| 7140
;
;      adjustable global values
;
;      all the pointers in this section can point to the
;      dynamic or the static region.
;      when a save file is reloaded, these pointers must
;      be adjusted if static or dynamic memory is now
;      at a different address.	see routine reloc for
;      additional information.
;
;      some values cannot be move here because of adjacency
;      constraints.  they are handled specially by reloc et al.
;      these values are kvrtn,
;
;      values gtswk, kvalp, and prbuf are reinitialized by
;      procedure insta, and do not need to appear here.
;
;      values flprt, flptr, gtcef, and stbas point into the
;      stack and are explicitly adjusted by osint's restart
;      procedure.
;
|a_aaa|dac|1,0|||; start of adjustable values| 7162
|cmpss|dac|1,0|||; save subroutine stack ptr| 7163
|dnamb|dac|1,0|||; start of dynamic area| 7164
|dnamp|dac|1,0|||; next available loc in dynamic area| 7165
|dname|dac|1,0|||; end of available dynamic area| 7166
|hshtb|dac|1,0|||; pointer to start of vrblk hash tabl| 7167
|hshte|dac|1,0|||; pointer past end of vrblk hash tabl| 7168
|iniss|dac|1,0|||; save subroutine stack ptr| 7169
|pftbl|dac|1,0|||; gets adrs of (imag) table base| 7170
|prnmv|dac|1,0|||; vrblk ptr from last name search| 7171
|statb|dac|1,0|||; start of static area| 7172
|state|dac|1,0|||; end of static area| 7173
|stxvr|dac|4,nulls|||; vrblk pointer or null| 7174
;
;      relocatable global values
;
;      all the pointers in this section can point to blocks in
;      the dynamic storage area and must be relocated by the
;      garbage collector. they are identified by r_xxx names.
;
|r_aaa|dac|1,0|||; start of relocatable values| 7183
|r_arf|dac|1,0|||; array block pointer for arref| 7184
|r_ccb|dac|1,0|||; ptr to ccblk being built (cdwrd)| 7185
|r_cim|dac|1,0|||; ptr to current compiler input str| 7186
|r_cmp|dac|1,0|||; copy of r_cim used in cmpil| 7187
|r_cni|dac|1,0|||; ptr to next compiler input string| 7188
|r_cnt|dac|1,0|||; cdblk pointer for setexit continue| 7189
|r_cod|dac|1,0|||; pointer to current cdblk or exblk| 7190
|r_ctp|dac|1,0|||; ptr to current ctblk for patst| 7191
|r_cts|dac|1,0|||; ptr to last string scanned by patst| 7192
|r_ert|dac|1,0|||; trblk pointer for errtype trace| 7193
|r_etx|dac|4,nulls|||; pointer to errtext string| 7194
|r_exs|dac|1,0|||; = save xl in expdm| 7195
|r_fcb|dac|1,0|||; fcblk chain head| 7196
|r_fnc|dac|1,0|||; trblk pointer for fnclevel trace| 7197
|r_gtc|dac|1,0|||; keep code ptr for gtcod,gtexp| 7198
|r_ici|dac|1,0|||; saved r_cim during include process.| 7200
|r_ifa|dac|1,0|||; array of file names by incl. depth| 7202
|r_ifl|dac|1,0|||; array of line nums by include depth| 7203
|r_ifn|dac|1,0|||; last include file name| 7205
|r_inc|dac|1,0|||; table of include file names seen| 7206
|r_io1|dac|1,0|||; file arg1 for ioput| 7208
|r_io2|dac|1,0|||; file arg2 for ioput| 7209
|r_iof|dac|1,0|||; fcblk ptr or 0| 7210
|r_ion|dac|1,0|||; name base ptr| 7211
|r_iop|dac|1,0|||; predecessor block ptr for ioput| 7212
|r_iot|dac|1,0|||; trblk ptr for ioput| 7213
|r_pms|dac|1,0|||; subject string ptr in pattern match| 7218
|r_ra2|dac|1,0|||; replace second argument last time| 7219
|r_ra3|dac|1,0|||; replace third argument last time| 7220
|r_rpt|dac|1,0|||; ptr to ctblk replace table last usd| 7221
|r_scp|dac|1,0|||; save pointer from last scane call| 7222
|r_sfc|dac|4,nulls|||; current source file name| 7224
|r_sfn|dac|1,0|||; ptr to source file name table| 7225
|r_sxl|dac|1,0|||; preserve xl in sortc| 7227
|r_sxr|dac|1,0|||; preserve xr in sorta/sortc| 7228
|r_stc|dac|1,0|||; trblk pointer for stcount trace| 7229
|r_stl|dac|1,0|||; source listing sub-title| 7230
|r_sxc|dac|1,0|||; code (cdblk) ptr for setexit trap| 7231
|r_ttl|dac|4,nulls|||; source listing title| 7232
|r_xsc|dac|1,0|||; string pointer for xscan| 7233
||ejc||||| 7234
;
;      the remaining pointers in this list are used to point
;      to function blocks for normally undefined operators.
;
|r_uba|dac|4,stndo|||; binary at| 7239
|r_ubm|dac|4,stndo|||; binary ampersand| 7240
|r_ubn|dac|4,stndo|||; binary number sign| 7241
|r_ubp|dac|4,stndo|||; binary percent| 7242
|r_ubt|dac|4,stndo|||; binary not| 7243
|r_uub|dac|4,stndo|||; unary vertical bar| 7244
|r_uue|dac|4,stndo|||; unary equal| 7245
|r_uun|dac|4,stndo|||; unary number sign| 7246
|r_uup|dac|4,stndo|||; unary percent| 7247
|r_uus|dac|4,stndo|||; unary slash| 7248
|r_uux|dac|4,stndo|||; unary exclamation| 7249
|r_yyy|dac|1,0|||; last relocatable location| 7250
;
;      global locations used in scan procedure
;
|scnbl|dac|1,0|||; set non-zero if scanned past blanks| 7254
|scncc|dac|1,0|||; non-zero to scan control card name| 7255
|scngo|dac|1,0|||; set non-zero to scan goto field| 7256
|scnil|dac|1,0|||; length of current input image| 7257
|scnpt|dac|1,0|||; pointer to next location in r_cim| 7258
|scnrs|dac|1,0|||; set non-zero to signal rescan| 7259
|scnse|dac|1,0|||; start of current element| 7260
|scntp|dac|1,0|||; save syntax type from last call| 7261
;
;      global value for indicating stage (see error section)
;
|stage|dac|1,0|||; initial value = initial compile| 7265
||ejc||||| 7266
;
;      global stack pointer
;
|stbas|dac|1,0|||; pointer past stack base| 7270
;
;      global values for setexit function (s_stx)
;
|stxoc|dac|1,0|||; code pointer offset| 7274
|stxof|dac|1,0|||; failure offset| 7275
;
;      global value for time keeping
;
|timsx|dic|16,+0|||; time at start of execution| 7279
|timup|dac|1,0|||; set when time up occurs| 7280
;
;      global values for xscan and xscni procedures
;
|xsofs|dac|1,0|||; offset to current location in r_xsc| 7284
;
;      label to mark end of working section
;
|w_yyy|dac|1,0|||;| 7288
||ttl|27,s p i t b o l -- minimal code|||| 7289
||sec||||; start of program section| 7290
|s_aaa|ent|2,bl__i|||; mark start of code| 7291
||ttl|27,s p i t b o l -- relocation|||| 7293
;
;      relocation
;      the following section provides services to osint to
;      relocate portions of the workspace.  it is used when
;      a saved memory image must be restarted at a different
;      location.
;
;      relaj -- relocate a list of pointers
;
;      (wa)		     ptr past last pointer of list
;      (wb)		     ptr to first pointer of list
;      (xl)		     list of boundaries and adjustments
;      jsr  relaj	     call to process list of pointers
;      (wb)		     destroyed
;
|relaj|prc|25,e|1,0||; entry point| 7309
||mov|11,-(xs)|7,xr||; save xr| 7310
||mov|11,-(xs)|8,wa||; save wa| 7311
||mov|3,rlals|7,xl||; save ptr to list of bounds| 7312
||mov|7,xr|8,wb||; ptr to first pointer to process| 7313
;
;      merge here to check if done
;
|rlaj0|mov|7,xl|3,rlals||; restore xl| 7317
||bne|7,xr|9,(xs)|6,rlaj1|; proceed if more to do| 7318
||mov|8,wa|10,(xs)+||; restore wa| 7319
||mov|7,xr|10,(xs)+||; restore xr| 7320
||exi||||; return to caller| 7321
;
;      merge here to process next pointer on list
;
|rlaj1|mov|8,wa|9,(xr)||; load next pointer on list| 7325
||lct|8,wb|18,=rnsi_||; number of sections of adjusters| 7326
;
;      merge here to process next section of stack list
;
|rlaj2|bgt|8,wa|13,rlend(xl)|6,rlaj3|; ok if past end of section| 7330
||blt|8,wa|13,rlstr(xl)|6,rlaj3|; or if before start of section| 7331
||add|8,wa|13,rladj(xl)||; within section, add adjustment| 7332
||mov|9,(xr)|8,wa||; return updated ptr to memory| 7333
||brn|6,rlaj4|||; done with this pointer| 7334
;
;      here if not within section
;
|rlaj3|add|7,xl|19,*rssi_||; advance to next section| 7338
||bct|8,wb|6,rlaj2||; jump if more to go| 7339
;
;      here when finished processing one pointer
;
|rlaj4|ica|7,xr|||; increment to next ptr on list| 7343
||brn|6,rlaj0|||; jump to check	 for completion| 7344
||enp||||; end procedure relaj| 7345
||ejc||||| 7346
;
;      relcr -- create relocation info after save file reload
;
;      (wa)		     original s_aaa code section adr
;      (wb)		     original c_aaa constant section adr
;      (wc)		     original g_aaa working section adr
;      (xr)		     ptr to start of static region
;      (cp)		     ptr to start of dynamic region
;      (xl)		     ptr to area to receive information
;      jsr  relcr	     create relocation information
;      (wa,wb,wc,xr)	     destroyed
;
;      a block of information is built at (xl) that is used
;      in relocating pointers.	there are rnsi_ instances
;      of a rssi_ word structure.  each instance corresponds
;      to one of the regions that a pointer might point into.
;      the layout of this structure is shown in the definitions
;      section, together with symbolic definitions of the
;      entries as offsets from xl.
;
|relcr|prc|25,e|1,0||; entry point| 7367
||add|7,xl|19,*rlsi_||; point past build area| 7368
||mov|11,-(xl)|8,wa||; save original code address| 7369
||mov|8,wa|22,=s_aaa||; compute adjustment| 7370
||sub|8,wa|9,(xl)||; as new s_aaa minus original s_aaa| 7371
||mov|11,-(xl)|8,wa||; save code adjustment| 7372
||mov|8,wa|22,=s_yyy||; end of target code section| 7373
||sub|8,wa|22,=s_aaa||; length of code section| 7374
||add|8,wa|13,num01(xl)||; plus original start address| 7375
||mov|11,-(xl)|8,wa||; end of original code section| 7376
||mov|11,-(xl)|8,wb||; save constant section address| 7377
||mov|8,wb|21,=c_aaa||; start of constants section| 7378
||mov|8,wa|21,=c_yyy||; end of constants section| 7379
||sub|8,wa|8,wb||; length of constants section| 7380
||sub|8,wb|9,(xl)||; new c_aaa minus original c_aaa| 7381
||mov|11,-(xl)|8,wb||; save constant adjustment| 7382
||add|8,wa|13,num01(xl)||; length plus original start adr| 7383
||mov|11,-(xl)|8,wa||; save as end of original constants| 7384
||mov|11,-(xl)|8,wc||; save working globals address| 7385
||mov|8,wc|20,=g_aaa||; start of working globals section| 7386
||mov|8,wa|20,=w_yyy||; end of working section| 7387
||sub|8,wa|8,wc||; length of working globals| 7388
||sub|8,wc|9,(xl)||; new g_aaa minus original g_aaa| 7389
||mov|11,-(xl)|8,wc||; save working globals adjustment| 7390
||add|8,wa|13,num01(xl)||; length plus original start adr| 7391
||mov|11,-(xl)|8,wa||; save as end of working globals| 7392
||mov|8,wb|3,statb||; old start of static region| 7393
||mov|11,-(xl)|8,wb||; save| 7394
||sub|7,xr|8,wb||; compute adjustment| 7395
||mov|11,-(xl)|7,xr||; save new statb minus old statb| 7396
||mov|11,-(xl)|3,state||; old end of static region| 7397
||mov|8,wb|3,dnamb||; old start of dynamic region| 7398
||mov|11,-(xl)|8,wb||; save| 7399
||scp|8,wa|||; new start of dynamic| 7400
||sub|8,wa|8,wb||; compute adjustment| 7401
||mov|11,-(xl)|8,wa||; save new dnamb minus old dnamb| 7402
||mov|8,wc|3,dnamp||; old end of dynamic region in use| 7403
||mov|11,-(xl)|8,wc||; save as end of old dynamic region| 7404
||exi||||| 7405
||enp||||| 7406
||ejc||||| 7407
;
;      reldn -- relocate pointers in the dynamic region
;
;      (xl)		     list of boundaries and adjustments
;      (xr)		     ptr to first location to process
;      (wc)		     ptr past last location to process
;      jsr  reldn	     call to process blocks in dynamic
;      (wa,wb,wc,xr)	     destroyed
;
;      processes all blocks in the dynamic region.  within a
;      block, pointers to the code section, constant section,
;      working globals section, static region, and dynamic
;      region are relocated as needed.
;
|reldn|prc|25,e|1,0||; entry point| 7422
||mov|3,rldcd|13,rlcda(xl)||; save code adjustment| 7423
||mov|3,rldst|13,rlsta(xl)||; save static adjustment| 7424
||mov|3,rldls|7,xl||; save list pointer| 7425
;
;      merge here to process the next block in dynamic
;
|rld01|add|9,(xr)|3,rldcd||; adjust block type word| 7429
||mov|7,xl|9,(xr)||; load block type word| 7430
||lei|7,xl|||; load entry point id (bl_xx)| 7431
;
;      block type switch. note that blocks with no relocatable
;      fields just return to rld05 to continue to next block.
;
;      note that dfblks do not appear in dynamic, only in static.
;      ccblks and cmblks are not live when a save file is
;      created, and can be skipped.
;
;      further note:  static blocks other than vrblks discovered
;      while scanning dynamic must be adjusted at this time.
;      see processing of ffblk for example.
;
||ejc||||| 7444
;
;      reldn (continued)
;
||bsw|7,xl|2,bl___||; switch on block type| 7448
||iff|2,bl_ar|6,rld03||; arblk| 7485
||iff|2,bl_cd|6,rld07||; cdblk| 7485
||iff|2,bl_ex|6,rld10||; exblk| 7485
||iff|2,bl_ic|6,rld05||; icblk| 7485
||iff|2,bl_nm|6,rld13||; nmblk| 7485
||iff|2,bl_p0|6,rld13||; p0blk| 7485
||iff|2,bl_p1|6,rld14||; p1blk| 7485
||iff|2,bl_p2|6,rld14||; p2blk| 7485
||iff|2,bl_rc|6,rld05||; rcblk| 7485
||iff|2,bl_sc|6,rld05||; scblk| 7485
||iff|2,bl_se|6,rld13||; seblk| 7485
||iff|2,bl_tb|6,rld17||; tbblk| 7485
||iff|2,bl_vc|6,rld17||; vcblk| 7485
||iff|2,bl_xn|6,rld05||; xnblk| 7485
||iff|2,bl_xr|6,rld20||; xrblk| 7485
||iff|2,bl_bc|6,rld05||; bcblk - dummy to fill out iffs| 7485
||iff|2,bl_pd|6,rld15||; pdblk| 7485
||iff|2,bl_tr|6,rld19||; trblk| 7485
||iff|2,bl_bf|6,rld05||; bfblk| 7485
||iff|2,bl_cc|6,rld05||; ccblk| 7485
||iff|2,bl_cm|6,rld05||; cmblk| 7485
||iff|2,bl_ct|6,rld05||; ctblk| 7485
||iff|2,bl_df|6,rld05||; dfblk| 7485
||iff|2,bl_ef|6,rld08||; efblk| 7485
||iff|2,bl_ev|6,rld09||; evblk| 7485
||iff|2,bl_ff|6,rld11||; ffblk| 7485
||iff|2,bl_kv|6,rld13||; kvblk| 7485
||iff|2,bl_pf|6,rld16||; pfblk| 7485
||iff|2,bl_te|6,rld18||; teblk| 7485
||esw||||; end of jump table| 7485
;
;      arblk
;
|rld03|mov|8,wa|13,arlen(xr)||; load length| 7489
||mov|8,wb|13,arofs(xr)||; set offset to 1st reloc fld (arpro)| 7490
;
;      merge here to process pointers in a block
;
;      (xr)		     ptr to current block
;      (wc)		     ptr past last location to process
;      (wa)		     length (reloc flds + flds at start)
;      (wb)		     offset to first reloc field
;
|rld04|add|8,wa|7,xr||; point past last reloc field| 7499
||add|8,wb|7,xr||; point to first reloc field| 7500
||mov|7,xl|3,rldls||; point to list of bounds| 7501
||jsr|6,relaj|||; adjust pointers| 7502
||ejc||||| 7503
;
;      reldn (continued)
;
;
;      merge here to advance to next block
;
;      (xr)		     ptr to current block
;      (wc)		     ptr past last location to process
;
|rld05|mov|8,wa|9,(xr)||; block type word| 7513
||jsr|6,blkln|||; get length of block| 7514
||add|7,xr|8,wa||; point to next block| 7515
||blt|7,xr|8,wc|6,rld01|; continue if more to process| 7516
||mov|7,xl|3,rldls||; restore xl| 7517
||exi||||; return to caller if done| 7518
;
;      cdblk
;
|rld07|mov|8,wa|13,cdlen(xr)||; load length| 7531
||mov|8,wb|19,*cdfal||; set offset| 7532
||bne|9,(xr)|22,=b_cdc|6,rld04|; jump back if not complex goto| 7533
||mov|8,wb|19,*cdcod||; do not process cdfal word| 7534
||brn|6,rld04|||; jump back| 7535
;
;      efblk
;
;      if the efcod word points to an xnblk, the xnblk type
;      word will not be adjusted.  since this is implementation
;      dependent, we will not worry about it.
;
|rld08|mov|8,wa|19,*efrsl||; set length| 7543
||mov|8,wb|19,*efcod||; and offset| 7544
||brn|6,rld04|||; all set| 7545
;
;      evblk
;
|rld09|mov|8,wa|19,*offs3||; point past third field| 7549
||mov|8,wb|19,*evexp||; set offset| 7550
||brn|6,rld04|||; all set| 7551
;
;      exblk
;
|rld10|mov|8,wa|13,exlen(xr)||; load length| 7555
||mov|8,wb|19,*exflc||; set offset| 7556
||brn|6,rld04|||; jump back| 7557
||ejc||||| 7558
;
;      reldn (continued)
;
;
;      ffblk
;
;      this block contains a ptr to a dfblk in the static rgn.
;      because there are multiple ffblks pointing to the same
;      dfblk (one for each field name), we only process the
;      dfblk when we encounter the ffblk for the first field.
;      the dfblk in turn contains a pointer to an scblk within
;      static.
;
|rld11|bne|13,ffofs(xr)|19,*pdfld|6,rld12|; skip dfblk if not first field| 7572
||mov|11,-(xs)|7,xr||; save xr| 7573
||mov|7,xr|13,ffdfp(xr)||; load old ptr to dfblk| 7574
||add|7,xr|3,rldst||; current location of dfblk| 7575
||add|9,(xr)|3,rldcd||; adjust dfblk type word| 7576
||mov|8,wa|13,dflen(xr)||; length of dfblk| 7577
||mov|8,wb|19,*dfnam||; offset to dfnam field| 7578
||add|8,wa|7,xr||; point past last reloc field| 7579
||add|8,wb|7,xr||; point to first reloc field| 7580
||mov|7,xl|3,rldls||; point to list of bounds| 7581
||jsr|6,relaj|||; adjust pointers| 7582
||mov|7,xr|13,dfnam(xr)||; pointer to static scblk| 7583
||add|9,(xr)|3,rldcd||; adjust scblk type word| 7584
||mov|7,xr|10,(xs)+||; restore ffblk pointer| 7585
;
;      ffblk (continued)
;
;      merge here to set up for adjustment of ptrs in ffblk
;
|rld12|mov|8,wa|19,*ffofs||; set length| 7591
||mov|8,wb|19,*ffdfp||; set offset| 7592
||brn|6,rld04|||; all set| 7593
;
;      kvblk, nmblk, p0blk, seblk
;
|rld13|mov|8,wa|19,*offs2||; point past second field| 7597
||mov|8,wb|19,*offs1||; offset is one (only reloc fld is 2)| 7598
||brn|6,rld04|||; all set| 7599
;
;      p1blk, p2blk
;
;      in p2blks, parm2 contains either a bit mask or the
;      name offset of a variable.  it never requires relocation.
;
|rld14|mov|8,wa|19,*parm2||; length (parm2 is non-relocatable)| 7606
||mov|8,wb|19,*pthen||; set offset| 7607
||brn|6,rld04|||; all set| 7608
;
;      pdblk
;
;      note that the dfblk pointed to by this pdblk was
;      processed when the ffblk was encountered.  because
;      the data function will be called before any records are
;      defined, the ffblk is encountered before any
;      corresponding pdblk.
;
|rld15|mov|7,xl|13,pddfp(xr)||; load ptr to dfblk| 7618
||add|7,xl|3,rldst||; adjust for static relocation| 7619
||mov|8,wa|13,dfpdl(xl)||; get pdblk length| 7620
||mov|8,wb|19,*pddfp||; set offset| 7621
||brn|6,rld04|||; all set| 7622
||ejc||||| 7623
;
;      reldn (continued)
;
;
;      pfblk
;
|rld16|add|13,pfvbl(xr)|3,rldst||; adjust non-contiguous field| 7630
||mov|8,wa|13,pflen(xr)||; get pfblk length| 7631
||mov|8,wb|19,*pfcod||; offset to first reloc| 7632
||brn|6,rld04|||; all set| 7633
;
;      tbblk, vcblk
;
|rld17|mov|8,wa|13,offs2(xr)||; load length| 7637
||mov|8,wb|19,*offs3||; set offset| 7638
||brn|6,rld04|||; jump back| 7639
;
;      teblk
;
|rld18|mov|8,wa|19,*tesi_||; set length| 7643
||mov|8,wb|19,*tesub||; and offset| 7644
||brn|6,rld04|||; all set| 7645
;
;      trblk
;
|rld19|mov|8,wa|19,*trsi_||; set length| 7649
||mov|8,wb|19,*trval||; and offset| 7650
||brn|6,rld04|||; all set| 7651
;
;      xrblk
;
|rld20|mov|8,wa|13,xrlen(xr)||; load length| 7655
||mov|8,wb|19,*xrptr||; set offset| 7656
||brn|6,rld04|||; jump back| 7657
||enp||||; end procedure reldn| 7658
||ejc||||| 7659
;
;      reloc -- relocate storage after save file reload
;
;      (xl)		     list of boundaries and adjustments
;      jsr  reloc	     relocate all pointers
;      (wa,wb,wc,xr)	     destroyed
;
;      the list of boundaries and adjustments pointed to by
;      register xl is created by a call to relcr, which should
;      be consulted for information on its structure.
;
|reloc|prc|25,e|1,0||; entry point| 7671
||mov|7,xr|13,rldys(xl)||; old start of dynamic| 7672
||mov|8,wc|13,rldye(xl)||; old end of dynamic| 7673
||add|7,xr|13,rldya(xl)||; create new start of dynamic| 7674
||add|8,wc|13,rldya(xl)||; create new end of dynamic| 7675
||jsr|6,reldn|||; relocate pointers in dynamic| 7676
||jsr|6,relws|||; relocate pointers in working sect| 7677
||jsr|6,relst|||; relocate pointers in static| 7678
||exi||||; return to caller| 7679
||enp||||; end procedure reloc| 7680
||ejc||||| 7681
;
;      relst -- relocate pointers in the static region
;
;      (xl)		     list of boundaries and adjustments
;      jsr  relst	     call to process blocks in static
;      (wa,wb,wc,xr)	     destroyed
;
;      only vrblks on the hash chain and any profile block are
;      processed.  other static blocks (dfblks) are processed
;      during processing of dynamic blocks.
;
;      global work locations will be processed at this point,
;      so pointers there can be relied upon.
;
|relst|prc|25,e|1,0||; entry point| 7696
||mov|7,xr|3,pftbl||; profile table| 7697
||bze|7,xr|6,rls01||; branch if no table allocated| 7698
||add|9,(xr)|13,rlcda(xl)||; adjust block type word| 7699
;
;      here after dealing with profiler
;
|rls01|mov|8,wc|3,hshtb||; point to start of hash table| 7703
||mov|8,wb|8,wc||; point to first hash bucket| 7704
||mov|8,wa|3,hshte||; point beyond hash table| 7705
||jsr|6,relaj|||; adjust bucket pointers| 7706
;
;      loop through slots in hash table
;
|rls02|beq|8,wc|3,hshte|6,rls05|; done if none left| 7710
||mov|7,xr|8,wc||; else copy slot pointer| 7711
||ica|8,wc|||; bump slot pointer| 7712
||sub|7,xr|19,*vrnxt||; set offset to merge into loop| 7713
;
;      loop through vrblks on one hash chain
;
|rls03|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain| 7717
||bze|7,xr|6,rls02||; jump for next bucket if chain end| 7718
||mov|8,wa|19,*vrlen||; offset of first loc past ptr fields| 7719
||mov|8,wb|19,*vrget||; offset of first location in vrblk| 7720
||bnz|13,vrlen(xr)|6,rls04||; jump if not system variable| 7721
||mov|8,wa|19,*vrsi_||; offset to include vrsvp field| 7722
;
;      merge here to process fields of vrblk
;
|rls04|add|8,wa|7,xr||; create end ptr| 7726
||add|8,wb|7,xr||; create start ptr| 7727
||jsr|6,relaj|||; adjust pointers in vrblk| 7728
||brn|6,rls03|||; check for another vrblk on chain| 7729
;
;      here when all vrblks processed
;
|rls05|exi||||; return to caller| 7733
||enp||||; end procedure relst| 7734
||ejc||||| 7735
;
;      relws -- relocate pointers in the working section
;
;      (xl)		     list of boundaries and adjustments
;      jsr  relws	     call to process working section
;      (wa,wb,wc,xr)	     destroyed
;
;      pointers between a_aaa and r_yyy are examined and
;      adjusted if necessary.  the pointer kvrtn is also
;      adjusted although it lies outside this range.
;      dname is explicitly adjusted because the limits
;      on dynamic region in stack are to the area actively
;      in use (between dnamb and dnamp), and dname is outside
;      this range.
;
|relws|prc|25,e|1,0||; entry point| 7751
||mov|8,wb|20,=a_aaa||; point to start of adjustables| 7752
||mov|8,wa|20,=r_yyy||; point to end of adjustables| 7753
||jsr|6,relaj|||; relocate adjustable pointers| 7754
||add|3,dname|13,rldya(xl)||; adjust ptr missed by relaj| 7755
||mov|8,wb|20,=kvrtn||; case of kvrtn| 7756
||mov|8,wa|8,wb||; handled specially| 7757
||ica|8,wa|||; one value to adjust| 7758
||jsr|6,relaj|||; adjust kvrtn| 7759
||exi||||; return to caller| 7760
||enp||||; end procedure relws| 7761
||ttl|27,s p i t b o l -- initialization|||| 7763
;
;      initialisation
;      the following section receives control from the system
;      at the start of a run with the registers set as follows.
;
;      (wa)		     initial stack pointer
;      (xr)		     points to first word of data area
;      (xl)		     points to last word of data area
;
|start|prc|25,e|1,0||; entry point| 7773
;z-
||mov|3,mxint|8,wb||;| 7775
||mov|4,bitsm|8,wb||;| 7776
||zer|8,wb|||;| 7777
||mov|7,xs|8,wa||; discard return| 7778
;z+
||jsr|6,systm|||; initialise timer| 7780
||sti|3,timsx|||; store time| 7782
||mov|3,statb|7,xr||; start address of static| 7783
||mov|3,rsmem|19,*e_srs||; reserve memory| 7835
||mov|3,stbas|7,xs||; store stack base| 7836
||sss|3,iniss|||; save s-r stack ptr| 7837
;
;      now convert free store percentage to a suitable factor
;      for easy testing in alloc routine.
;
||ldi|4,intvh|||; get 100| 7842
||dvi|4,alfsp|||; form 100 / alfsp| 7843
||sti|3,alfsf|||; store the factor| 7844
;
;      now convert free sediment percentage to a suitable factor
;      for easy testing in gbcol routine.
;
||ldi|4,intvh|||; get 100| 7850
||dvi|4,gbsdp|||; form 100 / gbsdp| 7851
||sti|3,gbsed|||; store the factor| 7852
;
;      initialize values for real conversion routine
;
||lct|8,wb|18,=cfp_s||; load counter for significant digits| 7861
||ldr|4,reav1|||; load 1.0| 7862
;
;      loop to compute 10**(max number significant digits)
;
|ini03|mlr|4,reavt|||; * 10.0| 7866
||bct|8,wb|6,ini03||; loop till done| 7867
||str|3,gtssc|||; store 10**(max sig digits)| 7868
||ldr|4,reap5|||; load 0.5| 7869
||dvr|3,gtssc|||; compute 0.5*10**(max sig digits)| 7870
||str|3,gtsrn|||; store as rounding bias| 7871
||zer|8,wc|||; set to read parameters| 7874
||jsr|6,prpar|||; read them| 7875
||ejc||||| 7876
;
;      now compute starting address for dynamic store and if
;      necessary request more memory.
;
||sub|7,xl|19,*e_srs||; allow for reserve memory| 7881
||mov|8,wa|3,prlen||; get print buffer length| 7882
||add|8,wa|18,=cfp_a||; add no. of chars in alphabet| 7883
||add|8,wa|18,=nstmx||; add chars for gtstg bfr| 7884
||ctb|8,wa|1,8||; convert to bytes, allowing a margin| 7885
||mov|7,xr|3,statb||; point to static base| 7886
||add|7,xr|8,wa||; increment for above buffers| 7887
||add|7,xr|19,*e_hnb||; increment for hash table| 7888
||add|7,xr|19,*e_sts||; bump for initial static block| 7889
||jsr|6,sysmx|||; get mxlen| 7890
||mov|3,kvmxl|8,wa||; provisionally store as maxlngth| 7891
||mov|3,mxlen|8,wa||; and as mxlen| 7892
||bgt|7,xr|8,wa|6,ini06|; skip if static hi exceeds mxlen| 7893
||ctb|8,wa|1,1||; round up and make bigger than mxlen| 7894
||mov|7,xr|8,wa||; use it instead| 7895
;
;      here to store values which mark initial division
;      of data area into static and dynamic
;
|ini06|mov|3,dnamb|7,xr||; dynamic base adrs| 7900
||mov|3,dnamp|7,xr||; dynamic ptr| 7901
||bnz|8,wa|6,ini07||; skip if non-zero mxlen| 7902
||dca|7,xr|||; point a word in front| 7903
||mov|3,kvmxl|7,xr||; use as maxlngth| 7904
||mov|3,mxlen|7,xr||; and as mxlen| 7905
||ejc||||| 7906
;
;      loop here if necessary till enough memory obtained
;      so that dname is above dnamb
;
|ini07|mov|3,dname|7,xl||; store dynamic end address| 7911
||blt|3,dnamb|7,xl|6,ini09|; skip if high enough| 7912
||jsr|6,sysmm|||; request more memory| 7913
||wtb|7,xr|||; get as baus (sgd05)| 7914
||add|7,xl|7,xr||; bump by amount obtained| 7915
||bnz|7,xr|6,ini07||; try again| 7916
||mov|8,wa|18,=mxern||; insufficient memory for maxlength| 7918
||zer|8,wb|||; no column number info| 7919
||zer|8,wc|||; no line number info| 7920
||mov|7,xr|18,=stgic||; initial compile stage| 7921
||mov|7,xl|21,=nulls||; no file name| 7923
||jsr|6,sysea|||; advise of error| 7925
||ppm|6,ini08|||; cant use error logic yet| 7926
||brn|6,ini08|||; force termination| 7927
;
;      insert text for error 329 in error message table
;
||erb|1,329|26,requested maxlngth too large||| 7931
|ini08|mov|7,xr|21,=endmo||; point to failure message| 7933
||mov|8,wa|4,endml||; message length| 7934
||jsr|6,syspr|||; print it (prtst not yet usable)| 7935
||ppm||||; should not fail| 7936
||zer|7,xl|||; no fcb chain yet| 7937
||mov|8,wb|18,=num10||; set special code value| 7938
||jsr|6,sysej|||; pack up (stopr not yet usable)| 7939
;
;      initialise structures at start of static region
;
|ini09|mov|7,xr|3,statb||; point to static again| 7943
||jsr|6,insta|||; initialize static| 7944
;
;      initialize number of hash headers
;
||mov|8,wa|18,=e_hnb||; get number of hash headers| 7948
||mti|8,wa|||; convert to integer| 7949
||sti|3,hshnb|||; store for use by gtnvr procedure| 7950
||lct|8,wa|8,wa||; counter for clearing hash table| 7951
||mov|3,hshtb|7,xr||; pointer to hash table| 7952
;
;      loop to clear hash table
;
|ini11|zer|10,(xr)+|||; blank a word| 7956
||bct|8,wa|6,ini11||; loop| 7957
||mov|3,hshte|7,xr||; end of hash table adrs is kept| 7958
||mov|3,state|7,xr||; store static end address| 7959
;
;      init table to map statement numbers to source file names
;
||mov|8,wc|18,=num01||; table will have only one bucket| 7964
||mov|7,xl|21,=nulls||; default table value| 7965
||mov|3,r_sfc|7,xl||; current source file name| 7966
||jsr|6,tmake|||; create table| 7967
||mov|3,r_sfn|7,xr||; save ptr to table| 7968
;
;      initialize table to detect duplicate include file names
;
||mov|8,wc|18,=num01||; table will have only one bucket| 7974
||mov|7,xl|21,=nulls||; default table value| 7975
||jsr|6,tmake|||; create table| 7976
||mov|3,r_inc|7,xr||; save ptr to table| 7977
;
;      initialize array to hold names of nested include files
;
||mov|8,wa|18,=ccinm||; maximum nesting level| 7982
||mov|7,xl|21,=nulls||; null string default value| 7983
||jsr|6,vmake|||; create array| 7984
||ppm||||| 7985
||mov|3,r_ifa|7,xr||; save ptr to array| 7986
;
;      init array to hold line numbers of nested include files
;
||mov|8,wa|18,=ccinm||; maximum nesting level| 7990
||mov|7,xl|21,=inton||; integer one default value| 7991
||jsr|6,vmake|||; create array| 7992
||ppm||||| 7993
||mov|3,r_ifl|7,xr||; save ptr to array| 7994
;z+
;
;      initialize variable blocks for input and output
;
||mov|7,xl|21,=v_inp||; point to string /input/| 8001
||mov|8,wb|18,=trtin||; trblk type for input| 8002
||jsr|6,inout|||; perform input association| 8003
||mov|7,xl|21,=v_oup||; point to string /output/| 8004
||mov|8,wb|18,=trtou||; trblk type for output| 8005
||jsr|6,inout|||; perform output association| 8006
||mov|8,wc|3,initr||; terminal flag| 8007
||bze|8,wc|6,ini13||; skip if no terminal| 8008
||jsr|6,prpar|||; associate terminal| 8009
||ejc||||| 8010
;
;      check for expiry date
;
|ini13|jsr|6,sysdc|||; call date check| 8014
||mov|3,flptr|7,xs||; in case stack overflows in compiler| 8015
;
;      now compile source input code
;
||jsr|6,cmpil|||; call compiler| 8019
||mov|3,r_cod|7,xr||; set ptr to first code block| 8020
||mov|3,r_ttl|21,=nulls||; forget title| 8021
||mov|3,r_stl|21,=nulls||; forget sub-title| 8022
||zer|3,r_cim|||; forget compiler input image| 8023
||zer|3,r_ccb|||; forget interim code block| 8024
||zer|3,cnind|||; in case end occurred with include| 8026
||zer|3,lstid|||; listing include depth| 8027
||zer|7,xl|||; clear dud value| 8029
||zer|8,wb|||; dont shift dynamic store up| 8030
||zer|3,dnams|||; collect sediment too| 8032
||jsr|6,gbcol|||; clear garbage left from compile| 8033
||mov|3,dnams|7,xr||; record new sediment size| 8034
||bnz|3,cpsts|6,inix0||; skip if no listing of comp stats| 8038
||jsr|6,prtpg|||; eject page| 8039
;
;      print compile statistics
;
||jsr|6,prtmm|||; print memory usage| 8043
||mti|3,cmerc|||; get count of errors as integer| 8044
||mov|7,xr|21,=encm3||; point to /compile errors/| 8045
||jsr|6,prtmi|||; print it| 8046
||mti|3,gbcnt|||; garbage collection count| 8047
||sbi|4,intv1|||; adjust for unavoidable collect| 8048
||mov|7,xr|21,=stpm5||; point to /storage regenerations/| 8049
||jsr|6,prtmi|||; print gbcol count| 8050
||jsr|6,systm|||; get time| 8051
||sbi|3,timsx|||; get compilation time| 8052
||mov|7,xr|21,=encm4||; point to compilation time (msec)/| 8053
||jsr|6,prtmi|||; print message| 8054
||add|3,lstlc|18,=num05||; bump line count| 8055
||bze|3,headp|6,inix0||; no eject if nothing printed| 8057
||jsr|6,prtpg|||; eject printer| 8058
||ejc||||| 8060
;
;      prepare now to start execution
;
;      set default input record length
;
|inix0|bgt|3,cswin|18,=iniln|6,inix1|; skip if not default -in72 used| 8066
||mov|3,cswin|18,=inils||; else use default record length| 8067
;
;      reset timer
;
|inix1|jsr|6,systm|||; get time again| 8071
||sti|3,timsx|||; store for end run processing| 8072
||zer|3,gbcnt|||; initialise collect count| 8073
||jsr|6,sysbx|||; call before starting execution| 8074
||add|3,noxeq|3,cswex||; add -noexecute flag| 8075
||bnz|3,noxeq|6,inix2||; jump if execution suppressed| 8076
;
;      merge when listing file set for execution.  also
;      merge here when restarting a save file or load module.
;
|iniy0|mnz|3,headp|||; mark headers out regardless| 8086
||zer|11,-(xs)|||; set failure location on stack| 8087
||mov|3,flptr|7,xs||; save ptr to failure offset word| 8088
||mov|7,xr|3,r_cod||; load ptr to entry code block| 8089
||mov|3,stage|18,=stgxt||; set stage for execute time| 8090
||mov|3,polcs|18,=num01||; reset interface polling interval| 8092
||mov|3,polct|18,=num01||; reset interface polling interval| 8093
||mov|3,pfnte|3,cmpsn||; copy stmts compiled count in case| 8097
||mov|3,pfdmp|3,kvpfl||; start profiling if &profile set| 8098
||jsr|6,systm|||; time yet again| 8099
||sti|3,pfstm|||;| 8100
||jsr|6,stgcc|||; compute stmgo countdown counters| 8102
||bri|9,(xr)|||; start xeq with first statement| 8103
;
;      here if execution is suppressed
;
|inix2|zer|8,wa|||; set abend value to zero| 8108
||mov|8,wb|18,=nini9||; set special code value| 8116
||zer|7,xl|||; no fcb chain| 8117
||jsr|6,sysej|||; end of job, exit to system| 8118
||enp||||; end procedure start| 8119
;
;      here from osint to restart a save file or load module.
;
|rstrt|prc|25,e|1,0||; entry point| 8123
||mov|7,xs|3,stbas||; discard return| 8124
||zer|7,xl|||; clear xl| 8125
||brn|6,iniy0|||; resume execution| 8126
||enp||||; end procedure rstrt| 8127
||ttl|27,s p i t b o l -- snobol4 operator routines|||| 8129
;
;      this section includes all routines which can be accessed
;      directly from the generated code except system functions.
;
;      all routines in this section start with a label of the
;      form o_xxx where xxx is three letters. the generated code
;      contains a pointer to the appropriate entry label.
;
;      since the general form of the generated code consists of
;      pointers to blocks whose first word is the address of the
;      actual entry point label (o_xxx).
;
;      these routines are in alphabetical order by their
;      entry label names (i.e. by the xxx of the o_xxx name)
;
;      these routines receive control as follows
;
;      (cp)		     pointer to next code word
;      (xs)		     current stack pointer
||ejc||||| 8149
;
;      binary plus (addition)
;
|o_add|ent||||; entry point| 8153
;z+
||jsr|6,arith|||; fetch arithmetic operands| 8155
||err|1,001|26,addition left operand is not numeric||| 8156
||err|1,002|26,addition right operand is not numeric||| 8157
||ppm|6,oadd1|||; jump if real operands| 8160
;
;      here to add two integers
;
||adi|13,icval(xl)|||; add right operand to left| 8165
||ino|6,exint|||; return integer if no overflow| 8166
||erb|1,003|26,addition caused integer overflow||| 8167
;
;      here to add two reals
;
|oadd1|adr|13,rcval(xl)|||; add right operand to left| 8173
||rno|6,exrea|||; return real if no overflow| 8174
||erb|1,261|26,addition caused real overflow||| 8175
||ejc||||| 8177
;
;      unary plus (affirmation)
;
|o_aff|ent||||; entry point| 8181
||mov|7,xr|10,(xs)+||; load operand| 8182
||jsr|6,gtnum|||; convert to numeric| 8183
||err|1,004|26,affirmation operand is not numeric||| 8184
||mov|11,-(xs)|7,xr||; result if converted to numeric| 8185
||lcw|7,xr|||; get next code word| 8186
||bri|9,(xr)|||; execute it| 8187
||ejc||||| 8188
;
;      binary bar (alternation)
;
|o_alt|ent||||; entry point| 8192
||mov|7,xr|10,(xs)+||; load right operand| 8193
||jsr|6,gtpat|||; convert to pattern| 8194
||err|1,005|26,alternation right operand is not pattern||| 8195
;
;      merge here from special (left alternation) case
;
|oalt1|mov|8,wb|22,=p_alt||; set pcode for alternative node| 8199
||jsr|6,pbild|||; build alternative node| 8200
||mov|7,xl|7,xr||; save address of alternative node| 8201
||mov|7,xr|10,(xs)+||; load left operand| 8202
||jsr|6,gtpat|||; convert to pattern| 8203
||err|1,006|26,alternation left operand is not pattern||| 8204
||beq|7,xr|22,=p_alt|6,oalt2|; jump if left arg is alternation| 8205
||mov|13,pthen(xl)|7,xr||; set left operand as successor| 8206
||mov|11,-(xs)|7,xl||; stack result| 8207
||lcw|7,xr|||; get next code word| 8208
||bri|9,(xr)|||; execute it| 8209
;
;      come here if left argument is itself an alternation
;
;      the result is more efficient if we make the replacement
;
;      (a / b) / c = a / (b / c)
;
|oalt2|mov|13,pthen(xl)|13,parm1(xr)||; build the (b / c) node| 8217
||mov|11,-(xs)|13,pthen(xr)||; set a as new left arg| 8218
||mov|7,xr|7,xl||; set (b / c) as new right arg| 8219
||brn|6,oalt1|||; merge back to build a / (b / c)| 8220
||ejc||||| 8221
;
;      array reference (multiple subscripts, by name)
;
|o_amn|ent||||; entry point| 8225
||lcw|7,xr|||; load number of subscripts| 8226
||mov|8,wb|7,xr||; set flag for by name| 8227
||brn|6,arref|||; jump to array reference routine| 8228
||ejc||||| 8229
;
;      array reference (multiple subscripts, by value)
;
|o_amv|ent||||; entry point| 8233
||lcw|7,xr|||; load number of subscripts| 8234
||zer|8,wb|||; set flag for by value| 8235
||brn|6,arref|||; jump to array reference routine| 8236
||ejc||||| 8237
;
;      array reference (one subscript, by name)
;
|o_aon|ent||||; entry point| 8241
||mov|7,xr|9,(xs)||; load subscript value| 8242
||mov|7,xl|13,num01(xs)||; load array value| 8243
||mov|8,wa|9,(xl)||; load first word of array operand| 8244
||beq|8,wa|22,=b_vct|6,oaon2|; jump if vector reference| 8245
||beq|8,wa|22,=b_tbt|6,oaon3|; jump if table reference| 8246
;
;      here to use central array reference routine
;
|oaon1|mov|7,xr|18,=num01||; set number of subscripts to one| 8250
||mov|8,wb|7,xr||; set flag for by name| 8251
||brn|6,arref|||; jump to array reference routine| 8252
;
;      here if we have a vector reference
;
|oaon2|bne|9,(xr)|22,=b_icl|6,oaon1|; use long routine if not integer| 8256
||ldi|13,icval(xr)|||; load integer subscript value| 8257
||mfi|8,wa|6,exfal||; copy as address int, fail if ovflo| 8258
||bze|8,wa|6,exfal||; fail if zero| 8259
||add|8,wa|18,=vcvlb||; compute offset in words| 8260
||wtb|8,wa|||; convert to bytes| 8261
||mov|9,(xs)|8,wa||; complete name on stack| 8262
||blt|8,wa|13,vclen(xl)|6,oaon4|; exit if subscript not too large| 8263
||brn|6,exfal|||; else fail| 8264
;
;      here for table reference
;
|oaon3|mnz|8,wb|||; set flag for name reference| 8268
||jsr|6,tfind|||; locate/create table element| 8269
||ppm|6,exfal|||; fail if access fails| 8270
||mov|13,num01(xs)|7,xl||; store name base on stack| 8271
||mov|9,(xs)|8,wa||; store name offset on stack| 8272
;
;      here to exit with result on stack
;
|oaon4|lcw|7,xr|||; result on stack, get code word| 8276
||bri|9,(xr)|||; execute next code word| 8277
||ejc||||| 8278
;
;      array reference (one subscript, by value)
;
|o_aov|ent||||; entry point| 8282
||mov|7,xr|10,(xs)+||; load subscript value| 8283
||mov|7,xl|10,(xs)+||; load array value| 8284
||mov|8,wa|9,(xl)||; load first word of array operand| 8285
||beq|8,wa|22,=b_vct|6,oaov2|; jump if vector reference| 8286
||beq|8,wa|22,=b_tbt|6,oaov3|; jump if table reference| 8287
;
;      here to use central array reference routine
;
|oaov1|mov|11,-(xs)|7,xl||; restack array value| 8291
||mov|11,-(xs)|7,xr||; restack subscript| 8292
||mov|7,xr|18,=num01||; set number of subscripts to one| 8293
||zer|8,wb|||; set flag for value call| 8294
||brn|6,arref|||; jump to array reference routine| 8295
;
;      here if we have a vector reference
;
|oaov2|bne|9,(xr)|22,=b_icl|6,oaov1|; use long routine if not integer| 8299
||ldi|13,icval(xr)|||; load integer subscript value| 8300
||mfi|8,wa|6,exfal||; move as one word int, fail if ovflo| 8301
||bze|8,wa|6,exfal||; fail if zero| 8302
||add|8,wa|18,=vcvlb||; compute offset in words| 8303
||wtb|8,wa|||; convert to bytes| 8304
||bge|8,wa|13,vclen(xl)|6,exfal|; fail if subscript too large| 8305
||jsr|6,acess|||; access value| 8306
||ppm|6,exfal|||; fail if access fails| 8307
||mov|11,-(xs)|7,xr||; stack result| 8308
||lcw|7,xr|||; get next code word| 8309
||bri|9,(xr)|||; execute it| 8310
;
;      here for table reference by value
;
|oaov3|zer|8,wb|||; set flag for value reference| 8314
||jsr|6,tfind|||; call table search routine| 8315
||ppm|6,exfal|||; fail if access fails| 8316
||mov|11,-(xs)|7,xr||; stack result| 8317
||lcw|7,xr|||; get next code word| 8318
||bri|9,(xr)|||; execute it| 8319
||ejc||||| 8320
;
;      assignment
;
|o_ass|ent||||; entry point| 8324
;
;      o_rpl (pattern replacement) merges here
;
|oass0|mov|8,wb|10,(xs)+||; load value to be assigned| 8328
||mov|8,wa|10,(xs)+||; load name offset| 8329
||mov|7,xl|9,(xs)||; load name base| 8330
||mov|9,(xs)|8,wb||; store assigned value as result| 8331
||jsr|6,asign|||; perform assignment| 8332
||ppm|6,exfal|||; fail if assignment fails| 8333
||lcw|7,xr|||; result on stack, get code word| 8334
||bri|9,(xr)|||; execute next code word| 8335
||ejc||||| 8336
;
;      compilation error
;
|o_cer|ent||||; entry point| 8340
||erb|1,007|26,compilation error encountered during execution||| 8341
||ejc||||| 8342
;
;      unary at (cursor assignment)
;
|o_cas|ent||||; entry point| 8346
||mov|8,wc|10,(xs)+||; load name offset (parm2)| 8347
||mov|7,xr|10,(xs)+||; load name base (parm1)| 8348
||mov|8,wb|22,=p_cas||; set pcode for cursor assignment| 8349
||jsr|6,pbild|||; build node| 8350
||mov|11,-(xs)|7,xr||; stack result| 8351
||lcw|7,xr|||; get next code word| 8352
||bri|9,(xr)|||; execute it| 8353
||ejc||||| 8354
;
;      concatenation
;
|o_cnc|ent||||; entry point| 8358
||mov|7,xr|9,(xs)||; load right argument| 8359
||beq|7,xr|21,=nulls|6,ocnc3|; jump if right arg is null| 8360
||mov|7,xl|12,1(xs)||; load left argument| 8361
||beq|7,xl|21,=nulls|6,ocnc4|; jump if left argument is null| 8362
||mov|8,wa|22,=b_scl||; get constant to test for string| 8363
||bne|8,wa|9,(xl)|6,ocnc2|; jump if left arg not a string| 8364
||bne|8,wa|9,(xr)|6,ocnc2|; jump if right arg not a string| 8365
;
;      merge here to concatenate two strings
;
|ocnc1|mov|8,wa|13,sclen(xl)||; load left argument length| 8369
||add|8,wa|13,sclen(xr)||; compute result length| 8370
||jsr|6,alocs|||; allocate scblk for result| 8371
||mov|12,1(xs)|7,xr||; store result ptr over left argument| 8372
||psc|7,xr|||; prepare to store chars of result| 8373
||mov|8,wa|13,sclen(xl)||; get number of chars in left arg| 8374
||plc|7,xl|||; prepare to load left arg chars| 8375
||mvc||||; move characters of left argument| 8376
||mov|7,xl|10,(xs)+||; load right arg pointer, pop stack| 8377
||mov|8,wa|13,sclen(xl)||; load number of chars in right arg| 8378
||plc|7,xl|||; prepare to load right arg chars| 8379
||mvc||||; move characters of right argument| 8380
||zer|7,xl|||; clear garbage value in xl| 8381
||lcw|7,xr|||; result on stack, get code word| 8382
||bri|9,(xr)|||; execute next code word| 8383
;
;      come here if arguments are not both strings
;
|ocnc2|jsr|6,gtstg|||; convert right arg to string| 8387
||ppm|6,ocnc5|||; jump if right arg is not string| 8388
||mov|7,xl|7,xr||; save right arg ptr| 8389
||jsr|6,gtstg|||; convert left arg to string| 8390
||ppm|6,ocnc6|||; jump if left arg is not a string| 8391
||mov|11,-(xs)|7,xr||; stack left argument| 8392
||mov|11,-(xs)|7,xl||; stack right argument| 8393
||mov|7,xl|7,xr||; move left arg to proper reg| 8394
||mov|7,xr|9,(xs)||; move right arg to proper reg| 8395
||brn|6,ocnc1|||; merge back to concatenate strings| 8396
||ejc||||| 8397
;
;      concatenation (continued)
;
;      come here for null right argument
;
|ocnc3|ica|7,xs|||; remove right arg from stack| 8403
||lcw|7,xr|||; left argument on stack| 8404
||bri|9,(xr)|||; execute next code word| 8405
;
;      here for null left argument
;
|ocnc4|ica|7,xs|||; unstack one argument| 8409
||mov|9,(xs)|7,xr||; store right argument| 8410
||lcw|7,xr|||; result on stack, get code word| 8411
||bri|9,(xr)|||; execute next code word| 8412
;
;      here if right argument is not a string
;
|ocnc5|mov|7,xl|7,xr||; move right argument ptr| 8416
||mov|7,xr|10,(xs)+||; load left arg pointer| 8417
;
;      merge here when left argument is not a string
;
|ocnc6|jsr|6,gtpat|||; convert left arg to pattern| 8421
||err|1,008|26,concatenation left operand is not a string or pattern||| 8422
||mov|11,-(xs)|7,xr||; save result on stack| 8423
||mov|7,xr|7,xl||; point to right operand| 8424
||jsr|6,gtpat|||; convert to pattern| 8425
||err|1,009|26,concatenation right operand is not a string or pattern||| 8426
||mov|7,xl|7,xr||; move for pconc| 8427
||mov|7,xr|10,(xs)+||; reload left operand ptr| 8428
||jsr|6,pconc|||; concatenate patterns| 8429
||mov|11,-(xs)|7,xr||; stack result| 8430
||lcw|7,xr|||; get next code word| 8431
||bri|9,(xr)|||; execute it| 8432
||ejc||||| 8433
;
;      complementation
;
|o_com|ent||||; entry point| 8437
||mov|7,xr|10,(xs)+||; load operand| 8438
||mov|8,wa|9,(xr)||; load type word| 8439
;
;      merge back here after conversion
;
|ocom1|beq|8,wa|22,=b_icl|6,ocom2|; jump if integer| 8443
||beq|8,wa|22,=b_rcl|6,ocom3|; jump if real| 8446
||jsr|6,gtnum|||; else convert to numeric| 8448
||err|1,010|26,negation operand is not numeric||| 8449
||brn|6,ocom1|||; back to check cases| 8450
;
;      here to complement integer
;
|ocom2|ldi|13,icval(xr)|||; load integer value| 8454
||ngi||||; negate| 8455
||ino|6,exint|||; return integer if no overflow| 8456
||erb|1,011|26,negation caused integer overflow||| 8457
;
;      here to complement real
;
|ocom3|ldr|13,rcval(xr)|||; load real value| 8463
||ngr||||; negate| 8464
||brn|6,exrea|||; return real result| 8465
||ejc||||| 8467
;
;      binary slash (division)
;
|o_dvd|ent||||; entry point| 8471
||jsr|6,arith|||; fetch arithmetic operands| 8472
||err|1,012|26,division left operand is not numeric||| 8473
||err|1,013|26,division right operand is not numeric||| 8474
||ppm|6,odvd2|||; jump if real operands| 8477
;
;      here to divide two integers
;
||dvi|13,icval(xl)|||; divide left operand by right| 8482
||ino|6,exint|||; result ok if no overflow| 8483
||erb|1,014|26,division caused integer overflow||| 8484
;
;      here to divide two reals
;
|odvd2|dvr|13,rcval(xl)|||; divide left operand by right| 8490
||rno|6,exrea|||; return real if no overflow| 8491
||erb|1,262|26,division caused real overflow||| 8492
||ejc||||| 8494
;
;      exponentiation
;
|o_exp|ent||||; entry point| 8498
||mov|7,xr|10,(xs)+||; load exponent| 8499
||jsr|6,gtnum|||; convert to number| 8500
||err|1,015|26,exponentiation right operand is not numeric||| 8501
||mov|7,xl|7,xr||; move exponent to xl| 8502
||mov|7,xr|10,(xs)+||; load base| 8503
||jsr|6,gtnum|||; convert to numeric| 8504
||err|1,016|26,exponentiation left operand is not numeric||| 8505
||beq|9,(xl)|22,=b_rcl|6,oexp7|; jump if real exponent| 8508
||ldi|13,icval(xl)|||; load exponent| 8510
||ilt|6,oex12|||; jump if negative exponent| 8511
||beq|8,wa|22,=b_rcl|6,oexp3|; jump if base is real| 8514
;
;      here to exponentiate an integer base and integer exponent
;
||mfi|8,wa|6,oexp2||; convert exponent to 1 word integer| 8519
||lct|8,wa|8,wa||; set loop counter| 8520
||ldi|13,icval(xr)|||; load base as initial value| 8521
||bnz|8,wa|6,oexp1||; jump into loop if non-zero exponent| 8522
||ieq|6,oexp4|||; error if 0**0| 8523
||ldi|4,intv1|||; nonzero**0| 8524
||brn|6,exint|||; give one as result for nonzero**0| 8525
;
;      loop to perform exponentiation
;
|oex13|mli|13,icval(xr)|||; multiply by base| 8529
||iov|6,oexp2|||; jump if overflow| 8530
|oexp1|bct|8,wa|6,oex13||; loop if more to go| 8531
||brn|6,exint|||; else return integer result| 8532
;
;      here if integer overflow
;
|oexp2|erb|1,017|26,exponentiation caused integer overflow||| 8536
||ejc||||| 8537
;
;      exponentiation (continued)
;
;      here to exponentiate a real to an integer power
;
|oexp3|mfi|8,wa|6,oexp6||; convert exponent to one word| 8545
||lct|8,wa|8,wa||; set loop counter| 8546
||ldr|13,rcval(xr)|||; load base as initial value| 8547
||bnz|8,wa|6,oexp5||; jump into loop if non-zero exponent| 8548
||req|6,oexp4|||; error if 0.0**0| 8549
||ldr|4,reav1|||; nonzero**0| 8550
||brn|6,exrea|||; return 1.0 if nonzero**zero| 8551
;
;      here for error of 0**0 or 0.0**0
;
|oexp4|erb|1,018|26,exponentiation result is undefined||| 8556
;
;      loop to perform exponentiation
;
|oex14|mlr|13,rcval(xr)|||; multiply by base| 8562
||rov|6,oexp6|||; jump if overflow| 8563
|oexp5|bct|8,wa|6,oex14||; loop till computation complete| 8564
||brn|6,exrea|||; then return real result| 8565
;
;      here if real overflow
;
|oexp6|erb|1,266|26,exponentiation caused real overflow||| 8569
;
;      here with real exponent in (xl), numeric base in (xr)
;
|oexp7|beq|9,(xr)|22,=b_rcl|6,oexp8|; jump if base real| 8574
||ldi|13,icval(xr)|||; load integer base| 8575
||itr||||; convert to real| 8576
||jsr|6,rcbld|||; create real in (xr)| 8577
;
;      here with real exponent in (xl)
;      numeric base in (xr) and ra
;
|oexp8|zer|8,wb|||; set positive result flag| 8582
||ldr|13,rcval(xr)|||; load base to ra| 8583
||rne|6,oexp9|||; jump if base non-zero| 8584
||ldr|13,rcval(xl)|||; base is zero.	 check exponent| 8585
||req|6,oexp4|||; jump if 0.0 ** 0.0| 8586
||ldr|4,reav0|||; 0.0 to non-zero exponent yields 0.0| 8587
||brn|6,exrea|||; return zero result| 8588
;
;      here with non-zero base in (xr) and ra, exponent in (xl)
;
;      a negative base is allowed if the exponent is integral.
;
|oexp9|rgt|6,oex10|||; jump if base gt 0.0| 8594
||ngr||||; make base positive| 8595
||jsr|6,rcbld|||; create positive base in (xr)| 8596
||ldr|13,rcval(xl)|||; examine exponent| 8597
||chp||||; chop to integral value| 8598
||rti|6,oexp6|||; convert to integer, br if too large| 8599
||sbr|13,rcval(xl)|||; chop(exponent) - exponent| 8600
||rne|6,oex11|||; non-integral power with neg base| 8601
||mfi|8,wb|||; record even/odd exponent| 8602
||anb|8,wb|4,bits1||; odd exponent yields negative result| 8603
||ldr|13,rcval(xr)|||; restore base to ra| 8604
;
;      here with positive base in ra and (xr), exponent in (xl)
;
|oex10|lnf||||; log of base| 8608
||rov|6,oexp6|||; too large| 8609
||mlr|13,rcval(xl)|||; times exponent| 8610
||rov|6,oexp6|||; too large| 8611
||etx||||; e ** (exponent * ln(base))| 8612
||rov|6,oexp6|||; too large| 8613
||bze|8,wb|6,exrea||; if no sign fixup required| 8614
||ngr||||; negative result needed| 8615
||brn|6,exrea|||;| 8616
;
;      here for non-integral exponent with negative base
;
|oex11|erb|1,311|26,exponentiation of negative base to non-integral power||| 8620
;
;      here with negative integer exponent in ia
;
|oex12|mov|11,-(xs)|7,xr||; stack base| 8629
||itr||||; convert to real exponent| 8630
||jsr|6,rcbld|||; real negative exponent in (xr)| 8631
||mov|7,xl|7,xr||; put exponent in xl| 8632
||mov|7,xr|10,(xs)+||; restore base value| 8633
||brn|6,oexp7|||; process real exponent| 8634
||ejc||||| 8638
;
;      failure in expression evaluation
;
;      this entry point is used if the evaluation of an
;      expression, initiated by the evalx procedure, fails.
;      control is returned to an appropriate point in evalx.
;
|o_fex|ent||||; entry point| 8646
||brn|6,evlx6|||; jump to failure loc in evalx| 8647
||ejc||||| 8648
;
;      failure during evaluation of a complex or direct goto
;
|o_fif|ent||||; entry point| 8652
||erb|1,020|26,goto evaluation failure||| 8653
||ejc||||| 8654
;
;      function call (more than one argument)
;
|o_fnc|ent||||; entry point| 8658
||lcw|8,wa|||; load number of arguments| 8659
||lcw|7,xr|||; load function vrblk pointer| 8660
||mov|7,xl|13,vrfnc(xr)||; load function pointer| 8661
||bne|8,wa|13,fargs(xl)|6,cfunc|; use central routine if wrong num| 8662
||bri|9,(xl)|||; jump to function if arg count ok| 8663
||ejc||||| 8664
;
;      function name error
;
|o_fne|ent||||; entry point| 8668
||lcw|8,wa|||; get next code word| 8669
||bne|8,wa|21,=ornm_|6,ofne1|; fail if not evaluating expression| 8670
||bze|13,num02(xs)|6,evlx3||; ok if expr. was wanted by value| 8671
;
;      here for error
;
|ofne1|erb|1,021|26,function called by name returned a value||| 8675
||ejc||||| 8676
;
;      function call (single argument)
;
|o_fns|ent||||; entry point| 8680
||lcw|7,xr|||; load function vrblk pointer| 8681
||mov|8,wa|18,=num01||; set number of arguments to one| 8682
||mov|7,xl|13,vrfnc(xr)||; load function pointer| 8683
||bne|8,wa|13,fargs(xl)|6,cfunc|; use central routine if wrong num| 8684
||bri|9,(xl)|||; jump to function if arg count ok| 8685
||ejc||||| 8686
;      call to undefined function
;
|o_fun|ent||||; entry point| 8689
||erb|1,022|26,undefined function called||| 8690
||ejc||||| 8691
;
;      execute complex goto
;
|o_goc|ent||||; entry point| 8695
||mov|7,xr|13,num01(xs)||; load name base pointer| 8696
||bhi|7,xr|3,state|6,ogoc1|; jump if not natural variable| 8697
||add|7,xr|19,*vrtra||; else point to vrtra field| 8698
||bri|9,(xr)|||; and jump through it| 8699
;
;      here if goto operand is not natural variable
;
|ogoc1|erb|1,023|26,goto operand is not a natural variable||| 8703
||ejc||||| 8704
;
;      execute direct goto
;
|o_god|ent||||; entry point| 8708
||mov|7,xr|9,(xs)||; load operand| 8709
||mov|8,wa|9,(xr)||; load first word| 8710
||beq|8,wa|22,=b_cds|6,bcds0|; jump if code block to code routine| 8711
||beq|8,wa|22,=b_cdc|6,bcdc0|; jump if code block to code routine| 8712
||erb|1,024|26,goto operand in direct goto is not code||| 8713
||ejc||||| 8714
;
;      set goto failure trap
;
;      this routine is executed at the start of a complex or
;      direct failure goto to trap a subsequent fail (see exfal)
;
|o_gof|ent||||; entry point| 8721
||mov|7,xr|3,flptr||; point to fail offset on stack| 8722
||ica|9,(xr)|||; point failure to o_fif word| 8723
||icp||||; point to next code word| 8724
||lcw|7,xr|||; fetch next code word| 8725
||bri|9,(xr)|||; execute it| 8726
||ejc||||| 8727
;
;      binary dollar (immediate assignment)
;
;      the pattern built by binary dollar is a compound pattern.
;      see description at start of pattern match section for
;      details of the structure which is constructed.
;
|o_ima|ent||||; entry point| 8735
||mov|8,wb|22,=p_imc||; set pcode for last node| 8736
||mov|8,wc|10,(xs)+||; pop name offset (parm2)| 8737
||mov|7,xr|10,(xs)+||; pop name base (parm1)| 8738
||jsr|6,pbild|||; build p_imc node| 8739
||mov|7,xl|7,xr||; save ptr to node| 8740
||mov|7,xr|9,(xs)||; load left argument| 8741
||jsr|6,gtpat|||; convert to pattern| 8742
||err|1,025|26,immediate assignment left operand is not pattern||| 8743
||mov|9,(xs)|7,xr||; save ptr to left operand pattern| 8744
||mov|8,wb|22,=p_ima||; set pcode for first node| 8745
||jsr|6,pbild|||; build p_ima node| 8746
||mov|13,pthen(xr)|10,(xs)+||; set left operand as p_ima successor| 8747
||jsr|6,pconc|||; concatenate to form final pattern| 8748
||mov|11,-(xs)|7,xr||; stack result| 8749
||lcw|7,xr|||; get next code word| 8750
||bri|9,(xr)|||; execute it| 8751
||ejc||||| 8752
;
;      indirection (by name)
;
|o_inn|ent||||; entry point| 8756
||mnz|8,wb|||; set flag for result by name| 8757
||brn|6,indir|||; jump to common routine| 8758
||ejc||||| 8759
;
;      interrogation
;
|o_int|ent||||; entry point| 8763
||mov|9,(xs)|21,=nulls||; replace operand with null| 8764
||lcw|7,xr|||; get next code word| 8765
||bri|9,(xr)|||; execute next code word| 8766
||ejc||||| 8767
;
;      indirection (by value)
;
|o_inv|ent||||; entry point| 8771
||zer|8,wb|||; set flag for by value| 8772
||brn|6,indir|||; jump to common routine| 8773
||ejc||||| 8774
;
;      keyword reference (by name)
;
|o_kwn|ent||||; entry point| 8778
||jsr|6,kwnam|||; get keyword name| 8779
||brn|6,exnam|||; exit with result name| 8780
||ejc||||| 8781
;
;      keyword reference (by value)
;
|o_kwv|ent||||; entry point| 8785
||jsr|6,kwnam|||; get keyword name| 8786
||mov|3,dnamp|7,xr||; delete kvblk| 8787
||jsr|6,acess|||; access value| 8788
||ppm|6,exnul|||; dummy (unused) failure return| 8789
||mov|11,-(xs)|7,xr||; stack result| 8790
||lcw|7,xr|||; get next code word| 8791
||bri|9,(xr)|||; execute it| 8792
||ejc||||| 8793
;
;      load expression by name
;
|o_lex|ent||||; entry point| 8797
||mov|8,wa|19,*evsi_||; set size of evblk| 8798
||jsr|6,alloc|||; allocate space for evblk| 8799
||mov|9,(xr)|22,=b_evt||; set type word| 8800
||mov|13,evvar(xr)|21,=trbev||; set dummy trblk pointer| 8801
||lcw|8,wa|||; load exblk pointer| 8802
||mov|13,evexp(xr)|8,wa||; set exblk pointer| 8803
||mov|7,xl|7,xr||; move name base to proper reg| 8804
||mov|8,wa|19,*evvar||; set name offset = zero| 8805
||brn|6,exnam|||; exit with name in (xl,wa)| 8806
||ejc||||| 8807
;
;      load pattern value
;
|o_lpt|ent||||; entry point| 8811
||lcw|7,xr|||; load pattern pointer| 8812
||mov|11,-(xs)|7,xr||; stack result| 8813
||lcw|7,xr|||; get next code word| 8814
||bri|9,(xr)|||; execute it| 8815
||ejc||||| 8816
;
;      load variable name
;
|o_lvn|ent||||; entry point| 8820
||lcw|8,wa|||; load vrblk pointer| 8821
||mov|11,-(xs)|8,wa||; stack vrblk ptr (name base)| 8822
||mov|11,-(xs)|19,*vrval||; stack name offset| 8823
||lcw|7,xr|||; get next code word| 8824
||bri|9,(xr)|||; execute next code word| 8825
||ejc||||| 8826
;
;      binary asterisk (multiplication)
;
|o_mlt|ent||||; entry point| 8830
||jsr|6,arith|||; fetch arithmetic operands| 8831
||err|1,026|26,multiplication left operand is not numeric||| 8832
||err|1,027|26,multiplication right operand is not numeric||| 8833
||ppm|6,omlt1|||; jump if real operands| 8836
;
;      here to multiply two integers
;
||mli|13,icval(xl)|||; multiply left operand by right| 8841
||ino|6,exint|||; return integer if no overflow| 8842
||erb|1,028|26,multiplication caused integer overflow||| 8843
;
;      here to multiply two reals
;
|omlt1|mlr|13,rcval(xl)|||; multiply left operand by right| 8849
||rno|6,exrea|||; return real if no overflow| 8850
||erb|1,263|26,multiplication caused real overflow||| 8851
||ejc||||| 8853
;
;      name reference
;
|o_nam|ent||||; entry point| 8857
||mov|8,wa|19,*nmsi_||; set length of nmblk| 8858
||jsr|6,alloc|||; allocate nmblk| 8859
||mov|9,(xr)|22,=b_nml||; set name block code| 8860
||mov|13,nmofs(xr)|10,(xs)+||; set name offset from operand| 8861
||mov|13,nmbas(xr)|10,(xs)+||; set name base from operand| 8862
||mov|11,-(xs)|7,xr||; stack result| 8863
||lcw|7,xr|||; get next code word| 8864
||bri|9,(xr)|||; execute it| 8865
||ejc||||| 8866
;
;      negation
;
;      initial entry
;
|o_nta|ent||||; entry point| 8872
||lcw|8,wa|||; load new failure offset| 8873
||mov|11,-(xs)|3,flptr||; stack old failure pointer| 8874
||mov|11,-(xs)|8,wa||; stack new failure offset| 8875
||mov|3,flptr|7,xs||; set new failure pointer| 8876
||lcw|7,xr|||; get next code word| 8877
||bri|9,(xr)|||; execute next code word| 8878
;
;      entry after successful evaluation of operand
;
|o_ntb|ent||||; entry point| 8882
||mov|3,flptr|13,num02(xs)||; restore old failure pointer| 8883
||brn|6,exfal|||; and fail| 8884
;
;      entry for failure during operand evaluation
;
|o_ntc|ent||||; entry point| 8888
||ica|7,xs|||; pop failure offset| 8889
||mov|3,flptr|10,(xs)+||; restore old failure pointer| 8890
||brn|6,exnul|||; exit giving null result| 8891
||ejc||||| 8892
;
;      use of undefined operator
;
|o_oun|ent||||; entry point| 8896
||erb|1,029|26,undefined operator referenced||| 8897
||ejc||||| 8898
;
;      binary dot (pattern assignment)
;
;      the pattern built by binary dot is a compound pattern.
;      see description at start of pattern match section for
;      details of the structure which is constructed.
;
|o_pas|ent||||; entry point| 8906
||mov|8,wb|22,=p_pac||; load pcode for p_pac node| 8907
||mov|8,wc|10,(xs)+||; load name offset (parm2)| 8908
||mov|7,xr|10,(xs)+||; load name base (parm1)| 8909
||jsr|6,pbild|||; build p_pac node| 8910
||mov|7,xl|7,xr||; save ptr to node| 8911
||mov|7,xr|9,(xs)||; load left operand| 8912
||jsr|6,gtpat|||; convert to pattern| 8913
||err|1,030|26,pattern assignment left operand is not pattern||| 8914
||mov|9,(xs)|7,xr||; save ptr to left operand pattern| 8915
||mov|8,wb|22,=p_paa||; set pcode for p_paa node| 8916
||jsr|6,pbild|||; build p_paa node| 8917
||mov|13,pthen(xr)|10,(xs)+||; set left operand as p_paa successor| 8918
||jsr|6,pconc|||; concatenate to form final pattern| 8919
||mov|11,-(xs)|7,xr||; stack result| 8920
||lcw|7,xr|||; get next code word| 8921
||bri|9,(xr)|||; execute it| 8922
||ejc||||| 8923
;
;      pattern match (by name, for replacement)
;
|o_pmn|ent||||; entry point| 8927
||zer|8,wb|||; set type code for match by name| 8928
||brn|6,match|||; jump to routine to start match| 8929
||ejc||||| 8930
;
;      pattern match (statement)
;
;      o_pms is used in place of o_pmv when the pattern match
;      occurs at the outer (statement) level since in this
;      case the substring value need not be constructed.
;
|o_pms|ent||||; entry point| 8938
||mov|8,wb|18,=num02||; set flag for statement to match| 8939
||brn|6,match|||; jump to routine to start match| 8940
||ejc||||| 8941
;
;      pattern match (by value)
;
|o_pmv|ent||||; entry point| 8945
||mov|8,wb|18,=num01||; set type code for value match| 8946
||brn|6,match|||; jump to routine to start match| 8947
||ejc||||| 8948
;
;      pop top item on stack
;
|o_pop|ent||||; entry point| 8952
||ica|7,xs|||; pop top stack entry| 8953
||lcw|7,xr|||; get next code word| 8954
||bri|9,(xr)|||; execute next code word| 8955
||ejc||||| 8956
;
;      terminate execution (code compiled for end statement)
;
|o_stp|ent||||; entry point| 8960
||brn|6,lend0|||; jump to end circuit| 8961
||ejc||||| 8962
;
;      return name from expression
;      this entry points is used if the evaluation of an
;      expression, initiated by the evalx procedure, returns
;      a name. control is returned to the proper point in evalx.
;
|o_rnm|ent||||; entry point| 8969
||brn|6,evlx4|||; return to evalx procedure| 8970
||ejc||||| 8971
;
;      pattern replacement
;
;      when this routine gets control, the following stack
;      entries have been made (see end of match routine p_nth)
;
;			     subject name base
;			     subject name offset
;			     initial cursor value
;			     final cursor value
;			     subject string pointer
;      (xs) ---------------- replacement value
;
|o_rpl|ent||||; entry point| 8985
||jsr|6,gtstg|||; convert replacement val to string| 8986
||err|1,031|26,pattern replacement right operand is not a string||| 8987
;
;      get result length and allocate result scblk
;
||mov|7,xl|9,(xs)||; load subject string pointer| 8991
||add|8,wa|13,sclen(xl)||; add subject string length| 8996
||add|8,wa|13,num02(xs)||; add starting cursor| 8997
||sub|8,wa|13,num01(xs)||; minus final cursor = total length| 8998
||bze|8,wa|6,orpl3||; jump if result is null| 8999
||mov|11,-(xs)|7,xr||; restack replacement string| 9000
||jsr|6,alocs|||; allocate scblk for result| 9001
||mov|8,wa|13,num03(xs)||; get initial cursor (part 1 len)| 9002
||mov|13,num03(xs)|7,xr||; stack result pointer| 9003
||psc|7,xr|||; point to characters of result| 9004
;
;      move part 1 (start of subject) to result
;
||bze|8,wa|6,orpl1||; jump if first part is null| 9008
||mov|7,xl|13,num01(xs)||; else point to subject string| 9009
||plc|7,xl|||; point to subject string chars| 9010
||mvc||||; move first part to result| 9011
||ejc||||| 9012
;      pattern replacement (continued)
;
;      now move in replacement value
;
|orpl1|mov|7,xl|10,(xs)+||; load replacement string, pop| 9017
||mov|8,wa|13,sclen(xl)||; load length| 9018
||bze|8,wa|6,orpl2||; jump if null replacement| 9019
||plc|7,xl|||; else point to chars of replacement| 9020
||mvc||||; move in chars (part 2)| 9021
;
;      now move in remainder of string (part 3)
;
|orpl2|mov|7,xl|10,(xs)+||; load subject string pointer, pop| 9025
||mov|8,wc|10,(xs)+||; load final cursor, pop| 9026
||mov|8,wa|13,sclen(xl)||; load subject string length| 9027
||sub|8,wa|8,wc||; minus final cursor = part 3 length| 9028
||bze|8,wa|6,oass0||; jump to assign if part 3 is null| 9029
||plc|7,xl|8,wc||; else point to last part of string| 9030
||mvc||||; move part 3 to result| 9031
||brn|6,oass0|||; jump to perform assignment| 9032
;
;      here if result is null
;
|orpl3|add|7,xs|19,*num02||; pop subject str ptr, final cursor| 9036
||mov|9,(xs)|21,=nulls||; set null result| 9037
||brn|6,oass0|||; jump to assign null value| 9038
||ejc||||| 9057
;
;      return value from expression
;
;      this entry points is used if the evaluation of an
;      expression, initiated by the evalx procedure, returns
;      a value. control is returned to the proper point in evalx
;
|o_rvl|ent||||; entry point| 9065
||brn|6,evlx3|||; return to evalx procedure| 9066
||ejc||||| 9067
;
;      selection
;
;      initial entry
;
|o_sla|ent||||; entry point| 9073
||lcw|8,wa|||; load new failure offset| 9074
||mov|11,-(xs)|3,flptr||; stack old failure pointer| 9075
||mov|11,-(xs)|8,wa||; stack new failure offset| 9076
||mov|3,flptr|7,xs||; set new failure pointer| 9077
||lcw|7,xr|||; get next code word| 9078
||bri|9,(xr)|||; execute next code word| 9079
;
;      entry after successful evaluation of alternative
;
|o_slb|ent||||; entry point| 9083
||mov|7,xr|10,(xs)+||; load result| 9084
||ica|7,xs|||; pop fail offset| 9085
||mov|3,flptr|9,(xs)||; restore old failure pointer| 9086
||mov|9,(xs)|7,xr||; restack result| 9087
||lcw|8,wa|||; load new code offset| 9088
||add|8,wa|3,r_cod||; point to absolute code location| 9089
||lcp|8,wa|||; set new code pointer| 9090
||lcw|7,xr|||; get next code word| 9091
||bri|9,(xr)|||; execute next code word| 9092
;
;      entry at start of subsequent alternatives
;
|o_slc|ent||||; entry point| 9096
||lcw|8,wa|||; load new fail offset| 9097
||mov|9,(xs)|8,wa||; store new fail offset| 9098
||lcw|7,xr|||; get next code word| 9099
||bri|9,(xr)|||; execute next code word| 9100
;
;      entry at start of last alternative
;
|o_sld|ent||||; entry point| 9104
||ica|7,xs|||; pop failure offset| 9105
||mov|3,flptr|10,(xs)+||; restore old failure pointer| 9106
||lcw|7,xr|||; get next code word| 9107
||bri|9,(xr)|||; execute next code word| 9108
||ejc||||| 9109
;
;      binary minus (subtraction)
;
|o_sub|ent||||; entry point| 9113
||jsr|6,arith|||; fetch arithmetic operands| 9114
||err|1,032|26,subtraction left operand is not numeric||| 9115
||err|1,033|26,subtraction right operand is not numeric||| 9116
||ppm|6,osub1|||; jump if real operands| 9119
;
;      here to subtract two integers
;
||sbi|13,icval(xl)|||; subtract right operand from left| 9124
||ino|6,exint|||; return integer if no overflow| 9125
||erb|1,034|26,subtraction caused integer overflow||| 9126
;
;      here to subtract two reals
;
|osub1|sbr|13,rcval(xl)|||; subtract right operand from left| 9132
||rno|6,exrea|||; return real if no overflow| 9133
||erb|1,264|26,subtraction caused real overflow||| 9134
||ejc||||| 9136
;
;      dummy operator to return control to trxeq procedure
;
|o_txr|ent||||; entry point| 9140
||brn|6,trxq1|||; jump into trxeq procedure| 9141
||ejc||||| 9142
;
;      unexpected failure
;
;      note that if a setexit trap is operating then
;      transfer to system label continue
;      will result in looping here.  difficult to avoid except
;      with a considerable overhead which is not worthwhile or
;      else by a technique such as setting kverl to zero.
;
|o_unf|ent||||; entry point| 9152
||erb|1,035|26,unexpected failure in -nofail mode||| 9153
||ttl|27,s p i t b o l -- block action routines|||| 9154
;
;      the first word of every block in dynamic storage and the
;      vrget, vrsto and vrtra fields of a vrblk contain a
;      pointer to an entry point in the program. all such entry
;      points are in the following section except those for
;      pattern blocks which are in the pattern matching segment
;      later on (labels of the form p_xxx), and dope vectors
;      (d_xxx) which are in the dope vector section following
;      the pattern routines (dope vectors are used for cmblks).
;
;      the entry points in this section have labels of the
;      form b_xxy where xx is the two character block type for
;      the corresponding block and y is any letter.
;
;      in some cases, the pointers serve no other purpose than
;      to identify the block type. in this case the routine
;      is never executed and thus no code is assembled.
;
;      for each of these entry points corresponding to a block
;      an entry point identification is assembled (bl_xx).
;
;      the exact entry conditions depend on the manner in
;      which the routine is accessed and are documented with
;      the individual routines as required.
;
;      the order of these routines is alphabetical with the
;      following exceptions.
;
;      the routines for seblk and exblk entries occur first so
;      that expressions can be quickly identified from the fact
;      that their routines lie before the symbol b_e__.
;
;      these are immediately followed by the routine for a trblk
;      so that the test against the symbol b_t__ checks for
;      trapped values or expression values (see procedure evalp)
;
;      the pattern routines lie after this section so that
;      patterns are identified with routines starting at or
;      after the initial instruction in these routines (p_aaa).
;
;      the symbol b_aaa defines the first location for block
;      routines and the symbol p_yyy (at the end of the pattern
;      match routines section) defines the last such entry point
;
|b_aaa|ent|2,bl__i|||; entry point of first block routine| 9199
||ejc||||| 9200
;
;      exblk
;
;      the routine for an exblk loads the expression onto
;      the stack as a value.
;
;      (xr)		     pointer to exblk
;
|b_exl|ent|2,bl_ex|||; entry point (exblk)| 9209
||mov|11,-(xs)|7,xr||; stack result| 9210
||lcw|7,xr|||; get next code word| 9211
||bri|9,(xr)|||; execute it| 9212
||ejc||||| 9213
;
;      seblk
;
;      the routine for seblk is accessed from the generated
;      code to load the expression value onto the stack.
;
|b_sel|ent|2,bl_se|||; entry point (seblk)| 9220
||mov|11,-(xs)|7,xr||; stack result| 9221
||lcw|7,xr|||; get next code word| 9222
||bri|9,(xr)|||; execute it| 9223
;
;      define symbol which marks end of entries for expressions
;
|b_e__|ent|2,bl__i|||; entry point| 9227
||ejc||||| 9228
;
;      trblk
;
;      the routine for a trblk is never executed
;
|b_trt|ent|2,bl_tr|||; entry point (trblk)| 9234
;
;      define symbol marking end of trap and expression blocks
;
|b_t__|ent|2,bl__i|||; end of trblk,seblk,exblk entries| 9238
||ejc||||| 9239
;
;      arblk
;
;      the routine for arblk is never executed
;
|b_art|ent|2,bl_ar|||; entry point (arblk)| 9245
||ejc||||| 9246
;
;      bcblk
;
;      the routine for a bcblk is never executed
;
;      (xr)		     pointer to bcblk
;
|b_bct|ent|2,bl_bc|||; entry point (bcblk)| 9254
||ejc||||| 9255
;
;      bfblk
;
;      the routine for a bfblk is never executed
;
;      (xr)		     pointer to bfblk
;
|b_bft|ent|2,bl_bf|||; entry point (bfblk)| 9263
||ejc||||| 9264
;
;      ccblk
;
;      the routine for ccblk is never entered
;
|b_cct|ent|2,bl_cc|||; entry point (ccblk)| 9270
||ejc||||| 9271
;
;      cdblk
;
;      the cdblk routines are executed from the generated code.
;      there are two cases depending on the form of cdfal.
;
;      entry for complex failure code at cdfal
;
;      (xr)		     pointer to cdblk
;
|b_cdc|ent|2,bl_cd|||; entry point (cdblk)| 9282
|bcdc0|mov|7,xs|3,flptr||; pop garbage off stack| 9283
||mov|9,(xs)|13,cdfal(xr)||; set failure offset| 9284
||brn|6,stmgo|||; enter stmt| 9285
||ejc||||| 9286
;
;      cdblk (continued)
;
;      entry for simple failure code at cdfal
;
;      (xr)		     pointer to cdblk
;
|b_cds|ent|2,bl_cd|||; entry point (cdblk)| 9294
|bcds0|mov|7,xs|3,flptr||; pop garbage off stack| 9295
||mov|9,(xs)|19,*cdfal||; set failure offset| 9296
||brn|6,stmgo|||; enter stmt| 9297
||ejc||||| 9298
;
;      cmblk
;
;      the routine for a cmblk is never executed
;
|b_cmt|ent|2,bl_cm|||; entry point (cmblk)| 9304
||ejc||||| 9305
;
;      ctblk
;
;      the routine for a ctblk is never executed
;
|b_ctt|ent|2,bl_ct|||; entry point (ctblk)| 9311
||ejc||||| 9312
;
;      dfblk
;
;      the routine for a dfblk is accessed from the o_fnc entry
;      to call a datatype function and build a pdblk.
;
;      (xl)		     pointer to dfblk
;
|b_dfc|ent|2,bl_df|||; entry point| 9321
||mov|8,wa|13,dfpdl(xl)||; load length of pdblk| 9322
||jsr|6,alloc|||; allocate pdblk| 9323
||mov|9,(xr)|22,=b_pdt||; store type word| 9324
||mov|13,pddfp(xr)|7,xl||; store dfblk pointer| 9325
||mov|8,wc|7,xr||; save pointer to pdblk| 9326
||add|7,xr|8,wa||; point past pdblk| 9327
||lct|8,wa|13,fargs(xl)||; set to count fields| 9328
;
;      loop to acquire field values from stack
;
|bdfc1|mov|11,-(xr)|10,(xs)+||; move a field value| 9332
||bct|8,wa|6,bdfc1||; loop till all moved| 9333
||mov|7,xr|8,wc||; recall pointer to pdblk| 9334
||brn|6,exsid|||; exit setting id field| 9335
||ejc||||| 9336
;
;      efblk
;
;      the routine for an efblk is passed control form the o_fnc
;      entry to call an external function.
;
;      (xl)		     pointer to efblk
;
|b_efc|ent|2,bl_ef|||; entry point (efblk)| 9345
||mov|8,wc|13,fargs(xl)||; load number of arguments| 9348
||wtb|8,wc|||; convert to offset| 9349
||mov|11,-(xs)|7,xl||; save pointer to efblk| 9350
||mov|7,xt|7,xs||; copy pointer to arguments| 9351
;
;      loop to convert arguments
;
|befc1|ica|7,xt|||; point to next entry| 9355
||mov|7,xr|9,(xs)||; load pointer to efblk| 9356
||dca|8,wc|||; decrement eftar offset| 9357
||add|7,xr|8,wc||; point to next eftar entry| 9358
||mov|7,xr|13,eftar(xr)||; load eftar entry| 9359
||bsw|7,xr|1,5||; switch on type| 9368
||iff|1,0|6,befc7||; no conversion needed| 9386
||iff|1,1|6,befc2||; string| 9386
||iff|1,2|6,befc3||; integer| 9386
||iff|1,3|6,befc4||; real| 9386
||iff|1,4|6,beff1||; file| 9386
||esw||||; end of switch on type| 9386
;
;      here to convert to file
;
|beff1|mov|11,-(xs)|7,xt||; save entry pointer| 9391
||mov|3,befof|8,wc||; save offset| 9392
||mov|11,-(xs)|9,(xt)||; stack arg pointer| 9393
||jsr|6,iofcb|||; convert to fcb| 9394
||err|1,298|26,external function argument is not file||| 9395
||err|1,298|26,external function argument is not file||| 9396
||err|1,298|26,external function argument is not file||| 9397
||mov|7,xr|8,wa||; point to fcb| 9398
||mov|7,xt|10,(xs)+||; reload entry pointer| 9399
||brn|6,befc5|||; jump to merge| 9400
;
;      here to convert to string
;
|befc2|mov|11,-(xs)|9,(xt)||; stack arg ptr| 9405
||jsr|6,gtstg|||; convert argument to string| 9406
||err|1,039|26,external function argument is not a string||| 9407
||brn|6,befc6|||; jump to merge| 9408
||ejc||||| 9409
;
;      efblk (continued)
;
;      here to convert an integer
;
|befc3|mov|7,xr|9,(xt)||; load next argument| 9415
||mov|3,befof|8,wc||; save offset| 9416
||jsr|6,gtint|||; convert to integer| 9417
||err|1,040|26,external function argument is not integer||| 9418
||brn|6,befc5|||; merge with real case| 9421
;
;      here to convert a real
;
|befc4|mov|7,xr|9,(xt)||; load next argument| 9425
||mov|3,befof|8,wc||; save offset| 9426
||jsr|6,gtrea|||; convert to real| 9427
||err|1,265|26,external function argument is not real||| 9428
;
;      integer case merges here
;
|befc5|mov|8,wc|3,befof||; restore offset| 9433
;
;      string merges here
;
|befc6|mov|9,(xt)|7,xr||; store converted result| 9437
;
;      no conversion merges here
;
|befc7|bnz|8,wc|6,befc1||; loop back if more to go| 9441
;
;      here after converting all the arguments
;
||mov|7,xl|10,(xs)+||; restore efblk pointer| 9445
||mov|8,wa|13,fargs(xl)||; get number of args| 9446
||jsr|6,sysex|||; call routine to call external fnc| 9447
||ppm|6,exfal|||; fail if failure| 9448
||err|1,327|26,calling external function - not found||| 9449
||err|1,326|26,calling external function - bad argument type||| 9450
||wtb|8,wa|||; convert number of args to bytes| 9452
||add|7,xs|8,wa||; remove arguments from stack| 9453
||ejc||||| 9455
;
;      efblk (continued)
;
;      return here with result in xr
;
;      first defend against non-standard null string returned
;
||mov|8,wb|13,efrsl(xl)||; get result type id| 9463
||bnz|8,wb|6,befa8||; branch if not unconverted| 9464
||bne|9,(xr)|22,=b_scl|6,befc8|; jump if not a string| 9465
||bze|13,sclen(xr)|6,exnul||; return null if null| 9466
;
;      here if converted result to check for null string
;
|befa8|bne|8,wb|18,=num01|6,befc8|; jump if not a string| 9470
||bze|13,sclen(xr)|6,exnul||; return null if null| 9471
;
;      return if result is in dynamic storage
;
|befc8|blt|7,xr|3,dnamb|6,befc9|; jump if not in dynamic storage| 9475
||ble|7,xr|3,dnamp|6,exixr|; return result if already dynamic| 9476
;
;      here we copy a result into the dynamic region
;
|befc9|mov|8,wa|9,(xr)||; get possible type word| 9480
||bze|8,wb|6,bef11||; jump if unconverted result| 9481
||mov|8,wa|22,=b_scl||; string| 9482
||beq|8,wb|18,=num01|6,bef10|; yes jump| 9483
||mov|8,wa|22,=b_icl||; integer| 9484
||beq|8,wb|18,=num02|6,bef10|; yes jump| 9485
||mov|8,wa|22,=b_rcl||; real| 9488
;
;      store type word in result
;
|bef10|mov|9,(xr)|8,wa||; stored before copying to dynamic| 9493
;
;      merge for unconverted result
;
|bef11|beq|9,(xr)|22,=b_scl|6,bef12|; branch if string result| 9497
||jsr|6,blkln|||; get length of block| 9498
||mov|7,xl|7,xr||; copy address of old block| 9499
||jsr|6,alloc|||; allocate dynamic block same size| 9500
||mov|11,-(xs)|7,xr||; set pointer to new block as result| 9501
||mvw||||; copy old block to dynamic block| 9502
||zer|7,xl|||; clear garbage value| 9503
||lcw|7,xr|||; get next code word| 9504
||bri|9,(xr)|||; execute next code word| 9505
;
;      here to return a string result that was not in dynamic.
;      cannot use the simple word copy above because it will not
;      guarantee zero padding in the last word.
;
|bef12|mov|7,xl|7,xr||; save source string pointer| 9511
||mov|8,wa|13,sclen(xr)||; fetch string length| 9512
||bze|8,wa|6,exnul||; return null string if length zero| 9513
||jsr|6,alocs|||; allocate space for string| 9514
||mov|11,-(xs)|7,xr||; save as result pointer| 9515
||psc|7,xr|||; prepare to store chars of result| 9516
||plc|7,xl|||; point to chars in source string| 9517
||mov|8,wa|8,wc||; number of characters to copy| 9518
||mvc||||; move characters to result string| 9519
||zer|7,xl|||; clear garbage value| 9520
||lcw|7,xr|||; get next code word| 9521
||bri|9,(xr)|||; execute next code word| 9522
||ejc||||| 9524
;
;      evblk
;
;      the routine for an evblk is never executed
;
|b_evt|ent|2,bl_ev|||; entry point (evblk)| 9530
||ejc||||| 9531
;
;      ffblk
;
;      the routine for an ffblk is executed from the o_fnc entry
;      to call a field function and extract a field value/name.
;
;      (xl)		     pointer to ffblk
;
|b_ffc|ent|2,bl_ff|||; entry point (ffblk)| 9540
||mov|7,xr|7,xl||; copy ffblk pointer| 9541
||lcw|8,wc|||; load next code word| 9542
||mov|7,xl|9,(xs)||; load pdblk pointer| 9543
||bne|9,(xl)|22,=b_pdt|6,bffc2|; jump if not pdblk at all| 9544
||mov|8,wa|13,pddfp(xl)||; load dfblk pointer from pdblk| 9545
;
;      loop to find correct ffblk for this pdblk
;
|bffc1|beq|8,wa|13,ffdfp(xr)|6,bffc3|; jump if this is the correct ffblk| 9549
||mov|7,xr|13,ffnxt(xr)||; else link to next ffblk on chain| 9550
||bnz|7,xr|6,bffc1||; loop back if another entry to check| 9551
;
;      here for bad argument
;
|bffc2|erb|1,041|26,field function argument is wrong datatype||| 9555
||ejc||||| 9556
;
;      ffblk (continued)
;
;      here after locating correct ffblk
;
|bffc3|mov|8,wa|13,ffofs(xr)||; load field offset| 9562
||beq|8,wc|21,=ofne_|6,bffc5|; jump if called by name| 9563
||add|7,xl|8,wa||; else point to value field| 9564
||mov|7,xr|9,(xl)||; load value| 9565
||bne|9,(xr)|22,=b_trt|6,bffc4|; jump if not trapped| 9566
||sub|7,xl|8,wa||; else restore name base,offset| 9567
||mov|9,(xs)|8,wc||; save next code word over pdblk ptr| 9568
||jsr|6,acess|||; access value| 9569
||ppm|6,exfal|||; fail if access fails| 9570
||mov|8,wc|9,(xs)||; restore next code word| 9571
;
;      here after getting value in (xr), xl is garbage
;
|bffc4|mov|9,(xs)|7,xr||; store value on stack (over pdblk)| 9575
||mov|7,xr|8,wc||; copy next code word| 9576
||mov|7,xl|9,(xr)||; load entry address| 9577
||bri|7,xl|||; jump to routine for next code word| 9578
;
;      here if called by name
;
|bffc5|mov|11,-(xs)|8,wa||; store name offset (base is set)| 9582
||lcw|7,xr|||; get next code word| 9583
||bri|9,(xr)|||; execute next code word| 9584
||ejc||||| 9585
;
;      icblk
;
;      the routine for icblk is executed from the generated
;      code to load an integer value onto the stack.
;
;      (xr)		     pointer to icblk
;
|b_icl|ent|2,bl_ic|||; entry point (icblk)| 9594
||mov|11,-(xs)|7,xr||; stack result| 9595
||lcw|7,xr|||; get next code word| 9596
||bri|9,(xr)|||; execute it| 9597
||ejc||||| 9598
;
;      kvblk
;
;      the routine for a kvblk is never executed.
;
|b_kvt|ent|2,bl_kv|||; entry point (kvblk)| 9604
||ejc||||| 9605
;
;      nmblk
;
;      the routine for a nmblk is executed from the generated
;      code for the case of loading a name onto the stack
;      where the name is that of a natural variable which can
;      be preevaluated at compile time.
;
;      (xr)		     pointer to nmblk
;
|b_nml|ent|2,bl_nm|||; entry point (nmblk)| 9616
||mov|11,-(xs)|7,xr||; stack result| 9617
||lcw|7,xr|||; get next code word| 9618
||bri|9,(xr)|||; execute it| 9619
||ejc||||| 9620
;
;      pdblk
;
;      the routine for a pdblk is never executed
;
|b_pdt|ent|2,bl_pd|||; entry point (pdblk)| 9626
||ejc||||| 9627
;
;      pfblk
;
;      the routine for a pfblk is executed from the entry o_fnc
;      to call a program defined function.
;
;      (xl)		     pointer to pfblk
;
;      the following stack entries are made before passing
;      control to the program defined function.
;
;			     saved value of first argument
;			     .
;			     saved value of last argument
;			     saved value of first local
;			     .
;			     saved value of last local
;			     saved value of function name
;			     saved code block ptr (r_cod)
;			     saved code pointer (-r_cod)
;			     saved value of flprt
;			     saved value of flptr
;			     pointer to pfblk
;      flptr --------------- zero (to be overwritten with offs)
;
|b_pfc|ent|2,bl_pf|||; entry point (pfblk)| 9653
||mov|3,bpfpf|7,xl||; save pfblk ptr (need not be reloc)| 9654
||mov|7,xr|7,xl||; copy for the moment| 9655
||mov|7,xl|13,pfvbl(xr)||; point to vrblk for function| 9656
;
;      loop to find old value of function
;
|bpf01|mov|8,wb|7,xl||; save pointer| 9660
||mov|7,xl|13,vrval(xl)||; load value| 9661
||beq|9,(xl)|22,=b_trt|6,bpf01|; loop if trblk| 9662
;
;      set value to null and save old function value
;
||mov|3,bpfsv|7,xl||; save old value| 9666
||mov|7,xl|8,wb||; point back to block with value| 9667
||mov|13,vrval(xl)|21,=nulls||; set value to null| 9668
||mov|8,wa|13,fargs(xr)||; load number of arguments| 9669
||add|7,xr|19,*pfarg||; point to pfarg entries| 9670
||bze|8,wa|6,bpf04||; jump if no arguments| 9671
||mov|7,xt|7,xs||; ptr to last arg| 9672
||wtb|8,wa|||; convert no. of args to bytes offset| 9673
||add|7,xt|8,wa||; point before first arg| 9674
||mov|3,bpfxt|7,xt||; remember arg pointer| 9675
||ejc||||| 9676
;
;      pfblk (continued)
;
;      loop to save old argument values and set new ones
;
|bpf02|mov|7,xl|10,(xr)+||; load vrblk ptr for next argument| 9682
;
;      loop through possible trblk chain to find value
;
|bpf03|mov|8,wc|7,xl||; save pointer| 9686
||mov|7,xl|13,vrval(xl)||; load next value| 9687
||beq|9,(xl)|22,=b_trt|6,bpf03|; loop back if trblk| 9688
;
;      save old value and get new value
;
||mov|8,wa|7,xl||; keep old value| 9692
||mov|7,xt|3,bpfxt||; point before next stacked arg| 9693
||mov|8,wb|11,-(xt)||; load argument (new value)| 9694
||mov|9,(xt)|8,wa||; save old value| 9695
||mov|3,bpfxt|7,xt||; keep arg ptr for next time| 9696
||mov|7,xl|8,wc||; point back to block with value| 9697
||mov|13,vrval(xl)|8,wb||; set new value| 9698
||bne|7,xs|3,bpfxt|6,bpf02|; loop if not all done| 9699
;
;      now process locals
;
|bpf04|mov|7,xl|3,bpfpf||; restore pfblk pointer| 9703
||mov|8,wa|13,pfnlo(xl)||; load number of locals| 9704
||bze|8,wa|6,bpf07||; jump if no locals| 9705
||mov|8,wb|21,=nulls||; get null constant| 9706
||lct|8,wa|8,wa||; set local counter| 9707
;
;      loop to process locals
;
|bpf05|mov|7,xl|10,(xr)+||; load vrblk ptr for next local| 9711
;
;      loop through possible trblk chain to find value
;
|bpf06|mov|8,wc|7,xl||; save pointer| 9715
||mov|7,xl|13,vrval(xl)||; load next value| 9716
||beq|9,(xl)|22,=b_trt|6,bpf06|; loop back if trblk| 9717
;
;      save old value and set null as new value
;
||mov|11,-(xs)|7,xl||; stack old value| 9721
||mov|7,xl|8,wc||; point back to block with value| 9722
||mov|13,vrval(xl)|8,wb||; set null as new value| 9723
||bct|8,wa|6,bpf05||; loop till all locals processed| 9724
||ejc||||| 9725
;
;      pfblk (continued)
;
;      here after processing arguments and locals
;
|bpf07|zer|7,xr|||; zero reg xr in case| 9734
||bze|3,kvpfl|6,bpf7c||; skip if profiling is off| 9735
||beq|3,kvpfl|18,=num02|6,bpf7a|; branch on type of profile| 9736
;
;      here if &profile = 1
;
||jsr|6,systm|||; get current time| 9740
||sti|3,pfetm|||; save for a sec| 9741
||sbi|3,pfstm|||; find time used by caller| 9742
||jsr|6,icbld|||; build into an icblk| 9743
||ldi|3,pfetm|||; reload current time| 9744
||brn|6,bpf7b|||; merge| 9745
;
;	here if &profile = 2
;
|bpf7a|ldi|3,pfstm|||; get start time of calling stmt| 9749
||jsr|6,icbld|||; assemble an icblk round it| 9750
||jsr|6,systm|||; get now time| 9751
;
;      both types of profile merge here
;
|bpf7b|sti|3,pfstm|||; set start time of 1st func stmt| 9755
||mnz|3,pffnc|||; flag function entry| 9756
;
;      no profiling merges here
;
|bpf7c|mov|11,-(xs)|7,xr||; stack icblk ptr (or zero)| 9760
||mov|8,wa|3,r_cod||; load old code block pointer| 9761
||scp|8,wb|||; get code pointer| 9763
||sub|8,wb|8,wa||; make code pointer into offset| 9764
||mov|7,xl|3,bpfpf||; recall pfblk pointer| 9765
||mov|11,-(xs)|3,bpfsv||; stack old value of function name| 9766
||mov|11,-(xs)|8,wa||; stack code block pointer| 9767
||mov|11,-(xs)|8,wb||; stack code offset| 9768
||mov|11,-(xs)|3,flprt||; stack old flprt| 9769
||mov|11,-(xs)|3,flptr||; stack old failure pointer| 9770
||mov|11,-(xs)|7,xl||; stack pointer to pfblk| 9771
||zer|11,-(xs)|||; dummy zero entry for fail return| 9772
||chk||||; check for stack overflow| 9773
||mov|3,flptr|7,xs||; set new fail return value| 9774
||mov|3,flprt|7,xs||; set new flprt| 9775
||mov|8,wa|3,kvtra||; load trace value| 9776
||add|8,wa|3,kvftr||; add ftrace value| 9777
||bnz|8,wa|6,bpf09||; jump if tracing possible| 9778
||icv|3,kvfnc|||; else bump fnclevel| 9779
;
;      here to actually jump to function
;
|bpf08|mov|7,xr|13,pfcod(xl)||; point to vrblk of entry label| 9783
||mov|7,xr|13,vrlbl(xr)||; point to target code| 9784
||beq|7,xr|21,=stndl|6,bpf17|; test for undefined label| 9785
||bne|9,(xr)|22,=b_trt|6,bpf8a|; jump if not trapped| 9786
||mov|7,xr|13,trlbl(xr)||; else load ptr to real label code| 9787
|bpf8a|bri|9,(xr)|||; off to execute function| 9788
;
;      here if tracing is possible
;
|bpf09|mov|7,xr|13,pfctr(xl)||; load possible call trace trblk| 9792
||mov|7,xl|13,pfvbl(xl)||; load vrblk pointer for function| 9793
||mov|8,wa|19,*vrval||; set name offset for variable| 9794
||bze|3,kvtra|6,bpf10||; jump if trace mode is off| 9795
||bze|7,xr|6,bpf10||; or if there is no call trace| 9796
;
;      here if call traced
;
||dcv|3,kvtra|||; decrement trace count| 9800
||bze|13,trfnc(xr)|6,bpf11||; jump if print trace| 9801
||jsr|6,trxeq|||; execute function type trace| 9802
||ejc||||| 9803
;
;      pfblk (continued)
;
;      here to test for ftrace trace
;
|bpf10|bze|3,kvftr|6,bpf16||; jump if ftrace is off| 9809
||dcv|3,kvftr|||; else decrement ftrace| 9810
;
;      here for print trace
;
|bpf11|jsr|6,prtsn|||; print statement number| 9814
||jsr|6,prtnm|||; print function name| 9815
||mov|8,wa|18,=ch_pp||; load left paren| 9816
||jsr|6,prtch|||; print left paren| 9817
||mov|7,xl|13,num01(xs)||; recover pfblk pointer| 9818
||bze|13,fargs(xl)|6,bpf15||; skip if no arguments| 9819
||zer|8,wb|||; else set argument counter| 9820
||brn|6,bpf13|||; jump into loop| 9821
;
;      loop to print argument values
;
|bpf12|mov|8,wa|18,=ch_cm||; load comma| 9825
||jsr|6,prtch|||; print to separate from last arg| 9826
;
;      merge here first time (no comma required)
;
|bpf13|mov|9,(xs)|8,wb||; save arg ctr (over failoffs is ok)| 9830
||wtb|8,wb|||; convert to byte offset| 9831
||add|7,xl|8,wb||; point to next argument pointer| 9832
||mov|7,xr|13,pfarg(xl)||; load next argument vrblk ptr| 9833
||sub|7,xl|8,wb||; restore pfblk pointer| 9834
||mov|7,xr|13,vrval(xr)||; load next value| 9835
||jsr|6,prtvl|||; print argument value| 9836
||ejc||||| 9837
;
;      here after dealing with one argument
;
||mov|8,wb|9,(xs)||; restore argument counter| 9841
||icv|8,wb|||; increment argument counter| 9842
||blt|8,wb|13,fargs(xl)|6,bpf12|; loop if more to print| 9843
;
;      merge here in no args case to print paren
;
|bpf15|mov|8,wa|18,=ch_rp||; load right paren| 9847
||jsr|6,prtch|||; print to terminate output| 9848
||jsr|6,prtnl|||; terminate print line| 9849
;
;      merge here to exit with test for fnclevel trace
;
|bpf16|icv|3,kvfnc|||; increment fnclevel| 9853
||mov|7,xl|3,r_fnc||; load ptr to possible trblk| 9854
||jsr|6,ktrex|||; call keyword trace routine| 9855
;
;      call function after trace tests complete
;
||mov|7,xl|13,num01(xs)||; restore pfblk pointer| 9859
||brn|6,bpf08|||; jump back to execute function| 9860
;
;      here if calling a function whose entry label is undefined
;
|bpf17|mov|3,flptr|13,num02(xs)||; reset so exfal can return to evalx| 9864
||erb|1,286|26,function call to undefined entry label||| 9865
||ejc||||| 9868
;
;      rcblk
;
;      the routine for an rcblk is executed from the generated
;      code to load a real value onto the stack.
;
;      (xr)		     pointer to rcblk
;
|b_rcl|ent|2,bl_rc|||; entry point (rcblk)| 9877
||mov|11,-(xs)|7,xr||; stack result| 9878
||lcw|7,xr|||; get next code word| 9879
||bri|9,(xr)|||; execute it| 9880
||ejc||||| 9882
;
;      scblk
;
;      the routine for an scblk is executed from the generated
;      code to load a string value onto the stack.
;
;      (xr)		     pointer to scblk
;
|b_scl|ent|2,bl_sc|||; entry point (scblk)| 9891
||mov|11,-(xs)|7,xr||; stack result| 9892
||lcw|7,xr|||; get next code word| 9893
||bri|9,(xr)|||; execute it| 9894
||ejc||||| 9895
;
;      tbblk
;
;      the routine for a tbblk is never executed
;
|b_tbt|ent|2,bl_tb|||; entry point (tbblk)| 9901
||ejc||||| 9902
;
;      teblk
;
;      the routine for a teblk is never executed
;
|b_tet|ent|2,bl_te|||; entry point (teblk)| 9908
||ejc||||| 9909
;
;      vcblk
;
;      the routine for a vcblk is never executed
;
|b_vct|ent|2,bl_vc|||; entry point (vcblk)| 9915
||ejc||||| 9916
;
;      vrblk
;
;      the vrblk routines are executed from the generated code.
;      there are six entries for vrblk covering various cases
;
|b_vr_|ent|2,bl__i|||; mark start of vrblk entry points| 9923
;
;      entry for vrget (trapped case). this routine is called
;      from the generated code to load the value of a variable.
;      this entry point is used if an access trace or input
;      association is currently active.
;
;      (xr)		     pointer to vrget field of vrblk
;
|b_vra|ent|2,bl__i|||; entry point| 9932
||mov|7,xl|7,xr||; copy name base (vrget = 0)| 9933
||mov|8,wa|19,*vrval||; set name offset| 9934
||jsr|6,acess|||; access value| 9935
||ppm|6,exfal|||; fail if access fails| 9936
||mov|11,-(xs)|7,xr||; stack result| 9937
||lcw|7,xr|||; get next code word| 9938
||bri|9,(xr)|||; execute it| 9939
||ejc||||| 9940
;
;      vrblk (continued)
;
;      entry for vrsto (error case. this routine is called from
;      the executed code for an attempt to modify the value
;      of a protected (pattern valued) natural variable.
;
|b_vre|ent||||; entry point| 9948
||erb|1,042|26,attempt to change value of protected variable||| 9949
||ejc||||| 9950
;
;      vrblk (continued)
;
;      entry for vrtra (untrapped case). this routine is called
;      from the executed code to transfer to a label.
;
;      (xr)		     pointer to vrtra field of vrblk
;
|b_vrg|ent||||; entry point| 9959
||mov|7,xr|13,vrlbo(xr)||; load code pointer| 9960
||mov|7,xl|9,(xr)||; load entry address| 9961
||bri|7,xl|||; jump to routine for next code word| 9962
||ejc||||| 9963
;
;      vrblk (continued)
;
;      entry for vrget (untrapped case). this routine is called
;      from the generated code to load the value of a variable.
;
;      (xr)		     points to vrget field of vrblk
;
|b_vrl|ent||||; entry point| 9972
||mov|11,-(xs)|13,vrval(xr)||; load value onto stack (vrget = 0)| 9973
||lcw|7,xr|||; get next code word| 9974
||bri|9,(xr)|||; execute next code word| 9975
||ejc||||| 9976
;
;      vrblk (continued)
;
;      entry for vrsto (untrapped case). this routine is called
;      from the generated code to store the value of a variable.
;
;      (xr)		     pointer to vrsto field of vrblk
;
|b_vrs|ent||||; entry point| 9985
||mov|13,vrvlo(xr)|9,(xs)||; store value, leave on stack| 9986
||lcw|7,xr|||; get next code word| 9987
||bri|9,(xr)|||; execute next code word| 9988
||ejc||||| 9989
;
;      vrblk (continued)
;
;      vrtra (trapped case). this routine is called from the
;      generated code to transfer to a label when a label
;      trace is currently active.
;
|b_vrt|ent||||; entry point| 9997
||sub|7,xr|19,*vrtra||; point back to start of vrblk| 9998
||mov|7,xl|7,xr||; copy vrblk pointer| 9999
||mov|8,wa|19,*vrval||; set name offset|10000
||mov|7,xr|13,vrlbl(xl)||; load pointer to trblk|10001
||bze|3,kvtra|6,bvrt2||; jump if trace is off|10002
||dcv|3,kvtra|||; else decrement trace count|10003
||bze|13,trfnc(xr)|6,bvrt1||; jump if print trace case|10004
||jsr|6,trxeq|||; else execute full trace|10005
||brn|6,bvrt2|||; merge to jump to label|10006
;
;      here for print trace -- print colon ( label name )
;
|bvrt1|jsr|6,prtsn|||; print statement number|10010
||mov|7,xr|7,xl||; copy vrblk pointer|10011
||mov|8,wa|18,=ch_cl||; colon|10012
||jsr|6,prtch|||; print it|10013
||mov|8,wa|18,=ch_pp||; left paren|10014
||jsr|6,prtch|||; print it|10015
||jsr|6,prtvn|||; print label name|10016
||mov|8,wa|18,=ch_rp||; right paren|10017
||jsr|6,prtch|||; print it|10018
||jsr|6,prtnl|||; terminate line|10019
||mov|7,xr|13,vrlbl(xl)||; point back to trblk|10020
;
;      merge here to jump to label
;
|bvrt2|mov|7,xr|13,trlbl(xr)||; load pointer to actual code|10024
||bri|9,(xr)|||; execute statement at label|10025
||ejc|||||10026
;
;      vrblk (continued)
;
;      entry for vrsto (trapped case). this routine is called
;      from the generated code to store the value of a variable.
;      this entry is used when a value trace or output
;      association is currently active.
;
;      (xr)		     pointer to vrsto field of vrblk
;
|b_vrv|ent||||; entry point|10037
||mov|8,wb|9,(xs)||; load value (leave copy on stack)|10038
||sub|7,xr|19,*vrsto||; point to vrblk|10039
||mov|7,xl|7,xr||; copy vrblk pointer|10040
||mov|8,wa|19,*vrval||; set offset|10041
||jsr|6,asign|||; call assignment routine|10042
||ppm|6,exfal|||; fail if assignment fails|10043
||lcw|7,xr|||; else get next code word|10044
||bri|9,(xr)|||; execute next code word|10045
||ejc|||||10046
;
;      xnblk
;
;      the routine for an xnblk is never executed
;
|b_xnt|ent|2,bl_xn|||; entry point (xnblk)|10052
||ejc|||||10053
;
;      xrblk
;
;      the routine for an xrblk is never executed
;
|b_xrt|ent|2,bl_xr|||; entry point (xrblk)|10059
;
;      mark entry address past last block action routine
;
|b_yyy|ent|2,bl__i|||; last block routine entry point|10063
||ttl|27,s p i t b o l -- pattern matching routines||||10064
;
;      the following section consists of the pattern matching
;      routines. all pattern nodes contain a pointer (pcode)
;      to one of the routines in this section (p_xxx).
;
;      note that this section follows the b_xxx routines to
;      enable a fast test for the pattern datatype.
;
|p_aaa|ent|2,bl__i|||; entry to mark first pattern|10073
;
;
;      the entry conditions to the match routine are as follows
;      (see o_pmn, o_pmv, o_pms and procedure match).
;
;      stack contents.
;
;			     name base (o_pmn only)
;			     name offset (o_pmn only)
;			     type (0-o_pmn, 1-o_pmv, 2-o_pms)
;      pmhbs --------------- initial cursor (zero)
;			     initial node pointer
;      xs ------------------ =ndabo (anchored), =nduna (unanch)
;
;      register values.
;
;	    (xs)	     set as shown in stack diagram
;	    (xr)	     pointer to initial pattern node
;	    (wb)	     initial cursor (zero)
;
;      global pattern values
;
;	    r_pms	     pointer to subject string scblk
;	    pmssl	     length of subject string in chars
;	    pmdfl	     dot flag, initially zero
;	    pmhbs	     set as shown in stack diagram
;
;      control is passed by branching through the pcode
;      field of the initial pattern node (bri (xr)).
||ejc|||||10103
;
;      description of algorithm
;
;      a pattern structure is represented as a linked graph
;      of nodes with the following structure.
;
;	    +------------------------------------+
;	    i		     pcode		 i
;	    +------------------------------------+
;	    i		     pthen		 i
;	    +------------------------------------+
;	    i		     parm1		 i
;	    +------------------------------------+
;	    i		     parm2		 i
;	    +------------------------------------+
;
;      pcode is a pointer to the routine which will perform
;      the match of this particular node type.
;
;      pthen is a pointer to the successor node. i.e. the node
;      to be matched if the attempt to match this node succeeds.
;      if this is the last node of the pattern pthen points
;      to the dummy node ndnth which initiates pattern exit.
;
;      parm1, parm2 are parameters whose use varies with the
;      particular node. they are only present if required.
;
;      alternatives are handled with the special alternative
;      node whose parameter points to the node to be matched
;      if there is a failure on the successor path.
;
;      the following example illustrates the manner in which
;      the structure is built up. the pattern is
;
;      (a / b / c) (d / e)   where / is alternation
;
;      in the diagram, the node marked + represents an
;      alternative node and the dotted line from a + node
;      represents the parameter pointer to the alternative.
;
;      +---+	 +---+	   +---+     +---+
;      i + i-----i a i-----i + i-----i d i-----
;      +---+	 +---+	i  +---+     +---+
;	 .		i    .
;	 .		i    .
;      +---+	 +---+	i  +---+
;      i + i-----i b i--i  i e i-----
;      +---+	 +---+	i  +---+
;	 .		i
;	 .		i
;      +---+		i
;      i c i------------i
;      +---+
||ejc|||||10157
;
;      during the match, the registers are used as follows.
;
;      (xr)		     points to the current node
;      (xl)		     scratch
;      (xs)		     main stack pointer
;      (wb)		     cursor (number of chars matched)
;      (wa,wc)		     scratch
;
;      to keep track of alternatives, the main stack is used as
;      a history stack and contains two word entries.
;
;      word 1		     saved cursor value
;      word 2		     node to match on failure
;
;      when a failure occurs, the most recent entry on this
;      stack is popped off to restore the cursor and point
;      to the node to be matched as an alternative. the entry
;      at the bottom of the stack points to the following
;      special nodes depending on the scan mode.
;
;      anchored mode	     the bottom entry points to the
;			     special node ndabo which causes an
;			     abort. the cursor value stored
;			     with this entry is always zero.
;
;      unanchored mode	     the bottom entry points to the
;			     special node nduna which moves the
;			     anchor point and restarts the match
;			     the cursor saved with this entry
;			     is the number of characters which
;			     lie before the initial anchor point
;			     (i.e. the number of anchor moves).
;			     this entry is three words long and
;			     also contains the initial pattern.
;
;      entries are made on this history stack by alternative
;      nodes and by some special compound patterns as described
;      later on. the following global locations are used during
;      pattern matching.
;
;      r_pms		     pointer to subject string
;      pmssl		     length of subject string
;      pmdfl		     flag set non-zero for dot patterns
;      pmhbs		     base ptr for current history stack
;
;      the following exit points are available to match routines
;
;      succp		     success in matching current node
;      failp		     failure in matching current node
||ejc|||||10208
;
;      compound patterns
;
;      some patterns have implicit alternatives and their
;      representation in the pattern structure consists of a
;      linked set of nodes as indicated by these diagrams.
;
;      as before, the + represents an alternative node and
;      the dotted line from a + node is the parameter pointer
;      to the alternative pattern.
;
;      arb
;      ---
;
;	    +---+	     this node (p_arb) matches null
;	    i b i-----	     and stacks cursor, successor ptr,
;	    +---+	     cursor (copy) and a ptr to ndarc.
;
;
;
;
;      bal
;      ---
;
;	    +---+	     the p_bal node scans a balanced
;	    i b i-----	     string and then stacks a pointer
;	    +---+	     to itself on the history stack.
||ejc|||||10236
;
;      compound pattern structures (continued)
;
;
;      arbno
;      -----
;
;	    +---+	     this alternative node matches null
;      +----i + i-----	     the first time and stacks a pointer
;      i    +---+	     to the argument pattern x.
;      i      .
;      i      .
;      i    +---+	     node (p_aba) to stack cursor
;      i    i a i	     and history stack base ptr.
;      i    +---+
;      i      i
;      i      i
;      i    +---+	     this is the argument pattern. as
;      i    i x i	     indicated, the successor of the
;      i    +---+	     pattern is the p_abc node
;      i      i
;      i      i
;      i    +---+	     this node (p_abc) pops pmhbs,
;      +----i c i	     stacks old pmhbs and ptr to ndabd
;	    +---+	     (unless optimization has occurred)
;
;      structure and execution of this pattern resemble those of
;      recursive pattern matching and immediate assignment.
;      the alternative node at the head of the structure matches
;      null initially but on subsequent failure ensures attempt
;      to match the argument.  before the argument is matched
;      p_aba stacks the cursor, pmhbs and a ptr to p_abb.  if
;      the argument cant be matched , p_abb removes this special
;      stack entry and fails.
;      if argument is matched , p_abc restores the outer pmhbs
;      value (saved by p_aba) .	 then if the argument has left
;      alternatives on stack it stacks the inner value of pmhbs
;      and a ptr to ndabd. if argument left nothing on the stack
;      it optimises by removing items stacked by p_aba.	 finally
;      a check is made that argument matched more than the null
;      string (check is intended to prevent useless looping).
;      if so the successor is again the alternative node at the
;      head of the structure , ensuring a possible extra attempt
;      to match the arg if necessary.  if not , the successor to
;      alternative is taken so as to terminate the loop.  p_abd
;      restores inner pmhbs ptr and fails , thus trying to match
;      alternatives left by the arbno argument.
||ejc|||||10284
;
;      compound pattern structures (continued)
;
;      breakx
;      ------
;
;	    +---+	     this node is a break node for
;      +----i b i	     the argument to breakx, identical
;      i    +---+	     to an ordinary break node.
;      i      i
;      i      i
;      i    +---+	     this alternative node stacks a
;      i    i + i-----	     pointer to the breakx node to
;      i    +---+	     allow for subsequent failure
;      i      .
;      i      .
;      i    +---+	     this is the breakx node itself. it
;      +----i x i	     matches one character and then
;	    +---+	     proceeds back to the break node.
;
;
;
;
;      fence
;      -----
;
;	    +---+	     the fence node matches null and
;	    i f i-----	     stacks a pointer to node ndabo to
;	    +---+	     abort on a subsequent rematch
;
;
;
;
;      succeed
;      -------
;
;	    +---+	     the node for succeed matches null
;	    i s i-----	     and stacks a pointer to itself
;	    +---+	     to repeat the match on a failure.
||ejc|||||10324
;
;      compound patterns (continued)
;
;      binary dot (pattern assignment)
;      -------------------------------
;
;	    +---+	     this node (p_paa) saves the current
;	    i a i	     cursor and a pointer to the
;	    +---+	     special node ndpab on the stack.
;	      i
;	      i
;	    +---+	     this is the structure for the
;	    i x i	     pattern left argument of the
;	    +---+	     pattern assignment call.
;	      i
;	      i
;	    +---+	     this node (p_pac) saves the cursor,
;	    i c i-----	     a ptr to itself, the cursor (copy)
;	    +---+	     and a ptr to ndpad on the stack.
;
;
;      the function of the match routine for ndpab (p_pab)
;      is simply to unstack itself and fail back onto the stack.
;
;      the match routine for p_pac also sets the global pattern
;      flag pmdfl non-zero to indicate that pattern assignments
;      may have occured in the pattern match
;
;      if pmdfl is set at the end of the match (see p_nth), the
;      history stack is scanned for matching ndpab-ndpad pairs
;      and the corresponding pattern assignments are executed.
;
;      the function of the match routine for ndpad (p_pad)
;      is simply to remove its entry from the stack and fail.
;      this includes removing the special node pointer stored
;      in addition to the standard two entries on the stack.
||ejc|||||10361
;
;      compount pattern structures (continued)
;
;      fence (function)
;      ----------------
;
;	    +---+	     this node (p_fna) saves the
;	    i a i	     current history stack and a
;	    +---+	     pointer to ndfnb on the stack.
;	      i
;	      i
;	    +---+	     this is the pattern structure
;	    i x i	     given as the argument to the
;	    +---+	     fence function.
;	      i
;	      i
;	    +---+	     this node p_fnc restores the outer
;	    i c i	     history stack ptr saved in p_fna,
;	    +---+	     and stacks the inner stack base
;			     ptr and a pointer to ndfnd on the
;			     stack.
;
;      ndfnb (f_fnb) simply is the failure exit for pattern
;      argument failure, and it pops itself and fails onto the
;      stack.
;
;      the match routine p_fnc allows for an optimization when
;      the fence pattern leaves no alternatives.  in this case,
;      the ndfnb entry is popped, and the match continues.
;
;      ndfnd (p_fnd) is entered when the pattern fails after
;      going through a non-optimized p_fnc, and it pops the
;      stack back past the innter stack base created by p_fna
||ejc|||||10395
;
;      compound patterns (continued)
;
;      expression patterns (recursive pattern matches)
;      -----------------------------------------------
;
;      initial entry for a pattern node is to the routine p_exa.
;      if the evaluated result of the expression is itself a
;      pattern, then the following steps are taken to arrange
;      for proper recursive processing.
;
;      1)   a pointer to the current node (the p_exa node) is
;	    stored on the history stack with a dummy cursor.
;
;      2)   a special history stack entry is made in which the
;	    node pointer points to ndexb, and the cursor value
;	    is the saved value of pmhbs on entry to this node.
;	    the match routine for ndexb (p_exb) restores pmhbs
;	    from this cursor entry, pops off the p_exa node
;	    pointer and fails.
;
;      3)   the resulting history stack pointer is saved in
;	    pmhbs to establish a new level of history stack.
;
;      after matching a pattern, the end of match routine gets
;      control (p_nth). this routine proceeds as follows.
;
;      1)   load the current value of pmhbs and recognize the
;	    outer level case by the fact that the associated
;	    cursor in this case is the pattern match type code
;	    which is less than 3. terminate the match in this
;	    case and continue execution of the program.
;
;      2)   otherwise make a special history stack entry in
;	    which the node pointer points to the special node
;	    ndexc and the cursor is the current value of pmhbs.
;	    the match routine for ndexc (p_exc) resets pmhbs to
;	    this (inner) value and and then fails.
;
;      3)   using the history stack entry made on starting the
;	    expression (accessible with the current value of
;	    pmhbs), restore the p_exa node pointer and the old
;	    pmhbs setting. take the successor and continue.
;
;      an optimization is possible if the expression pattern
;      makes no entries on the history stack. in this case,
;      instead of building the p_exc node in step 2, it is more
;      efficient to simply pop off the p_exb entry and its
;      associated node pointer. the effect is the same.
||ejc|||||10445
;
;      compound patterns (continued)
;
;      binary dollar (immediate assignment)
;      ------------------------------------
;
;	    +---+	     this node (p_ima) stacks the cursor
;	    i a i	     pmhbs and a ptr to ndimb and resets
;	    +---+	     the stack ptr pmhbs.
;	      i
;	      i
;	    +---+	     this is the left structure for the
;	    i x i	     pattern left argument of the
;	    +---+	     immediate assignment call.
;	      i
;	      i
;	    +---+	     this node (p_imc) performs the
;	    i c i-----	     assignment, pops pmhbs and stacks
;	    +---+	     the old pmhbs and a ptr to ndimd.
;
;
;      the structure and execution of this pattern are similar
;      to those of the recursive expression pattern matching.
;
;      the match routine for ndimb (p_imb) restores the outer
;      level value of pmhbs, unstacks the saved cursor and fails
;
;      the match routine p_imc uses the current value of pmhbs
;      to locate the p_imb entry. this entry is used to make
;      the assignment and restore the outer level value of
;      pmhbs. finally, the inner level value of pmhbs and a
;      pointer to the special node ndimd are stacked.
;
;      the match routine for ndimd (p_imd) restores the inner
;      level value of pmhbs and fails back into the stack.
;
;      an optimization occurs if the inner pattern makes no
;      entries on the history stack. in this case, p_imc pops
;      the p_imb entry instead of making a p_imd entry.
||ejc|||||10485
;
;      arbno
;
;      see compound patterns section for stucture and
;      algorithm for matching this node type.
;
;      no parameters
;
|p_aba|ent|2,bl_p0|||; p0blk|10494
||mov|11,-(xs)|8,wb||; stack cursor|10495
||mov|11,-(xs)|7,xr||; stack dummy node ptr|10496
||mov|11,-(xs)|3,pmhbs||; stack old stack base ptr|10497
||mov|11,-(xs)|21,=ndabb||; stack ptr to node ndabb|10498
||mov|3,pmhbs|7,xs||; store new stack base ptr|10499
||brn|6,succp|||; succeed|10500
||ejc|||||10501
;
;      arbno (remove p_aba special stack entry)
;
;      no parameters (dummy pattern)
;
|p_abb|ent||||; entry point|10507
||mov|3,pmhbs|8,wb||; restore history stack base ptr|10508
||brn|6,flpop|||; fail and pop dummy node ptr|10509
||ejc|||||10510
;
;      arbno (check if arg matched null string)
;
;      no parameters (dummy pattern)
;
|p_abc|ent|2,bl_p0|||; p0blk|10516
||mov|7,xt|3,pmhbs||; keep p_abb stack base|10517
||mov|8,wa|13,num03(xt)||; load initial cursor|10518
||mov|3,pmhbs|13,num01(xt)||; restore outer stack base ptr|10519
||beq|7,xt|7,xs|6,pabc1|; jump if no history stack entries|10520
||mov|11,-(xs)|7,xt||; else save inner pmhbs entry|10521
||mov|11,-(xs)|21,=ndabd||; stack ptr to special node ndabd|10522
||brn|6,pabc2|||; merge|10523
;
;      optimise case of no extra entries on stack from arbno arg
;
|pabc1|add|7,xs|19,*num04||; remove ndabb entry and cursor|10527
;
;      merge to check for matching of null string
;
|pabc2|bne|8,wa|8,wb|6,succp|; allow further attempt if non-null|10531
||mov|7,xr|13,pthen(xr)||; bypass alternative node so as to ...|10532
||brn|6,succp|||; ... refuse further match attempts|10533
||ejc|||||10534
;
;      arbno (try for alternatives in arbno argument)
;
;      no parameters (dummy pattern)
;
|p_abd|ent||||; entry point|10540
||mov|3,pmhbs|8,wb||; restore inner stack base ptr|10541
||brn|6,failp|||; and fail|10542
||ejc|||||10543
;
;      abort
;
;      no parameters
;
|p_abo|ent|2,bl_p0|||; p0blk|10549
||brn|6,exfal|||; signal statement failure|10550
||ejc|||||10551
;
;      alternation
;
;      parm1		     alternative node
;
|p_alt|ent|2,bl_p1|||; p1blk|10557
||mov|11,-(xs)|8,wb||; stack cursor|10558
||mov|11,-(xs)|13,parm1(xr)||; stack pointer to alternative|10559
||chk||||; check for stack overflow|10560
||brn|6,succp|||; if all ok, then succeed|10561
||ejc|||||10562
;
;      any (one character argument) (1-char string also)
;
;      parm1		     character argument
;
|p_ans|ent|2,bl_p1|||; p1blk|10568
||beq|8,wb|3,pmssl|6,failp|; fail if no chars left|10569
||mov|7,xl|3,r_pms||; else point to subject string|10570
||plc|7,xl|8,wb||; point to current character|10571
||lch|8,wa|9,(xl)||; load current character|10572
||bne|8,wa|13,parm1(xr)|6,failp|; fail if no match|10573
||icv|8,wb|||; else bump cursor|10574
||brn|6,succp|||; and succeed|10575
||ejc|||||10576
;
;      any (multi-character argument case)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit in ctblk
;
|p_any|ent|2,bl_p2|||; p2blk|10583
;
;      expression argument case merges here
;
|pany1|beq|8,wb|3,pmssl|6,failp|; fail if no characters left|10587
||mov|7,xl|3,r_pms||; else point to subject string|10588
||plc|7,xl|8,wb||; get char ptr to current character|10589
||lch|8,wa|9,(xl)||; load current character|10590
||mov|7,xl|13,parm1(xr)||; point to ctblk|10591
||wtb|8,wa|||; change to byte offset|10592
||add|7,xl|8,wa||; point to entry in ctblk|10593
||mov|8,wa|13,ctchs(xl)||; load word from ctblk|10594
||anb|8,wa|13,parm2(xr)||; and with selected bit|10595
||zrb|8,wa|6,failp||; fail if no match|10596
||icv|8,wb|||; else bump cursor|10597
||brn|6,succp|||; and succeed|10598
||ejc|||||10599
;
;      any (expression argument)
;
;      parm1		     expression pointer
;
|p_ayd|ent|2,bl_p1|||; p1blk|10605
||jsr|6,evals|||; evaluate string argument|10606
||err|1,043|26,any evaluated argument is not a string|||10607
||ppm|6,failp|||; fail if evaluation failure|10608
||ppm|6,pany1|||; merge multi-char case if ok|10609
||ejc|||||10610
;
;      p_arb		     initial arb match
;
;      no parameters
;
;      the p_arb node is part of a compound pattern structure
;      for an arb pattern (see description of compound patterns)
;
|p_arb|ent|2,bl_p0|||; p0blk|10619
||mov|7,xr|13,pthen(xr)||; load successor pointer|10620
||mov|11,-(xs)|8,wb||; stack dummy cursor|10621
||mov|11,-(xs)|7,xr||; stack successor pointer|10622
||mov|11,-(xs)|8,wb||; stack cursor|10623
||mov|11,-(xs)|21,=ndarc||; stack ptr to special node ndarc|10624
||bri|9,(xr)|||; execute next node matching null|10625
||ejc|||||10626
;
;      p_arc		     extend arb match
;
;      no parameters (dummy pattern)
;
|p_arc|ent||||; entry point|10632
||beq|8,wb|3,pmssl|6,flpop|; fail and pop stack to successor|10633
||icv|8,wb|||; else bump cursor|10634
||mov|11,-(xs)|8,wb||; stack updated cursor|10635
||mov|11,-(xs)|7,xr||; restack pointer to ndarc node|10636
||mov|7,xr|13,num02(xs)||; load successor pointer|10637
||bri|9,(xr)|||; off to reexecute successor node|10638
||ejc|||||10639
;
;      bal
;
;      no parameters
;
;      the p_bal node is part of the compound structure built
;      for bal (see section on compound patterns).
;
|p_bal|ent|2,bl_p0|||; p0blk|10648
||zer|8,wc|||; zero parentheses level counter|10649
||mov|7,xl|3,r_pms||; point to subject string|10650
||plc|7,xl|8,wb||; point to current character|10651
||brn|6,pbal2|||; jump into scan loop|10652
;
;      loop to scan out characters
;
|pbal1|lch|8,wa|10,(xl)+||; load next character, bump pointer|10656
||icv|8,wb|||; push cursor for character|10657
||beq|8,wa|18,=ch_pp|6,pbal3|; jump if left paren|10658
||beq|8,wa|18,=ch_rp|6,pbal4|; jump if right paren|10659
||bze|8,wc|6,pbal5||; else succeed if at outer level|10660
;
;      here after processing one character
;
|pbal2|bne|8,wb|3,pmssl|6,pbal1|; loop back unless end of string|10664
||brn|6,failp|||; in which case, fail|10665
;
;      here on left paren
;
|pbal3|icv|8,wc|||; bump paren level|10669
||brn|6,pbal2|||; loop back to check end of string|10670
;
;      here for right paren
;
|pbal4|bze|8,wc|6,failp||; fail if no matching left paren|10674
||dcv|8,wc|||; else decrement level counter|10675
||bnz|8,wc|6,pbal2||; loop back if not at outer level|10676
;
;      here after successfully scanning a balanced string
;
|pbal5|mov|11,-(xs)|8,wb||; stack cursor|10680
||mov|11,-(xs)|7,xr||; stack ptr to bal node for extend|10681
||brn|6,succp|||; and succeed|10682
||ejc|||||10683
;
;      break (expression argument)
;
;      parm1		     expression pointer
;
|p_bkd|ent|2,bl_p1|||; p1blk|10689
||jsr|6,evals|||; evaluate string expression|10690
||err|1,044|26,break evaluated argument is not a string|||10691
||ppm|6,failp|||; fail if evaluation fails|10692
||ppm|6,pbrk1|||; merge with multi-char case if ok|10693
||ejc|||||10694
;
;      break (one character argument)
;
;      parm1		     character argument
;
|p_bks|ent|2,bl_p1|||; p1blk|10700
||mov|8,wc|3,pmssl||; get subject string length|10701
||sub|8,wc|8,wb||; get number of characters left|10702
||bze|8,wc|6,failp||; fail if no characters left|10703
||lct|8,wc|8,wc||; set counter for chars left|10704
||mov|7,xl|3,r_pms||; point to subject string|10705
||plc|7,xl|8,wb||; point to current character|10706
;
;      loop to scan till break character found
;
|pbks1|lch|8,wa|10,(xl)+||; load next char, bump pointer|10710
||beq|8,wa|13,parm1(xr)|6,succp|; succeed if break character found|10711
||icv|8,wb|||; else push cursor|10712
||bct|8,wc|6,pbks1||; loop back if more to go|10713
||brn|6,failp|||; fail if end of string, no break chr|10714
||ejc|||||10715
;
;      break (multi-character argument)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
|p_brk|ent|2,bl_p2|||; p2blk|10722
;
;      expression argument merges here
;
|pbrk1|mov|8,wc|3,pmssl||; load subject string length|10726
||sub|8,wc|8,wb||; get number of characters left|10727
||bze|8,wc|6,failp||; fail if no characters left|10728
||lct|8,wc|8,wc||; set counter for characters left|10729
||mov|7,xl|3,r_pms||; else point to subject string|10730
||plc|7,xl|8,wb||; point to current character|10731
||mov|3,psave|7,xr||; save node pointer|10732
;
;      loop to search for break character
;
|pbrk2|lch|8,wa|10,(xl)+||; load next char, bump pointer|10736
||mov|7,xr|13,parm1(xr)||; load pointer to ctblk|10737
||wtb|8,wa|||; convert to byte offset|10738
||add|7,xr|8,wa||; point to ctblk entry|10739
||mov|8,wa|13,ctchs(xr)||; load ctblk word|10740
||mov|7,xr|3,psave||; restore node pointer|10741
||anb|8,wa|13,parm2(xr)||; and with selected bit|10742
||nzb|8,wa|6,succp||; succeed if break character found|10743
||icv|8,wb|||; else push cursor|10744
||bct|8,wc|6,pbrk2||; loop back unless end of string|10745
||brn|6,failp|||; fail if end of string, no break chr|10746
||ejc|||||10747
;
;      breakx (extension)
;
;      this is the entry which causes an extension of a breakx
;      match when failure occurs. see section on compound
;      patterns for full details of breakx matching.
;
;      no parameters
;
|p_bkx|ent|2,bl_p0|||; p0blk|10757
||icv|8,wb|||; step cursor past previous break chr|10758
||brn|6,succp|||; succeed to rematch break|10759
||ejc|||||10760
;
;      breakx (expression argument)
;
;      see section on compound patterns for full structure of
;      breakx pattern. the actual character matching uses a
;      break node. however, the entry for the expression
;      argument case is separated to get proper error messages.
;
;      parm1		     expression pointer
;
|p_bxd|ent|2,bl_p1|||; p1blk|10771
||jsr|6,evals|||; evaluate string argument|10772
||err|1,045|26,breakx evaluated argument is not a string|||10773
||ppm|6,failp|||; fail if evaluation fails|10774
||ppm|6,pbrk1|||; merge with break if all ok|10775
||ejc|||||10776
;
;      cursor assignment
;
;      parm1		     name base
;      parm2		     name offset
;
|p_cas|ent|2,bl_p2|||; p2blk|10783
||mov|11,-(xs)|7,xr||; save node pointer|10784
||mov|11,-(xs)|8,wb||; save cursor|10785
||mov|7,xl|13,parm1(xr)||; load name base|10786
||mti|8,wb|||; load cursor as integer|10787
||mov|8,wb|13,parm2(xr)||; load name offset|10788
||jsr|6,icbld|||; get icblk for cursor value|10789
||mov|8,wa|8,wb||; move name offset|10790
||mov|8,wb|7,xr||; move value to assign|10791
||jsr|6,asinp|||; perform assignment|10792
||ppm|6,flpop|||; fail on assignment failure|10793
||mov|8,wb|10,(xs)+||; else restore cursor|10794
||mov|7,xr|10,(xs)+||; restore node pointer|10795
||brn|6,succp|||; and succeed matching null|10796
||ejc|||||10797
;
;      expression node (p_exa, initial entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      parm1		     expression pointer
;
|p_exa|ent|2,bl_p1|||; p1blk|10806
||jsr|6,evalp|||; evaluate expression|10807
||ppm|6,failp|||; fail if evaluation fails|10808
||blo|8,wa|22,=p_aaa|6,pexa1|; jump if result is not a pattern|10809
;
;      here if result of expression is a pattern
;
||mov|11,-(xs)|8,wb||; stack dummy cursor|10813
||mov|11,-(xs)|7,xr||; stack ptr to p_exa node|10814
||mov|11,-(xs)|3,pmhbs||; stack history stack base ptr|10815
||mov|11,-(xs)|21,=ndexb||; stack ptr to special node ndexb|10816
||mov|3,pmhbs|7,xs||; store new stack base pointer|10817
||mov|7,xr|7,xl||; copy node pointer|10818
||bri|9,(xr)|||; match first node in expression pat|10819
;
;      here if result of expression is not a pattern
;
|pexa1|beq|8,wa|22,=b_scl|6,pexa2|; jump if it is already a string|10823
||mov|11,-(xs)|7,xl||; else stack result|10824
||mov|7,xl|7,xr||; save node pointer|10825
||jsr|6,gtstg|||; convert result to string|10826
||err|1,046|26,expression does not evaluate to pattern|||10827
||mov|8,wc|7,xr||; copy string pointer|10828
||mov|7,xr|7,xl||; restore node pointer|10829
||mov|7,xl|8,wc||; copy string pointer again|10830
;
;      merge here with string pointer in xl
;
|pexa2|bze|13,sclen(xl)|6,succp||; just succeed if null string|10834
||brn|6,pstr1|||; else merge with string circuit|10835
||ejc|||||10836
;
;      expression node (p_exb, remove ndexb entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      no parameters (dummy pattern)
;
|p_exb|ent||||; entry point|10845
||mov|3,pmhbs|8,wb||; restore outer level stack pointer|10846
||brn|6,flpop|||; fail and pop p_exa node ptr|10847
||ejc|||||10848
;
;      expression node (p_exc, remove ndexc entry)
;
;      see compound patterns description for the structure and
;      algorithms for handling expression nodes.
;
;      no parameters (dummy pattern)
;
|p_exc|ent||||; entry point|10857
||mov|3,pmhbs|8,wb||; restore inner stack base pointer|10858
||brn|6,failp|||; and fail into expr pattern alternvs|10859
||ejc|||||10860
;
;      fail
;
;      no parameters
;
|p_fal|ent|2,bl_p0|||; p0blk|10866
||brn|6,failp|||; just signal failure|10867
||ejc|||||10868
;
;      fence
;
;      see compound patterns section for the structure and
;      algorithm for matching this node type.
;
;      no parameters
;
|p_fen|ent|2,bl_p0|||; p0blk|10877
||mov|11,-(xs)|8,wb||; stack dummy cursor|10878
||mov|11,-(xs)|21,=ndabo||; stack ptr to abort node|10879
||brn|6,succp|||; and succeed matching null|10880
||ejc|||||10881
;
;      fence (function)
;
;      see compound patterns comments at start of this section
;      for details of scheme
;
;      no parameters
;
|p_fna|ent|2,bl_p0|||; p0blk|10890
||mov|11,-(xs)|3,pmhbs||; stack current history stack base|10891
||mov|11,-(xs)|21,=ndfnb||; stack indir ptr to p_fnb (failure)|10892
||mov|3,pmhbs|7,xs||; begin new history stack|10893
||brn|6,succp|||; succeed|10894
||ejc|||||10895
;
;      fence (function) (reset history stack and fail)
;
;      no parameters (dummy pattern)
;
|p_fnb|ent|2,bl_p0|||; p0blk|10901
||mov|3,pmhbs|8,wb||; restore outer pmhbs stack base|10902
||brn|6,failp|||; ...and fail|10903
||ejc|||||10904
;
;      fence (function) (make fence trap entry on stack)
;
;      no parameters (dummy pattern)
;
|p_fnc|ent|2,bl_p0|||; p0blk|10910
||mov|7,xt|3,pmhbs||; get inner stack base ptr|10911
||mov|3,pmhbs|13,num01(xt)||; restore outer stack base|10912
||beq|7,xt|7,xs|6,pfnc1|; optimize if no alternatives|10913
||mov|11,-(xs)|7,xt||; else stack inner stack base|10914
||mov|11,-(xs)|21,=ndfnd||; stack ptr to ndfnd|10915
||brn|6,succp|||; succeed|10916
;
;      here when fence function left nothing on the stack
;
|pfnc1|add|7,xs|19,*num02||; pop off p_fnb entry|10920
||brn|6,succp|||; succeed|10921
||ejc|||||10922
;
;      fence (function) (skip past alternatives on failure)
;
;      no parameters (dummy pattern)
;
|p_fnd|ent|2,bl_p0|||; p0blk|10928
||mov|7,xs|8,wb||; pop stack to fence() history base|10929
||brn|6,flpop|||; pop base entry and fail|10930
||ejc|||||10931
;
;      immediate assignment (initial entry, save current cursor)
;
;      see compound patterns description for details of the
;      structure and algorithm for matching this node type.
;
;      no parameters
;
|p_ima|ent|2,bl_p0|||; p0blk|10940
||mov|11,-(xs)|8,wb||; stack cursor|10941
||mov|11,-(xs)|7,xr||; stack dummy node pointer|10942
||mov|11,-(xs)|3,pmhbs||; stack old stack base pointer|10943
||mov|11,-(xs)|21,=ndimb||; stack ptr to special node ndimb|10944
||mov|3,pmhbs|7,xs||; store new stack base pointer|10945
||brn|6,succp|||; and succeed|10946
||ejc|||||10947
;
;      immediate assignment (remove cursor mark entry)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
|p_imb|ent||||; entry point|10956
||mov|3,pmhbs|8,wb||; restore history stack base ptr|10957
||brn|6,flpop|||; fail and pop dummy node ptr|10958
||ejc|||||10959
;
;      immediate assignment (perform actual assignment)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      parm1		     name base of variable
;      parm2		     name offset of variable
;
|p_imc|ent|2,bl_p2|||; p2blk|10969
||mov|7,xt|3,pmhbs||; load pointer to p_imb entry|10970
||mov|8,wa|8,wb||; copy final cursor|10971
||mov|8,wb|13,num03(xt)||; load initial cursor|10972
||mov|3,pmhbs|13,num01(xt)||; restore outer stack base pointer|10973
||beq|7,xt|7,xs|6,pimc1|; jump if no history stack entries|10974
||mov|11,-(xs)|7,xt||; else save inner pmhbs pointer|10975
||mov|11,-(xs)|21,=ndimd||; and a ptr to special node ndimd|10976
||brn|6,pimc2|||; merge|10977
;
;      here if no entries made on history stack
;
|pimc1|add|7,xs|19,*num04||; remove ndimb entry and cursor|10981
;
;      merge here to perform assignment
;
|pimc2|mov|11,-(xs)|8,wa||; save current (final) cursor|10985
||mov|11,-(xs)|7,xr||; save current node pointer|10986
||mov|7,xl|3,r_pms||; point to subject string|10987
||sub|8,wa|8,wb||; compute substring length|10988
||jsr|6,sbstr|||; build substring|10989
||mov|8,wb|7,xr||; move result|10990
||mov|7,xr|9,(xs)||; reload node pointer|10991
||mov|7,xl|13,parm1(xr)||; load name base|10992
||mov|8,wa|13,parm2(xr)||; load name offset|10993
||jsr|6,asinp|||; perform assignment|10994
||ppm|6,flpop|||; fail if assignment fails|10995
||mov|7,xr|10,(xs)+||; else restore node pointer|10996
||mov|8,wb|10,(xs)+||; restore cursor|10997
||brn|6,succp|||; and succeed|10998
||ejc|||||10999
;
;      immediate assignment (remove ndimd entry on failure)
;
;      see compound patterns description for details of the
;      structure and algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
|p_imd|ent||||; entry point|11008
||mov|3,pmhbs|8,wb||; restore inner stack base pointer|11009
||brn|6,failp|||; and fail|11010
||ejc|||||11011
;
;      len (integer argument)
;
;      parm1		     integer argument
;
|p_len|ent|2,bl_p1|||; p1blk|11017
;
;      expression argument case merges here
;
|plen1|add|8,wb|13,parm1(xr)||; push cursor indicated amount|11021
||ble|8,wb|3,pmssl|6,succp|; succeed if not off end|11022
||brn|6,failp|||; else fail|11023
||ejc|||||11024
;
;      len (expression argument)
;
;      parm1		     expression pointer
;
|p_lnd|ent|2,bl_p1|||; p1blk|11030
||jsr|6,evali|||; evaluate integer argument|11031
||err|1,047|26,len evaluated argument is not integer|||11032
||err|1,048|26,len evaluated argument is negative or too large|||11033
||ppm|6,failp|||; fail if evaluation fails|11034
||ppm|6,plen1|||; merge with normal circuit if ok|11035
||ejc|||||11036
;
;      notany (expression argument)
;
;      parm1		     expression pointer
;
|p_nad|ent|2,bl_p1|||; p1blk|11042
||jsr|6,evals|||; evaluate string argument|11043
||err|1,049|26,notany evaluated argument is not a string|||11044
||ppm|6,failp|||; fail if evaluation fails|11045
||ppm|6,pnay1|||; merge with multi-char case if ok|11046
||ejc|||||11047
;
;      notany (one character argument)
;
;      parm1		     character argument
;
|p_nas|ent|2,bl_p1|||; entry point|11053
||beq|8,wb|3,pmssl|6,failp|; fail if no chars left|11054
||mov|7,xl|3,r_pms||; else point to subject string|11055
||plc|7,xl|8,wb||; point to current character in strin|11056
||lch|8,wa|9,(xl)||; load current character|11057
||beq|8,wa|13,parm1(xr)|6,failp|; fail if match|11058
||icv|8,wb|||; else bump cursor|11059
||brn|6,succp|||; and succeed|11060
||ejc|||||11061
;
;      notany (multi-character string argument)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
|p_nay|ent|2,bl_p2|||; p2blk|11068
;
;      expression argument case merges here
;
|pnay1|beq|8,wb|3,pmssl|6,failp|; fail if no characters left|11072
||mov|7,xl|3,r_pms||; else point to subject string|11073
||plc|7,xl|8,wb||; point to current character|11074
||lch|8,wa|9,(xl)||; load current character|11075
||wtb|8,wa|||; convert to byte offset|11076
||mov|7,xl|13,parm1(xr)||; load pointer to ctblk|11077
||add|7,xl|8,wa||; point to entry in ctblk|11078
||mov|8,wa|13,ctchs(xl)||; load entry from ctblk|11079
||anb|8,wa|13,parm2(xr)||; and with selected bit|11080
||nzb|8,wa|6,failp||; fail if character is matched|11081
||icv|8,wb|||; else bump cursor|11082
||brn|6,succp|||; and succeed|11083
||ejc|||||11084
;
;      end of pattern match
;
;      this routine is entered on successful completion.
;      see description of expression patterns in compound
;      pattern section for handling of recursion in matching.
;
;      this pattern also results from an attempt to convert the
;      null string to a pattern via convert()
;
;      no parameters (dummy pattern)
;
|p_nth|ent|2,bl_p0|||; p0blk (dummy)|11097
||mov|7,xt|3,pmhbs||; load pointer to base of stack|11098
||mov|8,wa|13,num01(xt)||; load saved pmhbs (or pattern type)|11099
||ble|8,wa|18,=num02|6,pnth2|; jump if outer level (pattern type)|11100
;
;      here we are at the end of matching an expression pattern
;
||mov|3,pmhbs|8,wa||; restore outer stack base pointer|11104
||mov|7,xr|13,num02(xt)||; restore pointer to p_exa node|11105
||beq|7,xt|7,xs|6,pnth1|; jump if no history stack entries|11106
||mov|11,-(xs)|7,xt||; else stack inner stack base ptr|11107
||mov|11,-(xs)|21,=ndexc||; stack ptr to special node ndexc|11108
||brn|6,succp|||; and succeed|11109
;
;      here if no history stack entries during pattern
;
|pnth1|add|7,xs|19,*num04||; remove p_exb entry and node ptr|11113
||brn|6,succp|||; and succeed|11114
;
;      here if end of match at outer level
;
|pnth2|mov|3,pmssl|8,wb||; save final cursor in safe place|11118
||bze|3,pmdfl|6,pnth6||; jump if no pattern assignments|11119
||ejc|||||11120
;
;      end of pattern match (continued)
;
;      now we must perform pattern assignments. this is done by
;      scanning the history stack for matching ndpab-ndpad pairs
;
|pnth3|dca|7,xt|||; point past cursor entry|11127
||mov|8,wa|11,-(xt)||; load node pointer|11128
||beq|8,wa|21,=ndpad|6,pnth4|; jump if ndpad entry|11129
||bne|8,wa|21,=ndpab|6,pnth5|; jump if not ndpab entry|11130
;
;      here for ndpab entry, stack initial cursor
;      note that there must be more entries on the stack.
;
||mov|11,-(xs)|13,num01(xt)||; stack initial cursor|11135
||chk||||; check for stack overflow|11136
||brn|6,pnth3|||; loop back if ok|11137
;
;      here for ndpad entry. the starting cursor from the
;      matching ndpad entry is now the top stack entry.
;
|pnth4|mov|8,wa|13,num01(xt)||; load final cursor|11142
||mov|8,wb|9,(xs)||; load initial cursor from stack|11143
||mov|9,(xs)|7,xt||; save history stack scan ptr|11144
||sub|8,wa|8,wb||; compute length of string|11145
;
;      build substring and perform assignment
;
||mov|7,xl|3,r_pms||; point to subject string|11149
||jsr|6,sbstr|||; construct substring|11150
||mov|8,wb|7,xr||; copy substring pointer|11151
||mov|7,xt|9,(xs)||; reload history stack scan ptr|11152
||mov|7,xl|13,num02(xt)||; load pointer to p_pac node with nam|11153
||mov|8,wa|13,parm2(xl)||; load name offset|11154
||mov|7,xl|13,parm1(xl)||; load name base|11155
||jsr|6,asinp|||; perform assignment|11156
||ppm|6,exfal|||; match fails if name eval fails|11157
||mov|7,xt|10,(xs)+||; else restore history stack ptr|11158
||ejc|||||11159
;
;      end of pattern match (continued)
;
;      here check for end of entries
;
|pnth5|bne|7,xt|7,xs|6,pnth3|; loop if more entries to scan|11165
;
;      here after dealing with pattern assignments
;
|pnth6|mov|7,xs|3,pmhbs||; wipe out history stack|11169
||mov|8,wb|10,(xs)+||; load initial cursor|11170
||mov|8,wc|10,(xs)+||; load match type code|11171
||mov|8,wa|3,pmssl||; load final cursor value|11172
||mov|7,xl|3,r_pms||; point to subject string|11173
||zer|3,r_pms|||; clear subject string ptr for gbcol|11174
||bze|8,wc|6,pnth7||; jump if call by name|11175
||beq|8,wc|18,=num02|6,pnth9|; exit if statement level call|11176
;
;      here we have a call by value, build substring
;
||sub|8,wa|8,wb||; compute length of string|11180
||jsr|6,sbstr|||; build substring|11181
||mov|11,-(xs)|7,xr||; stack result|11182
||lcw|7,xr|||; get next code word|11183
||bri|9,(xr)|||; execute it|11184
;
;      here for call by name, make stack entries for o_rpl
;
|pnth7|mov|11,-(xs)|8,wb||; stack initial cursor|11188
||mov|11,-(xs)|8,wa||; stack final cursor|11189
;
;      here with xl pointing to scblk or bcblk
;
|pnth8|mov|11,-(xs)|7,xl||; stack subject pointer|11198
;
;      here to obey next code word
;
|pnth9|lcw|7,xr|||; get next code word|11202
||bri|9,(xr)|||; execute next code word|11203
||ejc|||||11204
;
;      pos (integer argument)
;
;      parm1		     integer argument
;
|p_pos|ent|2,bl_p1|||; p1blk|11210
;
;      optimize pos if it is the first pattern element,
;      unanchored mode, cursor is zero and pos argument
;      is not beyond end of string.  force cursor position
;      and number of unanchored moves.
;
;      this optimization is performed invisible provided
;      the argument is either a simple integer or an
;      expression that is an untraced variable (that is,
;      it has no side effects that would be lost by short-
;      circuiting the normal logic of failing and moving the
;      unanchored starting point.)
;
;      pos (integer argument)
;
;      parm1		     integer argument
;
||beq|8,wb|13,parm1(xr)|6,succp|; succeed if at right location|11228
||bnz|8,wb|6,failp||; don't look further if cursor not 0|11229
||mov|7,xt|3,pmhbs||; get history stack base ptr|11230
||bne|7,xr|11,-(xt)|6,failp|; fail if pos is not first node|11231
;
;      expression argument circuit merges here
;
|ppos2|bne|11,-(xt)|21,=nduna|6,failp|; fail if not unanchored mode|11235
||mov|8,wb|13,parm1(xr)||; get desired cursor position|11236
||bgt|8,wb|3,pmssl|6,exfal|; abort if off end|11237
||mov|13,num02(xt)|8,wb||; fake number of unanchored moves|11238
||brn|6,succp|||; continue match with adjusted cursor|11239
||ejc|||||11240
;
;      pos (expression argument)
;
;      parm1		     expression pointer
;
|p_psd|ent|2,bl_p1|||; p1blk|11246
||jsr|6,evali|||; evaluate integer argument|11247
||err|1,050|26,pos evaluated argument is not integer|||11248
||err|1,051|26,pos evaluated argument is negative or too large|||11249
||ppm|6,failp|||; fail if evaluation fails|11250
||ppm|6,ppos1|||; process expression case|11251
;
|ppos1|beq|8,wb|13,parm1(xr)|6,succp|; succeed if at right location|11253
||bnz|8,wb|6,failp||; don't look further if cursor not 0|11254
||bnz|3,evlif|6,failp||; fail if complex argument|11255
||mov|7,xt|3,pmhbs||; get history stack base ptr|11256
||mov|8,wa|3,evlio||; get original node ptr|11257
||bne|8,wa|11,-(xt)|6,failp|; fail if pos is not first node|11258
||brn|6,ppos2|||; merge with integer argument code|11259
||ejc|||||11260
;
;      pattern assignment (initial entry, save cursor)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters
;
|p_paa|ent|2,bl_p0|||; p0blk|11269
||mov|11,-(xs)|8,wb||; stack initial cursor|11270
||mov|11,-(xs)|21,=ndpab||; stack ptr to ndpab special node|11271
||brn|6,succp|||; and succeed matching null|11272
||ejc|||||11273
;
;      pattern assignment (remove saved cursor)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters (dummy pattern)
;
|p_pab|ent||||; entry point|11282
||brn|6,failp|||; just fail (entry is already popped)|11283
||ejc|||||11284
;
;      pattern assignment (end of match, make assign entry)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      parm1		     name base of variable
;      parm2		     name offset of variable
;
|p_pac|ent|2,bl_p2|||; p2blk|11294
||mov|11,-(xs)|8,wb||; stack dummy cursor value|11295
||mov|11,-(xs)|7,xr||; stack pointer to p_pac node|11296
||mov|11,-(xs)|8,wb||; stack final cursor|11297
||mov|11,-(xs)|21,=ndpad||; stack ptr to special ndpad node|11298
||mnz|3,pmdfl|||; set dot flag non-zero|11299
||brn|6,succp|||; and succeed|11300
||ejc|||||11301
;
;      pattern assignment (remove assign entry)
;
;      see compound patterns description for the structure and
;      algorithms for matching this node type.
;
;      no parameters (dummy node)
;
|p_pad|ent||||; entry point|11310
||brn|6,flpop|||; fail and remove p_pac node|11311
||ejc|||||11312
;
;      rem
;
;      no parameters
;
|p_rem|ent|2,bl_p0|||; p0blk|11318
||mov|8,wb|3,pmssl||; point cursor to end of string|11319
||brn|6,succp|||; and succeed|11320
||ejc|||||11321
;
;      rpos (expression argument)
;
;      optimize rpos if it is the first pattern element,
;      unanchored mode, cursor is zero and rpos argument
;      is not beyond end of string.  force cursor position
;      and number of unanchored moves.
;
;      this optimization is performed invisibly provided
;      the argument is either a simple integer or an
;      expression that is an untraced variable (that is,
;      it has no side effects that would be lost by short-
;      circuiting the normal logic of failing and moving the
;      unanchored starting point).
;
;      parm1		     expression pointer
;
|p_rpd|ent|2,bl_p1|||; p1blk|11339
||jsr|6,evali|||; evaluate integer argument|11340
||err|1,052|26,rpos evaluated argument is not integer|||11341
||err|1,053|26,rpos evaluated argument is negative or too large|||11342
||ppm|6,failp|||; fail if evaluation fails|11343
||ppm|6,prps1|||; merge with normal case if ok|11344
;
|prps1|mov|8,wc|3,pmssl||; get length of string|11346
||sub|8,wc|8,wb||; get number of characters remaining|11347
||beq|8,wc|13,parm1(xr)|6,succp|; succeed if at right location|11348
||bnz|8,wb|6,failp||; don't look further if cursor not 0|11349
||bnz|3,evlif|6,failp||; fail if complex argument|11350
||mov|7,xt|3,pmhbs||; get history stack base ptr|11351
||mov|8,wa|3,evlio||; get original node ptr|11352
||bne|8,wa|11,-(xt)|6,failp|; fail if pos is not first node|11353
||brn|6,prps2|||; merge with integer arg code|11354
||ejc|||||11355
;
;      rpos (integer argument)
;
;      parm1		     integer argument
;
|p_rps|ent|2,bl_p1|||; p1blk|11361
;
;      rpos (integer argument)
;
;      parm1		     integer argument
;
||mov|8,wc|3,pmssl||; get length of string|11367
||sub|8,wc|8,wb||; get number of characters remaining|11368
||beq|8,wc|13,parm1(xr)|6,succp|; succeed if at right location|11369
||bnz|8,wb|6,failp||; don't look further if cursor not 0|11370
||mov|7,xt|3,pmhbs||; get history stack base ptr|11371
||bne|7,xr|11,-(xt)|6,failp|; fail if rpos is not first node|11372
;
;      expression argument merges here
;
|prps2|bne|11,-(xt)|21,=nduna|6,failp|; fail if not unanchored mode|11376
||mov|8,wb|3,pmssl||; point to end of string|11377
||blt|8,wb|13,parm1(xr)|6,failp|; fail if string not long enough|11378
||sub|8,wb|13,parm1(xr)||; else set new cursor|11379
||mov|13,num02(xt)|8,wb||; fake number of unanchored moves|11380
||brn|6,succp|||; continue match with adjusted cursor|11381
||ejc|||||11382
;
;      rtab (integer argument)
;
;      parm1		     integer argument
;
|p_rtb|ent|2,bl_p1|||; p1blk|11388
;
;      expression argument case merges here
;
|prtb1|mov|8,wc|8,wb||; save initial cursor|11392
||mov|8,wb|3,pmssl||; point to end of string|11393
||blt|8,wb|13,parm1(xr)|6,failp|; fail if string not long enough|11394
||sub|8,wb|13,parm1(xr)||; else set new cursor|11395
||bge|8,wb|8,wc|6,succp|; and succeed if not too far already|11396
||brn|6,failp|||; in which case, fail|11397
||ejc|||||11398
;
;      rtab (expression argument)
;
;      parm1		     expression pointer
;
|p_rtd|ent|2,bl_p1|||; p1blk|11404
||jsr|6,evali|||; evaluate integer argument|11405
||err|1,054|26,rtab evaluated argument is not integer|||11406
||err|1,055|26,rtab evaluated argument is negative or too large|||11407
||ppm|6,failp|||; fail if evaluation fails|11408
||ppm|6,prtb1|||; merge with normal case if success|11409
||ejc|||||11410
;
;      span (expression argument)
;
;      parm1		     expression pointer
;
|p_spd|ent|2,bl_p1|||; p1blk|11416
||jsr|6,evals|||; evaluate string argument|11417
||err|1,056|26,span evaluated argument is not a string|||11418
||ppm|6,failp|||; fail if evaluation fails|11419
||ppm|6,pspn1|||; merge with multi-char case if ok|11420
||ejc|||||11421
;
;      span (multi-character argument case)
;
;      parm1		     pointer to ctblk
;      parm2		     bit mask to select bit column
;
|p_spn|ent|2,bl_p2|||; p2blk|11428
;
;      expression argument case merges here
;
|pspn1|mov|8,wc|3,pmssl||; copy subject string length|11432
||sub|8,wc|8,wb||; calculate number of characters left|11433
||bze|8,wc|6,failp||; fail if no characters left|11434
||mov|7,xl|3,r_pms||; point to subject string|11435
||plc|7,xl|8,wb||; point to current character|11436
||mov|3,psavc|8,wb||; save initial cursor|11437
||mov|3,psave|7,xr||; save node pointer|11438
||lct|8,wc|8,wc||; set counter for chars left|11439
;
;      loop to scan matching characters
;
|pspn2|lch|8,wa|10,(xl)+||; load next character, bump pointer|11443
||wtb|8,wa|||; convert to byte offset|11444
||mov|7,xr|13,parm1(xr)||; point to ctblk|11445
||add|7,xr|8,wa||; point to ctblk entry|11446
||mov|8,wa|13,ctchs(xr)||; load ctblk entry|11447
||mov|7,xr|3,psave||; restore node pointer|11448
||anb|8,wa|13,parm2(xr)||; and with selected bit|11449
||zrb|8,wa|6,pspn3||; jump if no match|11450
||icv|8,wb|||; else push cursor|11451
||bct|8,wc|6,pspn2||; loop back unless end of string|11452
;
;      here after scanning matching characters
;
|pspn3|bne|8,wb|3,psavc|6,succp|; succeed if chars matched|11456
||brn|6,failp|||; else fail if null string matched|11457
||ejc|||||11458
;
;      span (one character argument)
;
;      parm1		     character argument
;
|p_sps|ent|2,bl_p1|||; p1blk|11464
||mov|8,wc|3,pmssl||; get subject string length|11465
||sub|8,wc|8,wb||; calculate number of characters left|11466
||bze|8,wc|6,failp||; fail if no characters left|11467
||mov|7,xl|3,r_pms||; else point to subject string|11468
||plc|7,xl|8,wb||; point to current character|11469
||mov|3,psavc|8,wb||; save initial cursor|11470
||lct|8,wc|8,wc||; set counter for characters left|11471
;
;      loop to scan matching characters
;
|psps1|lch|8,wa|10,(xl)+||; load next character, bump pointer|11475
||bne|8,wa|13,parm1(xr)|6,psps2|; jump if no match|11476
||icv|8,wb|||; else push cursor|11477
||bct|8,wc|6,psps1||; and loop unless end of string|11478
;
;      here after scanning matching characters
;
|psps2|bne|8,wb|3,psavc|6,succp|; succeed if chars matched|11482
||brn|6,failp|||; fail if null string matched|11483
||ejc|||||11484
;
;      multi-character string
;
;      note that one character strings use the circuit for
;      one character any arguments (p_an1).
;
;      parm1		     pointer to scblk for string arg
;
|p_str|ent|2,bl_p1|||; p1blk|11493
||mov|7,xl|13,parm1(xr)||; get pointer to string|11494
;
;      merge here after evaluating expression with string value
;
|pstr1|mov|3,psave|7,xr||; save node pointer|11498
||mov|7,xr|3,r_pms||; load subject string pointer|11499
||plc|7,xr|8,wb||; point to current character|11500
||add|8,wb|13,sclen(xl)||; compute new cursor position|11501
||bgt|8,wb|3,pmssl|6,failp|; fail if past end of string|11502
||mov|3,psavc|8,wb||; save updated cursor|11503
||mov|8,wa|13,sclen(xl)||; get number of chars to compare|11504
||plc|7,xl|||; point to chars of test string|11505
||cmc|6,failp|6,failp||; compare, fail if not equal|11506
||mov|7,xr|3,psave||; if all matched, restore node ptr|11507
||mov|8,wb|3,psavc||; restore updated cursor|11508
||brn|6,succp|||; and succeed|11509
||ejc|||||11510
;
;      succeed
;
;      see section on compound patterns for details of the
;      structure and algorithms for matching this node type
;
;      no parameters
;
|p_suc|ent|2,bl_p0|||; p0blk|11519
||mov|11,-(xs)|8,wb||; stack cursor|11520
||mov|11,-(xs)|7,xr||; stack pointer to this node|11521
||brn|6,succp|||; succeed matching null|11522
||ejc|||||11523
;
;      tab (integer argument)
;
;      parm1		     integer argument
;
|p_tab|ent|2,bl_p1|||; p1blk|11529
;
;      expression argument case merges here
;
|ptab1|bgt|8,wb|13,parm1(xr)|6,failp|; fail if too far already|11533
||mov|8,wb|13,parm1(xr)||; else set new cursor position|11534
||ble|8,wb|3,pmssl|6,succp|; succeed if not off end|11535
||brn|6,failp|||; else fail|11536
||ejc|||||11537
;
;      tab (expression argument)
;
;      parm1		     expression pointer
;
|p_tbd|ent|2,bl_p1|||; p1blk|11543
||jsr|6,evali|||; evaluate integer argument|11544
||err|1,057|26,tab evaluated argument is not integer|||11545
||err|1,058|26,tab evaluated argument is negative or too large|||11546
||ppm|6,failp|||; fail if evaluation fails|11547
||ppm|6,ptab1|||; merge with normal case if ok|11548
||ejc|||||11549
;
;      anchor movement
;
;      no parameters (dummy node)
;
|p_una|ent||||; entry point|11555
||mov|7,xr|8,wb||; copy initial pattern node pointer|11556
||mov|8,wb|9,(xs)||; get initial cursor|11557
||beq|8,wb|3,pmssl|6,exfal|; match fails if at end of string|11558
||icv|8,wb|||; else increment cursor|11559
||mov|9,(xs)|8,wb||; store incremented cursor|11560
||mov|11,-(xs)|7,xr||; restack initial node ptr|11561
||mov|11,-(xs)|21,=nduna||; restack unanchored node|11562
||bri|9,(xr)|||; rematch first node|11563
||ejc|||||11564
;
;      end of pattern match routines
;
;      the following entry point marks the end of the pattern
;      matching routines and also the end of the entry points
;      referenced from the first word of blocks in dynamic store
;
|p_yyy|ent|2,bl__i|||; mark last entry in pattern section|11572
||ttl|27,s p i t b o l -- snobol4 built-in label routines||||11573
;
;      the following section contains the routines for labels
;      which have a predefined meaning in snobol4.
;
;      control is passed directly to the label name entry point.
;
;      entry names are of the form l_xxx where xxx is the three
;      letter variable name identifier.
;
;      entries are in alphabetical order
||ejc|||||11584
;
;      abort
;
|l_abo|ent||||; entry point|11588
;
;      merge here if execution terminates in error
;
|labo1|mov|8,wa|3,kvert||; load error code|11592
||bze|8,wa|6,labo3||; jump if no error has occured|11593
||jsr|6,sysax|||; call after execution proc|11595
||mov|8,wc|3,kvstn||; current statement|11599
||jsr|6,filnm|||; obtain file name for this statement|11600
||mov|7,xr|3,r_cod||; current code block|11603
||mov|8,wc|13,cdsln(xr)||; line number|11604
||zer|8,wb|||; column number|11608
||mov|7,xr|3,stage||;|11609
||jsr|6,sysea|||; advise system of error|11610
||ppm|6,stpr4|||; if system does not want print|11611
||jsr|6,prtpg|||; else eject printer|11613
||bze|7,xr|6,labo2||; did sysea request print|11615
||jsr|6,prtst|||; print text from sysea|11616
|labo2|jsr|6,ermsg|||; print error message|11618
||zer|7,xr|||; indicate no message to print|11619
||brn|6,stopr|||; jump to routine to stop run|11620
;
;      here if no error had occured
;
|labo3|erb|1,036|26,goto abort with no preceding error|||11624
||ejc|||||11625
;
;      continue
;
|l_cnt|ent||||; entry point|11629
;
;      merge here after execution error
;
|lcnt1|mov|7,xr|3,r_cnt||; load continuation code block ptr|11633
||bze|7,xr|6,lcnt3||; jump if no previous error|11634
||zer|3,r_cnt|||; clear flag|11635
||mov|3,r_cod|7,xr||; else store as new code block ptr|11636
||bne|9,(xr)|22,=b_cdc|6,lcnt2|; jump if not complex go|11637
||mov|8,wa|3,stxoc||; get offset of error|11638
||bge|8,wa|3,stxof|6,lcnt4|; jump if error in goto evaluation|11639
;
;      here if error did not occur in complex failure goto
;
|lcnt2|add|7,xr|3,stxof||; add failure offset|11643
||lcp|7,xr|||; load code pointer|11644
||mov|7,xs|3,flptr||; reset stack pointer|11645
||lcw|7,xr|||; get next code word|11646
||bri|9,(xr)|||; execute next code word|11647
;
;      here if no previous error
;
|lcnt3|icv|3,errft|||; fatal error|11651
||erb|1,037|26,goto continue with no preceding error|||11652
;
;      here if error in evaluation of failure goto.
;      cannot continue back to failure goto!
;
|lcnt4|icv|3,errft|||; fatal error|11657
||erb|1,332|26,goto continue with error in failure goto|||11658
||ejc|||||11659
;
;      end
;
|l_end|ent||||; entry point|11663
;
;      merge here from end code circuit
;
|lend0|mov|7,xr|21,=endms||; point to message /normal term.../|11667
||brn|6,stopr|||; jump to routine to stop run|11668
||ejc|||||11669
;
;      freturn
;
|l_frt|ent||||; entry point|11673
||mov|8,wa|21,=scfrt||; point to string /freturn/|11674
||brn|6,retrn|||; jump to common return routine|11675
||ejc|||||11676
;
;      nreturn
;
|l_nrt|ent||||; entry point|11680
||mov|8,wa|21,=scnrt||; point to string /nreturn/|11681
||brn|6,retrn|||; jump to common return routine|11682
||ejc|||||11683
;
;      return
;
|l_rtn|ent||||; entry point|11687
||mov|8,wa|21,=scrtn||; point to string /return/|11688
||brn|6,retrn|||; jump to common return routine|11689
||ejc|||||11690
;
;      scontinue
;
|l_scn|ent||||; entry point|11694
||mov|7,xr|3,r_cnt||; load continuation code block ptr|11695
||bze|7,xr|6,lscn2||; jump if no previous error|11696
||zer|3,r_cnt|||; clear flag|11697
||bne|3,kvert|18,=nm320|6,lscn1|; error must be user interrupt|11698
||beq|3,kvert|18,=nm321|6,lscn2|; detect scontinue loop|11699
||mov|3,r_cod|7,xr||; else store as new code block ptr|11700
||add|7,xr|3,stxoc||; add resume offset|11701
||lcp|7,xr|||; load code pointer|11702
||lcw|7,xr|||; get next code word|11703
||bri|9,(xr)|||; execute next code word|11704
;
;      here if no user interrupt
;
|lscn1|icv|3,errft|||; fatal error|11708
||erb|1,331|26,goto scontinue with no user interrupt|||11709
;
;      here if in scontinue loop or if no previous error
;
|lscn2|icv|3,errft|||; fatal error|11713
||erb|1,321|26,goto scontinue with no preceding error|||11714
||ejc|||||11715
;
;      undefined label
;
|l_und|ent||||; entry point|11719
||erb|1,038|26,goto undefined label|||11720
||ttl|27,s p i t b o l -- predefined snobol4 functions||||11721
;
;      the following section contains coding for functions
;      which are predefined and available at the snobol level.
;
;      these routines receive control directly from the code or
;      indirectly through the o_fnc, o_fns or cfunc routines.
;      in both cases the conditions on entry are as follows
;
;      the arguments are on the stack. the number of arguments
;      has been adjusted to correspond to the svblk svnar field.
;
;      in certain functions the direct call is not permitted
;      and in these instances we also have.
;
;      (wa)		     actual number of arguments in call
;
;      control returns by placing the function result value on
;      on the stack and continuing execution with the next
;      word from the generated code.
;
;      the names of the entry points of these functions are of
;      the form s_xxx where xxx is the three letter code for
;      the system variable name. the functions are in order
;      alphabetically by their entry names.
||ejc|||||11746
;
;      any
;
|s_any|ent||||; entry point|11800
||mov|8,wb|22,=p_ans||; set pcode for single char case|11801
||mov|7,xl|22,=p_any||; pcode for multi-char case|11802
||mov|8,wc|22,=p_ayd||; pcode for expression case|11803
||jsr|6,patst|||; call common routine to build node|11804
||err|1,059|26,any argument is not a string or expression|||11805
||mov|11,-(xs)|7,xr||; stack result|11806
||lcw|7,xr|||; get next code word|11807
||bri|9,(xr)|||; execute it|11808
||ejc|||||11809
;
;      apply
;
;      apply does not permit the direct (fast) call so that
;      wa contains the actual number of arguments passed.
;
|s_app|ent||||; entry point|11835
||bze|8,wa|6,sapp3||; jump if no arguments|11836
||dcv|8,wa|||; else get applied func arg count|11837
||mov|8,wb|8,wa||; copy|11838
||wtb|8,wb|||; convert to bytes|11839
||mov|7,xt|7,xs||; copy stack pointer|11840
||add|7,xt|8,wb||; point to function argument on stack|11841
||mov|7,xr|9,(xt)||; load function ptr (apply 1st arg)|11842
||bze|8,wa|6,sapp2||; jump if no args for applied func|11843
||lct|8,wb|8,wa||; else set counter for loop|11844
;
;      loop to move arguments up on stack
;
|sapp1|dca|7,xt|||; point to next argument|11848
||mov|13,num01(xt)|9,(xt)||; move argument up|11849
||bct|8,wb|6,sapp1||; loop till all moved|11850
;
;      merge here to call function (wa = number of arguments)
;
|sapp2|ica|7,xs|||; adjust stack ptr for apply 1st arg|11854
||jsr|6,gtnvr|||; get variable block addr for func|11855
||ppm|6,sapp3|||; jump if not natural variable|11856
||mov|7,xl|13,vrfnc(xr)||; else point to function block|11857
||brn|6,cfunc|||; go call applied function|11858
;
;      here for invalid first argument
;
|sapp3|erb|1,060|26,apply first arg is not natural variable name|||11862
||ejc|||||11863
;
;      arbno
;
;      arbno builds a compound pattern. see description at
;      start of pattern matching section for structure formed.
;
|s_abn|ent||||; entry point|11870
||zer|7,xr|||; set parm1 = 0 for the moment|11871
||mov|8,wb|22,=p_alt||; set pcode for alternative node|11872
||jsr|6,pbild|||; build alternative node|11873
||mov|7,xl|7,xr||; save ptr to alternative pattern|11874
||mov|8,wb|22,=p_abc||; pcode for p_abc|11875
||zer|7,xr|||; p0blk|11876
||jsr|6,pbild|||; build p_abc node|11877
||mov|13,pthen(xr)|7,xl||; put alternative node as successor|11878
||mov|8,wa|7,xl||; remember alternative node pointer|11879
||mov|7,xl|7,xr||; copy p_abc node ptr|11880
||mov|7,xr|9,(xs)||; load arbno argument|11881
||mov|9,(xs)|8,wa||; stack alternative node pointer|11882
||jsr|6,gtpat|||; get arbno argument as pattern|11883
||err|1,061|26,arbno argument is not pattern|||11884
||jsr|6,pconc|||; concat arg with p_abc node|11885
||mov|7,xl|7,xr||; remember ptr to concd patterns|11886
||mov|8,wb|22,=p_aba||; pcode for p_aba|11887
||zer|7,xr|||; p0blk|11888
||jsr|6,pbild|||; build p_aba node|11889
||mov|13,pthen(xr)|7,xl||; concatenate nodes|11890
||mov|7,xl|9,(xs)||; recall ptr to alternative node|11891
||mov|13,parm1(xl)|7,xr||; point alternative back to argument|11892
||lcw|7,xr|||; get next code word|11893
||bri|9,(xr)|||; execute next code word|11894
||ejc|||||11895
;
;      arg
;
|s_arg|ent||||; entry point|11899
||jsr|6,gtsmi|||; get second arg as small integer|11900
||err|1,062|26,arg second argument is not integer|||11901
||ppm|6,exfal|||; fail if out of range or negative|11902
||mov|8,wa|7,xr||; save argument number|11903
||mov|7,xr|10,(xs)+||; load first argument|11904
||jsr|6,gtnvr|||; locate vrblk|11905
||ppm|6,sarg1|||; jump if not natural variable|11906
||mov|7,xr|13,vrfnc(xr)||; else load function block pointer|11907
||bne|9,(xr)|22,=b_pfc|6,sarg1|; jump if not program defined|11908
||bze|8,wa|6,exfal||; fail if arg number is zero|11909
||bgt|8,wa|13,fargs(xr)|6,exfal|; fail if arg number is too large|11910
||wtb|8,wa|||; else convert to byte offset|11911
||add|7,xr|8,wa||; point to argument selected|11912
||mov|7,xr|13,pfagb(xr)||; load argument vrblk pointer|11913
||brn|6,exvnm|||; exit to build nmblk|11914
;
;      here if 1st argument is bad
;
|sarg1|erb|1,063|26,arg first argument is not program function name|||11918
||ejc|||||11919
;
;      array
;
|s_arr|ent||||; entry point|11923
||mov|7,xl|10,(xs)+||; load initial element value|11924
||mov|7,xr|10,(xs)+||; load first argument|11925
||jsr|6,gtint|||; convert first arg to integer|11926
||ppm|6,sar02|||; jump if not integer|11927
;
;      here for integer first argument, build vcblk
;
||ldi|13,icval(xr)|||; load integer value|11931
||ile|6,sar10|||; jump if zero or neg (bad dimension)|11932
||mfi|8,wa|6,sar11||; else convert to one word, test ovfl|11933
||jsr|6,vmake|||; create vector|11934
||ppm|6,sar11|||; fail if too large|11935
||brn|6,exsid|||; exit setting idval|11936
||ejc|||||11937
;
;      array (continued)
;
;      here if first argument is not an integer
;
|sar02|mov|11,-(xs)|7,xr||; replace argument on stack|11943
||jsr|6,xscni|||; initialize scan of first argument|11944
||err|1,064|26,array first argument is not integer or string|||11945
||ppm|6,exnul|||; dummy (unused) null string exit|11946
||mov|11,-(xs)|3,r_xsc||; save prototype pointer|11947
||mov|11,-(xs)|7,xl||; save default value|11948
||zer|3,arcdm|||; zero count of dimensions|11949
||zer|3,arptr|||; zero offset to indicate pass one|11950
||ldi|4,intv1|||; load integer one|11951
||sti|3,arnel|||; initialize element count|11952
;
;      the following code is executed twice. the first time
;      (arptr eq 0), it is used to count the number of elements
;      and number of dimensions. the second time (arptr gt 0) is
;      used to actually fill in the dim,lbd fields of the arblk.
;
|sar03|ldi|4,intv1|||; load one as default low bound|11959
||sti|3,arsvl|||; save as low bound|11960
||mov|8,wc|18,=ch_cl||; set delimiter one = colon|11961
||mov|7,xl|18,=ch_cm||; set delimiter two = comma|11962
||zer|8,wa|||; retain blanks in prototype|11963
||jsr|6,xscan|||; scan next bound|11964
||bne|8,wa|18,=num01|6,sar04|; jump if not colon|11965
;
;      here we have a colon ending a low bound
;
||jsr|6,gtint|||; convert low bound|11969
||err|1,065|26,array first argument lower bound is not integer|||11970
||ldi|13,icval(xr)|||; load value of low bound|11971
||sti|3,arsvl|||; store low bound value|11972
||mov|8,wc|18,=ch_cm||; set delimiter one = comma|11973
||mov|7,xl|8,wc||; and delimiter two = comma|11974
||zer|8,wa|||; retain blanks in prototype|11975
||jsr|6,xscan|||; scan high bound|11976
||ejc|||||11977
;
;      array (continued)
;
;      merge here to process upper bound
;
|sar04|jsr|6,gtint|||; convert high bound to integer|11983
||err|1,066|26,array first argument upper bound is not integer|||11984
||ldi|13,icval(xr)|||; get high bound|11985
||sbi|3,arsvl|||; subtract lower bound|11986
||iov|6,sar10|||; bad dimension if overflow|11987
||ilt|6,sar10|||; bad dimension if negative|11988
||adi|4,intv1|||; add 1 to get dimension|11989
||iov|6,sar10|||; bad dimension if overflow|11990
||mov|7,xl|3,arptr||; load offset (also pass indicator)|11991
||bze|7,xl|6,sar05||; jump if first pass|11992
;
;      here in second pass to store lbd and dim in arblk
;
||add|7,xl|9,(xs)||; point to current location in arblk|11996
||sti|13,cfp_i(xl)|||; store dimension|11997
||ldi|3,arsvl|||; load low bound|11998
||sti|9,(xl)|||; store low bound|11999
||add|3,arptr|19,*ardms||; bump offset to next bounds|12000
||brn|6,sar06|||; jump to check for end of bounds|12001
;
;      here in pass 1
;
|sar05|icv|3,arcdm|||; bump dimension count|12005
||mli|3,arnel|||; multiply dimension by count so far|12006
||iov|6,sar11|||; too large if overflow|12007
||sti|3,arnel|||; else store updated element count|12008
;
;      merge here after processing one set of bounds
;
|sar06|bnz|8,wa|6,sar03||; loop back unless end of bounds|12012
||bnz|3,arptr|6,sar09||; jump if end of pass 2|12013
||ejc|||||12014
;
;      array (continued)
;
;      here at end of pass one, build arblk
;
||ldi|3,arnel|||; get number of elements|12020
||mfi|8,wb|6,sar11||; get as addr integer, test ovflo|12021
||wtb|8,wb|||; else convert to length in bytes|12022
||mov|8,wa|19,*arsi_||; set size of standard fields|12023
||lct|8,wc|3,arcdm||; set dimension count to control loop|12024
;
;      loop to allow space for dimensions
;
|sar07|add|8,wa|19,*ardms||; allow space for one set of bounds|12028
||bct|8,wc|6,sar07||; loop back till all accounted for|12029
||mov|7,xl|8,wa||; save size (=arofs)|12030
;
;      now allocate space for arblk
;
||add|8,wa|8,wb||; add space for elements|12034
||ica|8,wa|||; allow for arpro prototype field|12035
||bgt|8,wa|3,mxlen|6,sar11|; fail if too large|12036
||jsr|6,alloc|||; else allocate arblk|12037
||mov|8,wb|9,(xs)||; load default value|12038
||mov|9,(xs)|7,xr||; save arblk pointer|12039
||mov|8,wc|8,wa||; save length in bytes|12040
||btw|8,wa|||; convert length back to words|12041
||lct|8,wa|8,wa||; set counter to control loop|12042
;
;      loop to clear entire arblk to default value
;
|sar08|mov|10,(xr)+|8,wb||; set one word|12046
||bct|8,wa|6,sar08||; loop till all set|12047
||ejc|||||12048
;
;      array (continued)
;
;      now set initial fields of arblk
;
||mov|7,xr|10,(xs)+||; reload arblk pointer|12054
||mov|8,wb|9,(xs)||; load prototype|12055
||mov|9,(xr)|22,=b_art||; set type word|12056
||mov|13,arlen(xr)|8,wc||; store length in bytes|12057
||zer|13,idval(xr)|||; zero id till we get it built|12058
||mov|13,arofs(xr)|7,xl||; set prototype field ptr|12059
||mov|13,arndm(xr)|3,arcdm||; set number of dimensions|12060
||mov|8,wc|7,xr||; save arblk pointer|12061
||add|7,xr|7,xl||; point to prototype field|12062
||mov|9,(xr)|8,wb||; store prototype ptr in arblk|12063
||mov|3,arptr|19,*arlbd||; set offset for pass 2 bounds scan|12064
||mov|3,r_xsc|8,wb||; reset string pointer for xscan|12065
||mov|9,(xs)|8,wc||; store arblk pointer on stack|12066
||zer|3,xsofs|||; reset offset ptr to start of string|12067
||brn|6,sar03|||; jump back to rescan bounds|12068
;
;      here after filling in bounds information (end pass two)
;
|sar09|mov|7,xr|10,(xs)+||; reload pointer to arblk|12072
||brn|6,exsid|||; exit setting idval|12073
;
;      here for bad dimension
;
|sar10|erb|1,067|26,array dimension is zero, negative or out of range|||12077
;
;      here if array is too large
;
|sar11|erb|1,068|26,array size exceeds maximum permitted|||12081
||ejc|||||12082
;
;      atan
;
|s_atn|ent||||; entry point|12087
||mov|7,xr|10,(xs)+||; get argument|12088
||jsr|6,gtrea|||; convert to real|12089
||err|1,301|26,atan argument not numeric|||12090
||ldr|13,rcval(xr)|||; load accumulator with argument|12091
||atn||||; take arctangent|12092
||brn|6,exrea|||; overflow, out of range not possible|12093
||ejc|||||12094
||ejc|||||12097
;
;      backspace
;
|s_bsp|ent||||; entry point|12101
||jsr|6,iofcb|||; call fcblk routine|12102
||err|1,316|26,backspace argument is not a suitable name|||12103
||err|1,316|26,backspace argument is not a suitable name|||12104
||err|1,317|26,backspace file does not exist|||12105
||jsr|6,sysbs|||; call backspace file function|12106
||err|1,317|26,backspace file does not exist|||12107
||err|1,318|26,backspace file does not permit backspace|||12108
||err|1,319|26,backspace caused non-recoverable error|||12109
||brn|6,exnul|||; return null as result|12110
||ejc|||||12111
;
;      break
;
|s_brk|ent||||; entry point|12144
||mov|8,wb|22,=p_bks||; set pcode for single char case|12145
||mov|7,xl|22,=p_brk||; pcode for multi-char case|12146
||mov|8,wc|22,=p_bkd||; pcode for expression case|12147
||jsr|6,patst|||; call common routine to build node|12148
||err|1,069|26,break argument is not a string or expression|||12149
||mov|11,-(xs)|7,xr||; stack result|12150
||lcw|7,xr|||; get next code word|12151
||bri|9,(xr)|||; execute it|12152
||ejc|||||12153
;
;      breakx
;
;      breakx is a compound pattern. see description at start
;      of pattern matching section for structure formed.
;
|s_bkx|ent||||; entry point|12160
||mov|8,wb|22,=p_bks||; pcode for single char argument|12161
||mov|7,xl|22,=p_brk||; pcode for multi-char argument|12162
||mov|8,wc|22,=p_bxd||; pcode for expression case|12163
||jsr|6,patst|||; call common routine to build node|12164
||err|1,070|26,breakx argument is not a string or expression|||12165
;
;      now hook breakx node on at front end
;
||mov|11,-(xs)|7,xr||; save ptr to break node|12169
||mov|8,wb|22,=p_bkx||; set pcode for breakx node|12170
||jsr|6,pbild|||; build it|12171
||mov|13,pthen(xr)|9,(xs)||; set break node as successor|12172
||mov|8,wb|22,=p_alt||; set pcode for alternation node|12173
||jsr|6,pbild|||; build (parm1=alt=breakx node)|12174
||mov|8,wa|7,xr||; save ptr to alternation node|12175
||mov|7,xr|9,(xs)||; point to break node|12176
||mov|13,pthen(xr)|8,wa||; set alternate node as successor|12177
||lcw|7,xr|||; result on stack|12178
||bri|9,(xr)|||; execute next code word|12179
||ejc|||||12180
;
;      char
;
|s_chr|ent||||; entry point|12184
||jsr|6,gtsmi|||; convert arg to integer|12185
||err|1,281|26,char argument not integer|||12186
||ppm|6,schr1|||; too big error exit|12187
||bge|8,wc|18,=cfp_a|6,schr1|; see if out of range of host set|12188
||mov|8,wa|18,=num01||; if not set scblk allocation|12189
||mov|8,wb|8,wc||; save char code|12190
||jsr|6,alocs|||; allocate 1 bau scblk|12191
||mov|7,xl|7,xr||; copy scblk pointer|12192
||psc|7,xl|||; get set to stuff char|12193
||sch|8,wb|9,(xl)||; stuff it|12194
||csc|7,xl|||; complete store character|12195
||zer|7,xl|||; clear slop in xl|12196
||mov|11,-(xs)|7,xr||; stack result|12197
||lcw|7,xr|||; get next code word|12198
||bri|9,(xr)|||; execute it|12199
;
;      here if char argument is out of range
;
|schr1|erb|1,282|26,char argument not in range|||12203
||ejc|||||12204
;
;      chop
;
|s_chp|ent||||; entry point|12209
||mov|7,xr|10,(xs)+||; get argument|12210
||jsr|6,gtrea|||; convert to real|12211
||err|1,302|26,chop argument not numeric|||12212
||ldr|13,rcval(xr)|||; load accumulator with argument|12213
||chp||||; truncate to integer valued real|12214
||brn|6,exrea|||; no overflow possible|12215
||ejc|||||12216
;
;      clear
;
|s_clr|ent||||; entry point|12221
||jsr|6,xscni|||; initialize to scan argument|12222
||err|1,071|26,clear argument is not a string|||12223
||ppm|6,sclr2|||; jump if null|12224
;
;      loop to scan out names in first argument. variables in
;      the list are flagged by setting vrget of vrblk to zero.
;
|sclr1|mov|8,wc|18,=ch_cm||; set delimiter one = comma|12229
||mov|7,xl|8,wc||; delimiter two = comma|12230
||mnz|8,wa|||; skip/trim blanks in prototype|12231
||jsr|6,xscan|||; scan next variable name|12232
||jsr|6,gtnvr|||; locate vrblk|12233
||err|1,072|26,clear argument has null variable name|||12234
||zer|13,vrget(xr)|||; else flag by zeroing vrget field|12235
||bnz|8,wa|6,sclr1||; loop back if stopped by comma|12236
;
;      here after flagging variables in argument list
;
|sclr2|mov|8,wb|3,hshtb||; point to start of hash table|12240
;
;      loop through slots in hash table
;
|sclr3|beq|8,wb|3,hshte|6,exnul|; exit returning null if none left|12244
||mov|7,xr|8,wb||; else copy slot pointer|12245
||ica|8,wb|||; bump slot pointer|12246
||sub|7,xr|19,*vrnxt||; set offset to merge into loop|12247
;
;      loop through vrblks on one hash chain
;
|sclr4|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain|12251
||bze|7,xr|6,sclr3||; jump for next bucket if chain end|12252
||bnz|13,vrget(xr)|6,sclr5||; jump if not flagged|12253
||ejc|||||12254
;
;      clear (continued)
;
;      here for flagged variable, do not set value to null
;
||jsr|6,setvr|||; for flagged var, restore vrget|12260
||brn|6,sclr4|||; and loop back for next vrblk|12261
;
;      here to set value of a variable to null
;      protected variables (arb, etc) are exempt
;
|sclr5|beq|13,vrsto(xr)|22,=b_vre|6,sclr4|; check for protected variable|12266
||mov|7,xl|7,xr||; copy vrblk pointer|12267
;
;      loop to locate value at end of possible trblk chain
;
|sclr6|mov|8,wa|7,xl||; save block pointer|12271
||mov|7,xl|13,vrval(xl)||; load next value field|12272
||beq|9,(xl)|22,=b_trt|6,sclr6|; loop back if trapped|12273
;
;      now store the null value
;
||mov|7,xl|8,wa||; restore block pointer|12277
||mov|13,vrval(xl)|21,=nulls||; store null constant value|12278
||brn|6,sclr4|||; loop back for next vrblk|12279
||ejc|||||12280
;
;      code
;
|s_cod|ent||||; entry point|12284
||mov|7,xr|10,(xs)+||; load argument|12285
||jsr|6,gtcod|||; convert to code|12286
||ppm|6,exfal|||; fail if conversion is impossible|12287
||mov|11,-(xs)|7,xr||; stack result|12288
||zer|3,r_ccb|||; forget interim code block|12289
||lcw|7,xr|||; get next code word|12290
||bri|9,(xr)|||; execute it|12291
||ejc|||||12292
;
;      collect
;
|s_col|ent||||; entry point|12296
||mov|7,xr|10,(xs)+||; load argument|12297
||jsr|6,gtint|||; convert to integer|12298
||err|1,073|26,collect argument is not integer|||12299
||ldi|13,icval(xr)|||; load collect argument|12300
||sti|3,clsvi|||; save collect argument|12301
||zer|8,wb|||; set no move up|12302
||zer|3,r_ccb|||; forget interim code block|12303
||zer|3,dnams|||; collect sediment too|12305
||jsr|6,gbcol|||; perform garbage collection|12306
||mov|3,dnams|7,xr||; record new sediment size|12307
||mov|8,wa|3,dname||; point to end of memory|12311
||sub|8,wa|3,dnamp||; subtract next location|12312
||btw|8,wa|||; convert bytes to words|12313
||mti|8,wa|||; convert words available as integer|12314
||sbi|3,clsvi|||; subtract argument|12315
||iov|6,exfal|||; fail if overflow|12316
||ilt|6,exfal|||; fail if not enough|12317
||adi|3,clsvi|||; else recompute available|12318
||brn|6,exint|||; and exit with integer result|12319
||ejc|||||12320
;
;      convert
;
|s_cnv|ent||||; entry point|12349
||jsr|6,gtstg|||; convert second argument to string|12350
||ppm|6,scv29|||; error if second argument not string|12351
||bze|8,wa|6,scv29||; or if null string|12352
||jsr|6,flstg|||; fold lower case to upper case|12354
||mov|7,xl|9,(xs)||; load first argument|12356
||bne|9,(xl)|22,=b_pdt|6,scv01|; jump if not program defined|12357
;
;      here for program defined datatype
;
||mov|7,xl|13,pddfp(xl)||; point to dfblk|12361
||mov|7,xl|13,dfnam(xl)||; load datatype name|12362
||jsr|6,ident|||; compare with second arg|12363
||ppm|6,exits|||; exit if ident with arg as result|12364
||brn|6,exfal|||; else fail|12365
;
;      here if not program defined datatype
;
|scv01|mov|11,-(xs)|7,xr||; save string argument|12369
||mov|7,xl|21,=svctb||; point to table of names to compare|12370
||zer|8,wb|||; initialize counter|12371
||mov|8,wc|8,wa||; save length of argument string|12372
;
;      loop through table entries
;
|scv02|mov|7,xr|10,(xl)+||; load next table entry, bump pointer|12376
||bze|7,xr|6,exfal||; fail if zero marking end of list|12377
||bne|8,wc|13,sclen(xr)|6,scv05|; jump if wrong length|12378
||mov|3,cnvtp|7,xl||; else store table pointer|12379
||plc|7,xr|||; point to chars of table entry|12380
||mov|7,xl|9,(xs)||; load pointer to string argument|12381
||plc|7,xl|||; point to chars of string arg|12382
||mov|8,wa|8,wc||; set number of chars to compare|12383
||cmc|6,scv04|6,scv04||; compare, jump if no match|12384
||ejc|||||12385
;
;      convert (continued)
;
;      here we have a match
;
|scv03|mov|7,xl|8,wb||; copy entry number|12391
||ica|7,xs|||; pop string arg off stack|12392
||mov|7,xr|10,(xs)+||; load first argument|12393
||bsw|7,xl|2,cnvtt||; jump to appropriate routine|12394
||iff|1,0|6,scv06||; string|12412
||iff|1,1|6,scv07||; integer|12412
||iff|1,2|6,scv09||; name|12412
||iff|1,3|6,scv10||; pattern|12412
||iff|1,4|6,scv11||; array|12412
||iff|1,5|6,scv19||; table|12412
||iff|1,6|6,scv25||; expression|12412
||iff|1,7|6,scv26||; code|12412
||iff|1,8|6,scv27||; numeric|12412
||iff|2,cnvrt|6,scv08||; real|12412
||esw||||; end of switch table|12412
;
;      here if no match with table entry
;
|scv04|mov|7,xl|3,cnvtp||; restore table pointer, merge|12416
;
;      merge here if lengths did not match
;
|scv05|icv|8,wb|||; bump entry number|12420
||brn|6,scv02|||; loop back to check next entry|12421
;
;      here to convert to string
;
|scv06|mov|11,-(xs)|7,xr||; replace string argument on stack|12425
||jsr|6,gtstg|||; convert to string|12426
||ppm|6,exfal|||; fail if conversion not possible|12427
||mov|11,-(xs)|7,xr||; stack result|12428
||lcw|7,xr|||; get next code word|12429
||bri|9,(xr)|||; execute it|12430
||ejc|||||12431
;
;      convert (continued)
;
;      here to convert to integer
;
|scv07|jsr|6,gtint|||; convert to integer|12437
||ppm|6,exfal|||; fail if conversion not possible|12438
||mov|11,-(xs)|7,xr||; stack result|12439
||lcw|7,xr|||; get next code word|12440
||bri|9,(xr)|||; execute it|12441
;
;      here to convert to real
;
|scv08|jsr|6,gtrea|||; convert to real|12447
||ppm|6,exfal|||; fail if conversion not possible|12448
||mov|11,-(xs)|7,xr||; stack result|12449
||lcw|7,xr|||; get next code word|12450
||bri|9,(xr)|||; execute it|12451
;
;      here to convert to name
;
|scv09|beq|9,(xr)|22,=b_nml|6,exixr|; return if already a name|12456
||jsr|6,gtnvr|||; else try string to name convert|12457
||ppm|6,exfal|||; fail if conversion not possible|12458
||brn|6,exvnm|||; else exit building nmblk for vrblk|12459
;
;      here to convert to pattern
;
|scv10|jsr|6,gtpat|||; convert to pattern|12463
||ppm|6,exfal|||; fail if conversion not possible|12464
||mov|11,-(xs)|7,xr||; stack result|12465
||lcw|7,xr|||; get next code word|12466
||bri|9,(xr)|||; execute it|12467
;
;      convert to array
;
;      if the first argument is a table, then we go through
;      an intermediate array of addresses that is sorted to
;      provide a result ordered by time of entry in the
;      original table.	see c3.762.
;
|scv11|mov|11,-(xs)|7,xr||; save argument on stack|12476
||zer|8,wa|||; use table chain block addresses|12477
||jsr|6,gtarr|||; get an array|12478
||ppm|6,exfal|||; fail if empty table|12479
||ppm|6,exfal|||; fail if not convertible|12480
||mov|7,xl|10,(xs)+||; reload original arg|12481
||bne|9,(xl)|22,=b_tbt|6,exsid|; exit if original not a table|12482
||mov|11,-(xs)|7,xr||; sort the intermediate array|12483
||mov|11,-(xs)|21,=nulls||; on first column|12484
||zer|8,wa|||; sort ascending|12485
||jsr|6,sorta|||; do sort|12486
||ppm|6,exfal|||; if sort fails, so shall we|12487
||mov|8,wb|7,xr||; save array result|12488
||ldi|13,ardim(xr)|||; load dim 1 (number of elements)|12489
||mfi|8,wa|||; get as one word integer|12490
||lct|8,wa|8,wa||; copy to control loop|12491
||add|7,xr|19,*arvl2||; point to first element in array|12492
;
;      here for each row of this 2-column array
;
|scv12|mov|7,xl|9,(xr)||; get teblk address|12496
||mov|10,(xr)+|13,tesub(xl)||; replace with subscript|12497
||mov|10,(xr)+|13,teval(xl)||; replace with value|12498
||bct|8,wa|6,scv12||; loop till all copied over|12499
||mov|7,xr|8,wb||; retrieve array address|12500
||brn|6,exsid|||; exit setting id field|12501
;
;      convert to table
;
|scv19|mov|8,wa|9,(xr)||; load first word of block|12505
||mov|11,-(xs)|7,xr||; replace arblk pointer on stack|12506
||beq|8,wa|22,=b_tbt|6,exits|; return arg if already a table|12507
||bne|8,wa|22,=b_art|6,exfal|; else fail if not an array|12508
||ejc|||||12509
;
;      convert (continued)
;
;      here to convert an array to table
;
||bne|13,arndm(xr)|18,=num02|6,exfal|; fail if not 2-dim array|12515
||ldi|13,ardm2(xr)|||; load dim 2|12516
||sbi|4,intv2|||; subtract 2 to compare|12517
||ine|6,exfal|||; fail if dim2 not 2|12518
;
;      here we have an arblk of the right shape
;
||ldi|13,ardim(xr)|||; load dim 1 (number of elements)|12522
||mfi|8,wa|||; get as one word integer|12523
||lct|8,wb|8,wa||; copy to control loop|12524
||add|8,wa|18,=tbsi_||; add space for standard fields|12525
||wtb|8,wa|||; convert length to bytes|12526
||jsr|6,alloc|||; allocate space for tbblk|12527
||mov|8,wc|7,xr||; copy tbblk pointer|12528
||mov|11,-(xs)|7,xr||; save tbblk pointer|12529
||mov|10,(xr)+|22,=b_tbt||; store type word|12530
||zer|10,(xr)+|||; store zero for idval for now|12531
||mov|10,(xr)+|8,wa||; store length|12532
||mov|10,(xr)+|21,=nulls||; null initial lookup value|12533
;
;      loop to initialize bucket ptrs to point to table
;
|scv20|mov|10,(xr)+|8,wc||; set bucket ptr to point to tbblk|12537
||bct|8,wb|6,scv20||; loop till all initialized|12538
||mov|8,wb|19,*arvl2||; set offset to first arblk element|12539
;
;      loop to copy elements from array to table
;
|scv21|mov|7,xl|13,num01(xs)||; point to arblk|12543
||beq|8,wb|13,arlen(xl)|6,scv24|; jump if all moved|12544
||add|7,xl|8,wb||; else point to current location|12545
||add|8,wb|19,*num02||; bump offset|12546
||mov|7,xr|9,(xl)||; load subscript name|12547
||dca|7,xl|||; adjust ptr to merge (trval=1+1)|12548
||ejc|||||12549
;
;      convert (continued)
;
;      loop to chase down trblk chain for value
;
|scv22|mov|7,xl|13,trval(xl)||; point to next value|12555
||beq|9,(xl)|22,=b_trt|6,scv22|; loop back if trapped|12556
;
;      here with name in xr, value in xl
;
|scv23|mov|11,-(xs)|7,xl||; stack value|12560
||mov|7,xl|13,num01(xs)||; load tbblk pointer|12561
||jsr|6,tfind|||; build teblk (note wb gt 0 by name)|12562
||ppm|6,exfal|||; fail if acess fails|12563
||mov|13,teval(xl)|10,(xs)+||; store value in teblk|12564
||brn|6,scv21|||; loop back for next element|12565
;
;      here after moving all elements to tbblk
;
|scv24|mov|7,xr|10,(xs)+||; load tbblk pointer|12569
||ica|7,xs|||; pop arblk pointer|12570
||brn|6,exsid|||; exit setting idval|12571
;
;      convert to expression
;
|scv25|zer|8,wb|||; by value|12576
||jsr|6,gtexp|||; convert to expression|12577
||ppm|6,exfal|||; fail if conversion not possible|12581
||zer|3,r_ccb|||; forget interim code block|12582
||mov|11,-(xs)|7,xr||; stack result|12583
||lcw|7,xr|||; get next code word|12584
||bri|9,(xr)|||; execute it|12585
;
;      convert to code
;
|scv26|jsr|6,gtcod|||; convert to code|12589
||ppm|6,exfal|||; fail if conversion is not possible|12590
||zer|3,r_ccb|||; forget interim code block|12591
||mov|11,-(xs)|7,xr||; stack result|12592
||lcw|7,xr|||; get next code word|12593
||bri|9,(xr)|||; execute it|12594
;
;      convert to numeric
;
|scv27|jsr|6,gtnum|||; convert to numeric|12598
||ppm|6,exfal|||; fail if unconvertible|12599
|scv31|mov|11,-(xs)|7,xr||; stack result|12600
||lcw|7,xr|||; get next code word|12601
||bri|9,(xr)|||; execute it|12602
||ejc|||||12603
;
;      second argument not string or null
;
|scv29|erb|1,074|26,convert second argument is not a string|||12629
;
;      copy
;
|s_cop|ent||||; entry point|12633
||jsr|6,copyb|||; copy the block|12634
||ppm|6,exits|||; return if no idval field|12635
||brn|6,exsid|||; exit setting id value|12636
||ejc|||||12637
;
;      cos
;
|s_cos|ent||||; entry point|12642
||mov|7,xr|10,(xs)+||; get argument|12643
||jsr|6,gtrea|||; convert to real|12644
||err|1,303|26,cos argument not numeric|||12645
||ldr|13,rcval(xr)|||; load accumulator with argument|12646
||cos||||; take cosine|12647
||rno|6,exrea|||; if no overflow, return result in ra|12648
||erb|1,322|26,cos argument is out of range|||12649
||ejc|||||12650
;
;      data
;
|s_dat|ent||||; entry point|12655
||jsr|6,xscni|||; prepare to scan argument|12656
||err|1,075|26,data argument is not a string|||12657
||err|1,076|26,data argument is null|||12658
;
;      scan out datatype name
;
||mov|8,wc|18,=ch_pp||; delimiter one = left paren|12662
||mov|7,xl|8,wc||; delimiter two = left paren|12663
||mnz|8,wa|||; skip/trim blanks in prototype|12664
||jsr|6,xscan|||; scan datatype name|12665
||bnz|8,wa|6,sdat1||; skip if left paren found|12666
||erb|1,077|26,data argument is missing a left paren|||12667
;
;      here after scanning datatype name
;
|sdat1|mov|8,wa|13,sclen(xr)||; get length|12672
||bze|8,wa|6,sdt1a||; avoid folding if null string|12673
||jsr|6,flstg|||; fold lower case to upper case|12674
|sdt1a|mov|7,xl|7,xr||; save name ptr|12675
||mov|8,wa|13,sclen(xr)||; get length|12679
||ctb|8,wa|2,scsi_||; compute space needed|12680
||jsr|6,alost|||; request static store for name|12681
||mov|11,-(xs)|7,xr||; save datatype name|12682
||mvw||||; copy name to static|12683
||mov|7,xr|9,(xs)||; get name ptr|12684
||zer|7,xl|||; scrub dud register|12685
||jsr|6,gtnvr|||; locate vrblk for datatype name|12686
||err|1,078|26,data argument has null datatype name|||12687
||mov|3,datdv|7,xr||; save vrblk pointer for datatype|12688
||mov|3,datxs|7,xs||; store starting stack value|12689
||zer|8,wb|||; zero count of field names|12690
;
;      loop to scan field names and stack vrblk pointers
;
|sdat2|mov|8,wc|18,=ch_rp||; delimiter one = right paren|12694
||mov|7,xl|18,=ch_cm||; delimiter two = comma|12695
||mnz|8,wa|||; skip/trim blanks in prototype|12696
||jsr|6,xscan|||; scan next field name|12697
||bnz|8,wa|6,sdat3||; jump if delimiter found|12698
||erb|1,079|26,data argument is missing a right paren|||12699
;
;      here after scanning out one field name
;
|sdat3|jsr|6,gtnvr|||; locate vrblk for field name|12703
||err|1,080|26,data argument has null field name|||12704
||mov|11,-(xs)|7,xr||; stack vrblk pointer|12705
||icv|8,wb|||; increment counter|12706
||beq|8,wa|18,=num02|6,sdat2|; loop back if stopped by comma|12707
||ejc|||||12708
;
;      data (continued)
;
;      now build the dfblk
;
||mov|8,wa|18,=dfsi_||; set size of dfblk standard fields|12714
||add|8,wa|8,wb||; add number of fields|12715
||wtb|8,wa|||; convert length to bytes|12716
||mov|8,wc|8,wb||; preserve no. of fields|12717
||jsr|6,alost|||; allocate space for dfblk|12718
||mov|8,wb|8,wc||; get no of fields|12719
||mov|7,xt|3,datxs||; point to start of stack|12720
||mov|8,wc|9,(xt)||; load datatype name|12721
||mov|9,(xt)|7,xr||; save dfblk pointer on stack|12722
||mov|10,(xr)+|22,=b_dfc||; store type word|12723
||mov|10,(xr)+|8,wb||; store number of fields (fargs)|12724
||mov|10,(xr)+|8,wa||; store length (dflen)|12725
||sub|8,wa|19,*pddfs||; compute pdblk length (for dfpdl)|12726
||mov|10,(xr)+|8,wa||; store pdblk length (dfpdl)|12727
||mov|10,(xr)+|8,wc||; store datatype name (dfnam)|12728
||lct|8,wc|8,wb||; copy number of fields|12729
;
;      loop to move field name vrblk pointers to dfblk
;
|sdat4|mov|10,(xr)+|11,-(xt)||; move one field name vrblk pointer|12733
||bct|8,wc|6,sdat4||; loop till all moved|12734
;
;      now define the datatype function
;
||mov|8,wc|8,wa||; copy length of pdblk for later loop|12738
||mov|7,xr|3,datdv||; point to vrblk|12739
||mov|7,xt|3,datxs||; point back on stack|12740
||mov|7,xl|9,(xt)||; load dfblk pointer|12741
||jsr|6,dffnc|||; define function|12742
||ejc|||||12743
;
;      data (continued)
;
;      loop to build ffblks
;
;
;      notice that the ffblks are constructed in reverse order
;      so that the required offsets can be obtained from
;      successive decrementation of the pdblk length (in wc).
;
|sdat5|mov|8,wa|19,*ffsi_||; set length of ffblk|12754
||jsr|6,alloc|||; allocate space for ffblk|12755
||mov|9,(xr)|22,=b_ffc||; set type word|12756
||mov|13,fargs(xr)|18,=num01||; store fargs (always one)|12757
||mov|7,xt|3,datxs||; point back on stack|12758
||mov|13,ffdfp(xr)|9,(xt)||; copy dfblk ptr to ffblk|12759
||dca|8,wc|||; decrement old dfpdl to get next ofs|12760
||mov|13,ffofs(xr)|8,wc||; set offset to this field|12761
||zer|13,ffnxt(xr)|||; tentatively set zero forward ptr|12762
||mov|7,xl|7,xr||; copy ffblk pointer for dffnc|12763
||mov|7,xr|9,(xs)||; load vrblk pointer for field|12764
||mov|7,xr|13,vrfnc(xr)||; load current function pointer|12765
||bne|9,(xr)|22,=b_ffc|6,sdat6|; skip if not currently a field func|12766
;
;      here we must chain an old ffblk ptr to preserve it in the
;      case of multiple field functions with the same name
;
||mov|13,ffnxt(xl)|7,xr||; link new ffblk to previous chain|12771
;
;      merge here to define field function
;
|sdat6|mov|7,xr|10,(xs)+||; load vrblk pointer|12775
||jsr|6,dffnc|||; define field function|12776
||bne|7,xs|3,datxs|6,sdat5|; loop back till all done|12777
||ica|7,xs|||; pop dfblk pointer|12778
||brn|6,exnul|||; return with null result|12779
||ejc|||||12780
;
;      datatype
;
|s_dtp|ent||||; entry point|12784
||mov|7,xr|10,(xs)+||; load argument|12785
||jsr|6,dtype|||; get datatype|12786
||mov|11,-(xs)|7,xr||; stack result|12787
||lcw|7,xr|||; get next code word|12788
||bri|9,(xr)|||; execute it|12789
||ejc|||||12790
;
;      date
;
|s_dte|ent||||; entry point|12794
||mov|7,xr|10,(xs)+||; load argument|12795
||jsr|6,gtint|||; convert to an integer|12796
||err|1,330|26,date argument is not integer|||12797
||jsr|6,sysdt|||; call system date routine|12798
||mov|8,wa|13,num01(xl)||; load length for sbstr|12799
||bze|8,wa|6,exnul||; return null if length is zero|12800
||zer|8,wb|||; set zero offset|12801
||jsr|6,sbstr|||; use sbstr to build scblk|12802
||mov|11,-(xs)|7,xr||; stack result|12803
||lcw|7,xr|||; get next code word|12804
||bri|9,(xr)|||; execute it|12805
||ejc|||||12806
;
;      define
;
|s_def|ent||||; entry point|12810
||mov|7,xr|10,(xs)+||; load second argument|12811
||zer|3,deflb|||; zero label pointer in case null|12812
||beq|7,xr|21,=nulls|6,sdf01|; jump if null second argument|12813
||jsr|6,gtnvr|||; else find vrblk for label|12814
||ppm|6,sdf12|||; jump if not a variable name|12815
||mov|3,deflb|7,xr||; else set specified entry|12816
;
;      scan function name
;
|sdf01|jsr|6,xscni|||; prepare to scan first argument|12820
||err|1,081|26,define first argument is not a string|||12821
||err|1,082|26,define first argument is null|||12822
||mov|8,wc|18,=ch_pp||; delimiter one = left paren|12823
||mov|7,xl|8,wc||; delimiter two = left paren|12824
||mnz|8,wa|||; skip/trim blanks in prototype|12825
||jsr|6,xscan|||; scan out function name|12826
||bnz|8,wa|6,sdf02||; jump if left paren found|12827
||erb|1,083|26,define first argument is missing a left paren|||12828
;
;      here after scanning out function name
;
|sdf02|jsr|6,gtnvr|||; get variable name|12832
||err|1,084|26,define first argument has null function name|||12833
||mov|3,defvr|7,xr||; save vrblk pointer for function nam|12834
||zer|8,wb|||; zero count of arguments|12835
||mov|3,defxs|7,xs||; save initial stack pointer|12836
||bnz|3,deflb|6,sdf03||; jump if second argument given|12837
||mov|3,deflb|7,xr||; else default is function name|12838
;
;      loop to scan argument names and stack vrblk pointers
;
|sdf03|mov|8,wc|18,=ch_rp||; delimiter one = right paren|12842
||mov|7,xl|18,=ch_cm||; delimiter two = comma|12843
||mnz|8,wa|||; skip/trim blanks in prototype|12844
||jsr|6,xscan|||; scan out next argument name|12845
||bnz|8,wa|6,sdf04||; skip if delimiter found|12846
||erb|1,085|26,null arg name or missing ) in define first arg.|||12847
||ejc|||||12848
;
;      define (continued)
;
;      here after scanning an argument name
;
|sdf04|bne|7,xr|21,=nulls|6,sdf05|; skip if non-null|12854
||bze|8,wb|6,sdf06||; ignore null if case of no arguments|12855
;
;      here after dealing with the case of no arguments
;
|sdf05|jsr|6,gtnvr|||; get vrblk pointer|12859
||ppm|6,sdf03|||; loop back to ignore null name|12860
||mov|11,-(xs)|7,xr||; stack argument vrblk pointer|12861
||icv|8,wb|||; increment counter|12862
||beq|8,wa|18,=num02|6,sdf03|; loop back if stopped by a comma|12863
;
;      here after scanning out function argument names
;
|sdf06|mov|3,defna|8,wb||; save number of arguments|12867
||zer|8,wb|||; zero count of locals|12868
;
;      loop to scan local names and stack vrblk pointers
;
|sdf07|mov|8,wc|18,=ch_cm||; set delimiter one = comma|12872
||mov|7,xl|8,wc||; set delimiter two = comma|12873
||mnz|8,wa|||; skip/trim blanks in prototype|12874
||jsr|6,xscan|||; scan out next local name|12875
||bne|7,xr|21,=nulls|6,sdf08|; skip if non-null|12876
||bze|8,wa|6,sdf09||; exit scan if end of string|12877
;
;      here after scanning out a local name
;
|sdf08|jsr|6,gtnvr|||; get vrblk pointer|12881
||ppm|6,sdf07|||; loop back to ignore null name|12882
||icv|8,wb|||; if ok, increment count|12883
||mov|11,-(xs)|7,xr||; stack vrblk pointer|12884
||bnz|8,wa|6,sdf07||; loop back if stopped by a comma|12885
||ejc|||||12886
;
;      define (continued)
;
;      here after scanning locals, build pfblk
;
|sdf09|mov|8,wa|8,wb||; copy count of locals|12892
||add|8,wa|3,defna||; add number of arguments|12893
||mov|8,wc|8,wa||; set sum args+locals as loop count|12894
||add|8,wa|18,=pfsi_||; add space for standard fields|12895
||wtb|8,wa|||; convert length to bytes|12896
||jsr|6,alloc|||; allocate space for pfblk|12897
||mov|7,xl|7,xr||; save pointer to pfblk|12898
||mov|10,(xr)+|22,=b_pfc||; store first word|12899
||mov|10,(xr)+|3,defna||; store number of arguments|12900
||mov|10,(xr)+|8,wa||; store length (pflen)|12901
||mov|10,(xr)+|3,defvr||; store vrblk ptr for function name|12902
||mov|10,(xr)+|8,wb||; store number of locals|12903
||zer|10,(xr)+|||; deal with label later|12904
||zer|10,(xr)+|||; zero pfctr|12905
||zer|10,(xr)+|||; zero pfrtr|12906
||bze|8,wc|6,sdf11||; skip if no args or locals|12907
||mov|8,wa|7,xl||; keep pfblk pointer|12908
||mov|7,xt|3,defxs||; point before arguments|12909
||lct|8,wc|8,wc||; get count of args+locals for loop|12910
;
;      loop to move locals and args to pfblk
;
|sdf10|mov|10,(xr)+|11,-(xt)||; store one entry and bump pointers|12914
||bct|8,wc|6,sdf10||; loop till all stored|12915
||mov|7,xl|8,wa||; recover pfblk pointer|12916
||ejc|||||12917
;
;      define (continued)
;
;      now deal with label
;
|sdf11|mov|7,xs|3,defxs||; pop stack|12923
||mov|13,pfcod(xl)|3,deflb||; store label vrblk in pfblk|12924
||mov|7,xr|3,defvr||; point back to vrblk for function|12925
||jsr|6,dffnc|||; define function|12926
||brn|6,exnul|||; and exit returning null|12927
;
;      here for erroneous label
;
|sdf12|erb|1,086|26,define function entry point is not defined label|||12931
||ejc|||||12932
;
;      detach
;
|s_det|ent||||; entry point|12936
||mov|7,xr|10,(xs)+||; load argument|12937
||jsr|6,gtvar|||; locate variable|12938
||err|1,087|26,detach argument is not appropriate name|||12939
||jsr|6,dtach|||; detach i/o association from name|12940
||brn|6,exnul|||; return null result|12941
||ejc|||||12942
;
;      differ
;
|s_dif|ent||||; entry point|12946
||mov|7,xr|10,(xs)+||; load second argument|12947
||mov|7,xl|10,(xs)+||; load first argument|12948
||jsr|6,ident|||; call ident comparison routine|12949
||ppm|6,exfal|||; fail if ident|12950
||brn|6,exnul|||; return null if differ|12951
||ejc|||||12952
;
;      dump
;
|s_dmp|ent||||; entry point|12956
||jsr|6,gtsmi|||; load dump arg as small integer|12957
||err|1,088|26,dump argument is not integer|||12958
||err|1,089|26,dump argument is negative or too large|||12959
||jsr|6,dumpr|||; else call dump routine|12960
||brn|6,exnul|||; and return null as result|12961
||ejc|||||12962
;
;      dupl
;
|s_dup|ent||||; entry point|12966
||jsr|6,gtsmi|||; get second argument as small integr|12967
||err|1,090|26,dupl second argument is not integer|||12968
||ppm|6,sdup7|||; jump if negative or too big|12969
||mov|8,wb|7,xr||; save duplication factor|12970
||jsr|6,gtstg|||; get first arg as string|12971
||ppm|6,sdup4|||; jump if not a string|12972
;
;      here for case of duplication of a string
;
||mti|8,wa|||; acquire length as integer|12976
||sti|3,dupsi|||; save for the moment|12977
||mti|8,wb|||; get duplication factor as integer|12978
||mli|3,dupsi|||; form product|12979
||iov|6,sdup3|||; jump if overflow|12980
||ieq|6,exnul|||; return null if result length = 0|12981
||mfi|8,wa|6,sdup3||; get as addr integer, check ovflo|12982
;
;      merge here with result length in wa
;
|sdup1|mov|7,xl|7,xr||; save string pointer|12986
||jsr|6,alocs|||; allocate space for string|12987
||mov|11,-(xs)|7,xr||; save as result pointer|12988
||mov|8,wc|7,xl||; save pointer to argument string|12989
||psc|7,xr|||; prepare to store chars of result|12990
||lct|8,wb|8,wb||; set counter to control loop|12991
;
;      loop through duplications
;
|sdup2|mov|7,xl|8,wc||; point back to argument string|12995
||mov|8,wa|13,sclen(xl)||; get number of characters|12996
||plc|7,xl|||; point to chars in argument string|12997
||mvc||||; move characters to result string|12998
||bct|8,wb|6,sdup2||; loop till all duplications done|12999
||zer|7,xl|||; clear garbage value|13000
||lcw|7,xr|||; get next code word|13001
||bri|9,(xr)|||; execute next code word|13002
||ejc|||||13003
;
;      dupl (continued)
;
;      here if too large, set max length and let alocs catch it
;
|sdup3|mov|8,wa|3,dname||; set impossible length for alocs|13009
||brn|6,sdup1|||; merge back|13010
;
;      here if not a string
;
|sdup4|jsr|6,gtpat|||; convert argument to pattern|13014
||err|1,091|26,dupl first argument is not a string or pattern|||13015
;
;      here to duplicate a pattern argument
;
||mov|11,-(xs)|7,xr||; store pattern on stack|13019
||mov|7,xr|21,=ndnth||; start off with null pattern|13020
||bze|8,wb|6,sdup6||; null pattern is result if dupfac=0|13021
||mov|11,-(xs)|8,wb||; preserve loop count|13022
;
;      loop to duplicate by successive concatenation
;
|sdup5|mov|7,xl|7,xr||; copy current value as right argumnt|13026
||mov|7,xr|13,num01(xs)||; get a new copy of left|13027
||jsr|6,pconc|||; concatenate|13028
||dcv|9,(xs)|||; count down|13029
||bnz|9,(xs)|6,sdup5||; loop|13030
||ica|7,xs|||; pop loop count|13031
;
;      here to exit after constructing pattern
;
|sdup6|mov|9,(xs)|7,xr||; store result on stack|13035
||lcw|7,xr|||; get next code word|13036
||bri|9,(xr)|||; execute next code word|13037
;
;      fail if second arg is out of range
;
|sdup7|ica|7,xs|||; pop first argument|13041
||brn|6,exfal|||; fail|13042
||ejc|||||13043
;
;      eject
;
|s_ejc|ent||||; entry point|13047
||jsr|6,iofcb|||; call fcblk routine|13048
||err|1,092|26,eject argument is not a suitable name|||13049
||ppm|6,sejc1|||; null argument|13050
||err|1,093|26,eject file does not exist|||13051
||jsr|6,sysef|||; call eject file function|13052
||err|1,093|26,eject file does not exist|||13053
||err|1,094|26,eject file does not permit page eject|||13054
||err|1,095|26,eject caused non-recoverable output error|||13055
||brn|6,exnul|||; return null as result|13056
;
;      here to eject standard output file
;
|sejc1|jsr|6,sysep|||; call routine to eject printer|13060
||brn|6,exnul|||; exit with null result|13061
||ejc|||||13062
;
;      endfile
;
|s_enf|ent||||; entry point|13066
||jsr|6,iofcb|||; call fcblk routine|13067
||err|1,096|26,endfile argument is not a suitable name|||13068
||err|1,097|26,endfile argument is null|||13069
||err|1,098|26,endfile file does not exist|||13070
||jsr|6,sysen|||; call endfile routine|13071
||err|1,098|26,endfile file does not exist|||13072
||err|1,099|26,endfile file does not permit endfile|||13073
||err|1,100|26,endfile caused non-recoverable output error|||13074
||mov|8,wb|7,xl||; remember vrblk ptr from iofcb call|13075
||mov|7,xr|7,xl||; copy pointer|13076
;
;      loop to find trtrf block
;
|senf1|mov|7,xl|7,xr||; remember previous entry|13080
||mov|7,xr|13,trval(xr)||; chain along|13081
||bne|9,(xr)|22,=b_trt|6,exnul|; skip out if chain end|13082
||bne|13,trtyp(xr)|18,=trtfc|6,senf1|; loop if not found|13083
||mov|13,trval(xl)|13,trval(xr)||; remove trtrf|13084
||mov|3,enfch|13,trtrf(xr)||; point to head of iochn|13085
||mov|8,wc|13,trfpt(xr)||; point to fcblk|13086
||mov|7,xr|8,wb||; filearg1 vrblk from iofcb|13087
||jsr|6,setvr|||; reset it|13088
||mov|7,xl|20,=r_fcb||; ptr to head of fcblk chain|13089
||sub|7,xl|19,*num02||; adjust ready to enter loop|13090
;
;      find fcblk
;
|senf2|mov|7,xr|7,xl||; copy ptr|13094
||mov|7,xl|13,num02(xl)||; get next link|13095
||bze|7,xl|6,senf4||; stop if chain end|13096
||beq|13,num03(xl)|8,wc|6,senf3|; jump if fcblk found|13097
||brn|6,senf2|||; loop|13098
;
;      remove fcblk
;
|senf3|mov|13,num02(xr)|13,num02(xl)||; delete fcblk from chain|13102
;
;      loop which detaches all vbls on iochn chain
;
|senf4|mov|7,xl|3,enfch||; get chain head|13106
||bze|7,xl|6,exnul||; finished if chain end|13107
||mov|3,enfch|13,trtrf(xl)||; chain along|13108
||mov|8,wa|13,ionmo(xl)||; name offset|13109
||mov|7,xl|13,ionmb(xl)||; name base|13110
||jsr|6,dtach|||; detach name|13111
||brn|6,senf4|||; loop till done|13112
||ejc|||||13113
;
;      eq
;
|s_eqf|ent||||; entry point|13117
||jsr|6,acomp|||; call arithmetic comparison routine|13118
||err|1,101|26,eq first argument is not numeric|||13119
||err|1,102|26,eq second argument is not numeric|||13120
||ppm|6,exfal|||; fail if lt|13121
||ppm|6,exnul|||; return null if eq|13122
||ppm|6,exfal|||; fail if gt|13123
||ejc|||||13124
;
;      eval
;
|s_evl|ent||||; entry point|13128
||mov|7,xr|10,(xs)+||; load argument|13129
||lcw|8,wc|||; load next code word|13135
||bne|8,wc|21,=ofne_|6,sevl1|; jump if called by value|13136
||scp|7,xl|||; copy code pointer|13137
||mov|8,wa|9,(xl)||; get next code word|13138
||bne|8,wa|21,=ornm_|6,sevl2|; by name unless expression|13139
||bnz|13,num01(xs)|6,sevl2||; jump if by name|13140
;
;      here if called by value
;
|sevl1|zer|8,wb|||; set flag for by value|13144
||mov|11,-(xs)|8,wc||; save code word|13146
||jsr|6,gtexp|||; convert to expression|13147
||err|1,103|26,eval argument is not expression|||13148
||zer|3,r_ccb|||; forget interim code block|13149
||zer|8,wb|||; set flag for by value|13150
||jsr|6,evalx|||; evaluate expression by value|13154
||ppm|6,exfal|||; fail if evaluation fails|13155
||mov|7,xl|7,xr||; copy result|13156
||mov|7,xr|9,(xs)||; reload next code word|13157
||mov|9,(xs)|7,xl||; stack result|13158
||bri|9,(xr)|||; jump to execute next code word|13159
;
;      here if called by name
;
|sevl2|mov|8,wb|18,=num01||; set flag for by name|13163
||jsr|6,gtexp|||; convert to expression|13165
||err|1,103|26,eval argument is not expression|||13166
||zer|3,r_ccb|||; forget interim code block|13167
||mov|8,wb|18,=num01||; set flag for by name|13168
||jsr|6,evalx|||; evaluate expression by name|13170
||ppm|6,exfal|||; fail if evaluation fails|13171
||brn|6,exnam|||; exit with name|13172
||ejc|||||13175
;
;      exit
;
|s_ext|ent||||; entry point|13179
||zer|8,wb|||; clear amount of static shift|13180
||zer|3,r_ccb|||; forget interim code block|13181
||zer|3,dnams|||; collect sediment too|13183
||jsr|6,gbcol|||; compact memory by collecting|13184
||mov|3,dnams|7,xr||; record new sediment size|13185
||jsr|6,gtstg|||;|13189
||err|1,288|26,exit second argument is not a string|||13190
||mov|7,xl|7,xr||; copy second arg string pointer|13191
||jsr|6,gtstg|||; convert arg to string|13192
||err|1,104|26,exit first argument is not suitable integer or string|||13193
||mov|11,-(xs)|7,xl||; save second argument|13194
||mov|7,xl|7,xr||; copy first arg string ptr|13195
||jsr|6,gtint|||; check it is integer|13196
||ppm|6,sext1|||; skip if unconvertible|13197
||zer|7,xl|||; note it is integer|13198
||ldi|13,icval(xr)|||; get integer arg|13199
;
;      merge to call osint exit routine
;
|sext1|mov|8,wb|3,r_fcb||; get fcblk chain header|13203
||mov|7,xr|21,=headv||; point to v.v string|13204
||mov|8,wa|10,(xs)+||; provide second argument scblk|13205
||jsr|6,sysxi|||; call external routine|13206
||err|1,105|26,exit action not available in this implementation|||13207
||err|1,106|26,exit action caused irrecoverable error|||13208
||ieq|6,exnul|||; return if argument 0|13209
||igt|6,sext2|||; skip if positive|13210
||ngi||||; make positive|13211
;
;      check for option respecification
;
;      sysxi returns 0 in wa when a file has been resumed,
;      1 when this is a continuation of an exit(4) or exit(-4)
;      action.
;
|sext2|mfi|8,wc|||; get value in work reg|13219
||add|8,wa|8,wc||; prepare to test for continue|13220
||beq|8,wa|18,=num05|6,sext5|; continued execution if 4 plus 1|13221
||zer|3,gbcnt|||; resuming execution so reset|13222
||bge|8,wc|18,=num03|6,sext3|; skip if was 3 or 4|13223
||mov|11,-(xs)|8,wc||; save value|13224
||zer|8,wc|||; set to read options|13225
||jsr|6,prpar|||; read syspp options|13226
||mov|8,wc|10,(xs)+||; restore value|13227
;
;      deal with header option (fiddled by prpar)
;
|sext3|mnz|3,headp|||; assume no headers|13231
||bne|8,wc|18,=num01|6,sext4|; skip if not 1|13232
||zer|3,headp|||; request header printing|13233
;
;      almost ready to resume running
;
|sext4|jsr|6,systm|||; get execution time start (sgd11)|13237
||sti|3,timsx|||; save as initial time|13238
||ldi|3,kvstc|||; reset to ensure ...|13239
||sti|3,kvstl|||; ... correct execution stats|13240
||jsr|6,stgcc|||; recompute countdown counters|13241
||brn|6,exnul|||; resume execution|13242
;
;      here after exit(4) or exit(-4) -- create save file
;      or load module and continue execution.
;
;      return integer 1 to signal the continuation of the
;      original execution.
;
|sext5|mov|7,xr|21,=inton||; integer one|13250
||brn|6,exixr|||; return as result|13251
||ejc|||||13253
;
;      exp
;
|s_exp|ent||||; entry point|13258
||mov|7,xr|10,(xs)+||; get argument|13259
||jsr|6,gtrea|||; convert to real|13260
||err|1,304|26,exp argument not numeric|||13261
||ldr|13,rcval(xr)|||; load accumulator with argument|13262
||etx||||; take exponential|13263
||rno|6,exrea|||; if no overflow, return result in ra|13264
||erb|1,305|26,exp produced real overflow|||13265
||ejc|||||13266
;
;      field
;
|s_fld|ent||||; entry point|13271
||jsr|6,gtsmi|||; get second argument (field number)|13272
||err|1,107|26,field second argument is not integer|||13273
||ppm|6,exfal|||; fail if out of range|13274
||mov|8,wb|7,xr||; else save integer value|13275
||mov|7,xr|10,(xs)+||; load first argument|13276
||jsr|6,gtnvr|||; point to vrblk|13277
||ppm|6,sfld1|||; jump (error) if not variable name|13278
||mov|7,xr|13,vrfnc(xr)||; else point to function block|13279
||bne|9,(xr)|22,=b_dfc|6,sfld1|; error if not datatype function|13280
;
;      here if first argument is a datatype function name
;
||bze|8,wb|6,exfal||; fail if argument number is zero|13284
||bgt|8,wb|13,fargs(xr)|6,exfal|; fail if too large|13285
||wtb|8,wb|||; else convert to byte offset|13286
||add|7,xr|8,wb||; point to field name|13287
||mov|7,xr|13,dfflb(xr)||; load vrblk pointer|13288
||brn|6,exvnm|||; exit to build nmblk|13289
;
;      here for bad first argument
;
|sfld1|erb|1,108|26,field first argument is not datatype name|||13293
||ejc|||||13294
;
;      fence
;
|s_fnc|ent||||; entry point|13298
||mov|8,wb|22,=p_fnc||; set pcode for p_fnc|13299
||zer|7,xr|||; p0blk|13300
||jsr|6,pbild|||; build p_fnc node|13301
||mov|7,xl|7,xr||; save pointer to it|13302
||mov|7,xr|10,(xs)+||; get argument|13303
||jsr|6,gtpat|||; convert to pattern|13304
||err|1,259|26,fence argument is not pattern|||13305
||jsr|6,pconc|||; concatenate to p_fnc node|13306
||mov|7,xl|7,xr||; save ptr to concatenated pattern|13307
||mov|8,wb|22,=p_fna||; set for p_fna pcode|13308
||zer|7,xr|||; p0blk|13309
||jsr|6,pbild|||; construct p_fna node|13310
||mov|13,pthen(xr)|7,xl||; set pattern as pthen|13311
||mov|11,-(xs)|7,xr||; set as result|13312
||lcw|7,xr|||; get next code word|13313
||bri|9,(xr)|||; execute next code word|13314
||ejc|||||13315
;
;      ge
;
|s_gef|ent||||; entry point|13319
||jsr|6,acomp|||; call arithmetic comparison routine|13320
||err|1,109|26,ge first argument is not numeric|||13321
||err|1,110|26,ge second argument is not numeric|||13322
||ppm|6,exfal|||; fail if lt|13323
||ppm|6,exnul|||; return null if eq|13324
||ppm|6,exnul|||; return null if gt|13325
||ejc|||||13326
;
;      gt
;
|s_gtf|ent||||; entry point|13330
||jsr|6,acomp|||; call arithmetic comparison routine|13331
||err|1,111|26,gt first argument is not numeric|||13332
||err|1,112|26,gt second argument is not numeric|||13333
||ppm|6,exfal|||; fail if lt|13334
||ppm|6,exfal|||; fail if eq|13335
||ppm|6,exnul|||; return null if gt|13336
||ejc|||||13337
;
;      host
;
|s_hst|ent||||; entry point|13341
||mov|8,wc|10,(xs)+||; get fifth arg|13342
||mov|8,wb|10,(xs)+||; get fourth arg|13343
||mov|7,xr|10,(xs)+||; get third arg|13344
||mov|7,xl|10,(xs)+||; get second arg|13345
||mov|8,wa|10,(xs)+||; get first arg|13346
||jsr|6,syshs|||; enter syshs routine|13347
||err|1,254|26,erroneous argument for host|||13348
||err|1,255|26,error during execution of host|||13349
||ppm|6,shst1|||; store host string|13350
||ppm|6,exnul|||; return null result|13351
||ppm|6,exixr|||; return xr|13352
||ppm|6,exfal|||; fail return|13353
||ppm|6,shst3|||; store actual string|13354
||ppm|6,shst4|||; return copy of xr|13355
;
;      return host string
;
|shst1|bze|7,xl|6,exnul||; null string if syshs uncooperative|13359
||mov|8,wa|13,sclen(xl)||; length|13360
||zer|8,wb|||; zero offset|13361
;
;      copy string and return
;
|shst2|jsr|6,sbstr|||; build copy of string|13365
||mov|11,-(xs)|7,xr||; stack the result|13366
||lcw|7,xr|||; load next code word|13367
||bri|9,(xr)|||; execute it|13368
;
;      return actual string pointed to by xl
;
|shst3|zer|8,wb|||; treat xl like an scblk ptr|13372
||sub|8,wb|18,=cfp_f||; by creating a negative offset|13373
||brn|6,shst2|||; join to copy string|13374
;
;      return copy of block pointed to by xr
;
|shst4|mov|11,-(xs)|7,xr||; stack results|13378
||jsr|6,copyb|||; make copy of block|13379
||ppm|6,exits|||; if not an aggregate structure|13380
||brn|6,exsid|||; set current id value otherwise|13381
||ejc|||||13382
;
;      ident
;
|s_idn|ent||||; entry point|13386
||mov|7,xr|10,(xs)+||; load second argument|13387
||mov|7,xl|10,(xs)+||; load first argument|13388
||jsr|6,ident|||; call ident comparison routine|13389
||ppm|6,exnul|||; return null if ident|13390
||brn|6,exfal|||; fail if differ|13391
||ejc|||||13392
;
;      input
;
|s_inp|ent||||; entry point|13396
||zer|8,wb|||; input flag|13397
||jsr|6,ioput|||; call input/output assoc. routine|13398
||err|1,113|26,input third argument is not a string|||13399
||err|1,114|26,inappropriate second argument for input|||13400
||err|1,115|26,inappropriate first argument for input|||13401
||err|1,116|26,inappropriate file specification for input|||13402
||ppm|6,exfal|||; fail if file does not exist|13403
||err|1,117|26,input file cannot be read|||13404
||err|1,289|26,input channel currently in use|||13405
||brn|6,exnul|||; return null string|13406
||ejc|||||13407
;
;      integer
;
|s_int|ent||||; entry point|13440
||mov|7,xr|10,(xs)+||; load argument|13441
||jsr|6,gtnum|||; convert to numeric|13442
||ppm|6,exfal|||; fail if non-numeric|13443
||beq|8,wa|22,=b_icl|6,exnul|; return null if integer|13444
||brn|6,exfal|||; fail if real|13445
||ejc|||||13446
;
;      item
;
;      item does not permit the direct (fast) call so that
;      wa contains the actual number of arguments passed.
;
|s_itm|ent||||; entry point|13453
;
;      deal with case of no args
;
||bnz|8,wa|6,sitm1||; jump if at least one arg|13457
||mov|11,-(xs)|21,=nulls||; else supply garbage null arg|13458
||mov|8,wa|18,=num01||; and fix argument count|13459
;
;      check for name/value cases
;
|sitm1|scp|7,xr|||; get current code pointer|13463
||mov|7,xl|9,(xr)||; load next code word|13464
||dcv|8,wa|||; get number of subscripts|13465
||mov|7,xr|8,wa||; copy for arref|13466
||beq|7,xl|21,=ofne_|6,sitm2|; jump if called by name|13467
;
;      here if called by value
;
||zer|8,wb|||; set code for call by value|13471
||brn|6,arref|||; off to array reference routine|13472
;
;      here for call by name
;
|sitm2|mnz|8,wb|||; set code for call by name|13476
||lcw|8,wa|||; load and ignore ofne_ call|13477
||brn|6,arref|||; off to array reference routine|13478
||ejc|||||13479
;
;      le
;
|s_lef|ent||||; entry point|13483
||jsr|6,acomp|||; call arithmetic comparison routine|13484
||err|1,118|26,le first argument is not numeric|||13485
||err|1,119|26,le second argument is not numeric|||13486
||ppm|6,exnul|||; return null if lt|13487
||ppm|6,exnul|||; return null if eq|13488
||ppm|6,exfal|||; fail if gt|13489
||ejc|||||13490
;
;      len
;
|s_len|ent||||; entry point|13494
||mov|8,wb|22,=p_len||; set pcode for integer arg case|13495
||mov|8,wa|22,=p_lnd||; set pcode for expr arg case|13496
||jsr|6,patin|||; call common routine to build node|13497
||err|1,120|26,len argument is not integer or expression|||13498
||err|1,121|26,len argument is negative or too large|||13499
||mov|11,-(xs)|7,xr||; stack result|13500
||lcw|7,xr|||; get next code word|13501
||bri|9,(xr)|||; execute it|13502
||ejc|||||13503
;
;      leq
;
|s_leq|ent||||; entry point|13507
||jsr|6,lcomp|||; call string comparison routine|13508
||err|1,122|26,leq first argument is not a string|||13509
||err|1,123|26,leq second argument is not a string|||13510
||ppm|6,exfal|||; fail if llt|13511
||ppm|6,exnul|||; return null if leq|13512
||ppm|6,exfal|||; fail if lgt|13513
||ejc|||||13514
;
;      lge
;
|s_lge|ent||||; entry point|13518
||jsr|6,lcomp|||; call string comparison routine|13519
||err|1,124|26,lge first argument is not a string|||13520
||err|1,125|26,lge second argument is not a string|||13521
||ppm|6,exfal|||; fail if llt|13522
||ppm|6,exnul|||; return null if leq|13523
||ppm|6,exnul|||; return null if lgt|13524
||ejc|||||13525
;
;      lgt
;
|s_lgt|ent||||; entry point|13529
||jsr|6,lcomp|||; call string comparison routine|13530
||err|1,126|26,lgt first argument is not a string|||13531
||err|1,127|26,lgt second argument is not a string|||13532
||ppm|6,exfal|||; fail if llt|13533
||ppm|6,exfal|||; fail if leq|13534
||ppm|6,exnul|||; return null if lgt|13535
||ejc|||||13536
;
;      lle
;
|s_lle|ent||||; entry point|13540
||jsr|6,lcomp|||; call string comparison routine|13541
||err|1,128|26,lle first argument is not a string|||13542
||err|1,129|26,lle second argument is not a string|||13543
||ppm|6,exnul|||; return null if llt|13544
||ppm|6,exnul|||; return null if leq|13545
||ppm|6,exfal|||; fail if lgt|13546
||ejc|||||13547
;
;      llt
;
|s_llt|ent||||; entry point|13551
||jsr|6,lcomp|||; call string comparison routine|13552
||err|1,130|26,llt first argument is not a string|||13553
||err|1,131|26,llt second argument is not a string|||13554
||ppm|6,exnul|||; return null if llt|13555
||ppm|6,exfal|||; fail if leq|13556
||ppm|6,exfal|||; fail if lgt|13557
||ejc|||||13558
;
;      lne
;
|s_lne|ent||||; entry point|13562
||jsr|6,lcomp|||; call string comparison routine|13563
||err|1,132|26,lne first argument is not a string|||13564
||err|1,133|26,lne second argument is not a string|||13565
||ppm|6,exnul|||; return null if llt|13566
||ppm|6,exfal|||; fail if leq|13567
||ppm|6,exnul|||; return null if lgt|13568
||ejc|||||13569
;
;      ln
;
|s_lnf|ent||||; entry point|13574
||mov|7,xr|10,(xs)+||; get argument|13575
||jsr|6,gtrea|||; convert to real|13576
||err|1,306|26,ln argument not numeric|||13577
||ldr|13,rcval(xr)|||; load accumulator with argument|13578
||req|6,slnf1|||; overflow if argument is 0|13579
||rlt|6,slnf2|||; error if argument less than 0|13580
||lnf||||; take natural logarithm|13581
||rno|6,exrea|||; if no overflow, return result in ra|13582
|slnf1|erb|1,307|26,ln produced real overflow|||13583
;
;      here for bad argument
;
|slnf2|erb|1,315|26,ln argument negative|||13587
||ejc|||||13588
;
;      local
;
|s_loc|ent||||; entry point|13593
||jsr|6,gtsmi|||; get second argument (local number)|13594
||err|1,134|26,local second argument is not integer|||13595
||ppm|6,exfal|||; fail if out of range|13596
||mov|8,wb|7,xr||; save local number|13597
||mov|7,xr|10,(xs)+||; load first argument|13598
||jsr|6,gtnvr|||; point to vrblk|13599
||ppm|6,sloc1|||; jump if not variable name|13600
||mov|7,xr|13,vrfnc(xr)||; else load function pointer|13601
||bne|9,(xr)|22,=b_pfc|6,sloc1|; jump if not program defined|13602
;
;      here if we have a program defined function name
;
||bze|8,wb|6,exfal||; fail if second arg is zero|13606
||bgt|8,wb|13,pfnlo(xr)|6,exfal|; or too large|13607
||add|8,wb|13,fargs(xr)||; else adjust offset to include args|13608
||wtb|8,wb|||; convert to bytes|13609
||add|7,xr|8,wb||; point to local pointer|13610
||mov|7,xr|13,pfagb(xr)||; load vrblk pointer|13611
||brn|6,exvnm|||; exit building nmblk|13612
;
;      here if first argument is no good
;
|sloc1|erb|1,135|26,local first arg is not a program function name|||13616
||ejc|||||13619
;
;      load
;
|s_lod|ent||||; entry point|13623
||jsr|6,gtstg|||; load library name|13624
||err|1,136|26,load second argument is not a string|||13625
||mov|7,xl|7,xr||; save library name|13626
||jsr|6,xscni|||; prepare to scan first argument|13627
||err|1,137|26,load first argument is not a string|||13628
||err|1,138|26,load first argument is null|||13629
||mov|11,-(xs)|7,xl||; stack library name|13630
||mov|8,wc|18,=ch_pp||; set delimiter one = left paren|13631
||mov|7,xl|8,wc||; set delimiter two = left paren|13632
||mnz|8,wa|||; skip/trim blanks in prototype|13633
||jsr|6,xscan|||; scan function name|13634
||mov|11,-(xs)|7,xr||; save ptr to function name|13635
||bnz|8,wa|6,slod1||; jump if left paren found|13636
||erb|1,139|26,load first argument is missing a left paren|||13637
;
;      here after successfully scanning function name
;
|slod1|jsr|6,gtnvr|||; locate vrblk|13641
||err|1,140|26,load first argument has null function name|||13642
||mov|3,lodfn|7,xr||; save vrblk pointer|13643
||zer|3,lodna|||; zero count of arguments|13644
;
;      loop to scan argument datatype names
;
|slod2|mov|8,wc|18,=ch_rp||; delimiter one is right paren|13648
||mov|7,xl|18,=ch_cm||; delimiter two is comma|13649
||mnz|8,wa|||; skip/trim blanks in prototype|13650
||jsr|6,xscan|||; scan next argument name|13651
||icv|3,lodna|||; bump argument count|13652
||bnz|8,wa|6,slod3||; jump if ok delimiter was found|13653
||erb|1,141|26,load first argument is missing a right paren|||13654
||ejc|||||13655
;
;      load (continued)
;
;      come here to analyze the datatype pointer in (xr). this
;      code is used both for arguments (wa=1,2) and for the
;      result datatype (with wa set to zero).
;
|slod3|mov|8,wb|8,wa||; save scan mode|13664
||mov|8,wa|13,sclen(xr)||; datatype length|13665
||bze|8,wa|6,sld3a||; bypass if null string|13666
||jsr|6,flstg|||; fold to upper case|13667
|sld3a|mov|8,wa|8,wb||; restore scan mode|13668
||mov|11,-(xs)|7,xr||; stack datatype name pointer|13669
||mov|8,wb|18,=num01||; set string code in case|13673
||mov|7,xl|21,=scstr||; point to /string/|13674
||jsr|6,ident|||; check for match|13675
||ppm|6,slod4|||; jump if match|13676
||mov|7,xr|9,(xs)||; else reload name|13677
||add|8,wb|8,wb||; set code for integer (2)|13678
||mov|7,xl|21,=scint||; point to /integer/|13679
||jsr|6,ident|||; check for match|13680
||ppm|6,slod4|||; jump if match|13681
||mov|7,xr|9,(xs)||; else reload string pointer|13684
||icv|8,wb|||; set code for real (3)|13685
||mov|7,xl|21,=screa||; point to /real/|13686
||jsr|6,ident|||; check for match|13687
||ppm|6,slod4|||; jump if match|13688
||mov|7,xr|9,(xs)||; reload string pointer|13691
||icv|8,wb|||; code for file (4, or 3 if no reals)|13692
||mov|7,xl|21,=scfil||; point to /file/|13693
||jsr|6,ident|||; check for match|13694
||ppm|6,slod4|||; jump if match|13695
||zer|8,wb|||; else get code for no convert|13697
;
;      merge here with proper datatype code in wb
;
|slod4|mov|9,(xs)|8,wb||; store code on stack|13701
||beq|8,wa|18,=num02|6,slod2|; loop back if arg stopped by comma|13702
||bze|8,wa|6,slod5||; jump if that was the result type|13703
;
;      here we scan out the result type (arg stopped by ) )
;
||mov|8,wc|3,mxlen||; set dummy (impossible) delimiter 1|13707
||mov|7,xl|8,wc||; and delimiter two|13708
||mnz|8,wa|||; skip/trim blanks in prototype|13709
||jsr|6,xscan|||; scan result name|13710
||zer|8,wa|||; set code for processing result|13711
||brn|6,slod3|||; jump back to process result name|13712
||ejc|||||13713
;
;      load (continued)
;
;      here after processing all args and result
;
|slod5|mov|8,wa|3,lodna||; get number of arguments|13719
||mov|8,wc|8,wa||; copy for later|13720
||wtb|8,wa|||; convert length to bytes|13721
||add|8,wa|19,*efsi_||; add space for standard fields|13722
||jsr|6,alloc|||; allocate efblk|13723
||mov|9,(xr)|22,=b_efc||; set type word|13724
||mov|13,fargs(xr)|8,wc||; set number of arguments|13725
||zer|13,efuse(xr)|||; set use count (dffnc will set to 1)|13726
||zer|13,efcod(xr)|||; zero code pointer for now|13727
||mov|13,efrsl(xr)|10,(xs)+||; store result type code|13728
||mov|13,efvar(xr)|3,lodfn||; store function vrblk pointer|13729
||mov|13,eflen(xr)|8,wa||; store efblk length|13730
||mov|8,wb|7,xr||; save efblk pointer|13731
||add|7,xr|8,wa||; point past end of efblk|13732
||lct|8,wc|8,wc||; set number of arguments for loop|13733
;
;      loop to set argument type codes from stack
;
|slod6|mov|11,-(xr)|10,(xs)+||; store one type code from stack|13737
||bct|8,wc|6,slod6||; loop till all stored|13738
;
;      now load the external function and perform definition
;
||mov|7,xr|10,(xs)+||; load function string name|13742
||mov|8,wa|13,sclen(xr)||; function name length|13744
||jsr|6,flstg|||; fold to upper case|13745
||mov|7,xl|9,(xs)||; load library name|13747
||mov|9,(xs)|8,wb||; store efblk pointer|13748
||jsr|6,sysld|||; call function to load external func|13749
||err|1,142|26,load function does not exist|||13750
||err|1,143|26,load function caused input error during load|||13751
||err|1,328|26,load function - insufficient memory|||13752
||mov|7,xl|10,(xs)+||; recall efblk pointer|13753
||mov|13,efcod(xl)|7,xr||; store code pointer|13754
||mov|7,xr|3,lodfn||; point to vrblk for function|13755
||jsr|6,dffnc|||; perform function definition|13756
||brn|6,exnul|||; return null result|13757
||ejc|||||13759
;
;      lpad
;
|s_lpd|ent||||; entry point|13763
||jsr|6,gtstg|||; get pad character|13764
||err|1,144|26,lpad third argument is not a string|||13765
||plc|7,xr|||; point to character (null is blank)|13766
||lch|8,wb|9,(xr)||; load pad character|13767
||jsr|6,gtsmi|||; get pad length|13768
||err|1,145|26,lpad second argument is not integer|||13769
||ppm|6,slpd4|||; skip if negative or large|13770
;
;      merge to check first arg
;
|slpd1|jsr|6,gtstg|||; get first argument (string to pad)|13774
||err|1,146|26,lpad first argument is not a string|||13775
||bge|8,wa|8,wc|6,exixr|; return 1st arg if too long to pad|13776
||mov|7,xl|7,xr||; else move ptr to string to pad|13777
;
;      now we are ready for the pad
;
;      (xl)		     pointer to string to pad
;      (wb)		     pad character
;      (wc)		     length to pad string to
;
||mov|8,wa|8,wc||; copy length|13785
||jsr|6,alocs|||; allocate scblk for new string|13786
||mov|11,-(xs)|7,xr||; save as result|13787
||mov|8,wa|13,sclen(xl)||; load length of argument|13788
||sub|8,wc|8,wa||; calculate number of pad characters|13789
||psc|7,xr|||; point to chars in result string|13790
||lct|8,wc|8,wc||; set counter for pad loop|13791
;
;      loop to perform pad
;
|slpd2|sch|8,wb|10,(xr)+||; store pad character, bump ptr|13795
||bct|8,wc|6,slpd2||; loop till all pad chars stored|13796
||csc|7,xr|||; complete store characters|13797
;
;      now copy string
;
||bze|8,wa|6,slpd3||; exit if null string|13801
||plc|7,xl|||; else point to chars in argument|13802
||mvc||||; move characters to result string|13803
||zer|7,xl|||; clear garbage xl|13804
;
;      here to exit with result on stack
;
|slpd3|lcw|7,xr|||; load next code word|13808
||bri|9,(xr)|||; execute it|13809
;
;      here if 2nd arg is negative or large
;
|slpd4|zer|8,wc|||; zero pad count|13813
||brn|6,slpd1|||; merge|13814
||ejc|||||13815
;
;      lt
;
|s_ltf|ent||||; entry point|13819
||jsr|6,acomp|||; call arithmetic comparison routine|13820
||err|1,147|26,lt first argument is not numeric|||13821
||err|1,148|26,lt second argument is not numeric|||13822
||ppm|6,exnul|||; return null if lt|13823
||ppm|6,exfal|||; fail if eq|13824
||ppm|6,exfal|||; fail if gt|13825
||ejc|||||13826
;
;      ne
;
|s_nef|ent||||; entry point|13830
||jsr|6,acomp|||; call arithmetic comparison routine|13831
||err|1,149|26,ne first argument is not numeric|||13832
||err|1,150|26,ne second argument is not numeric|||13833
||ppm|6,exnul|||; return null if lt|13834
||ppm|6,exfal|||; fail if eq|13835
||ppm|6,exnul|||; return null if gt|13836
||ejc|||||13837
;
;      notany
;
|s_nay|ent||||; entry point|13841
||mov|8,wb|22,=p_nas||; set pcode for single char arg|13842
||mov|7,xl|22,=p_nay||; pcode for multi-char arg|13843
||mov|8,wc|22,=p_nad||; set pcode for expr arg|13844
||jsr|6,patst|||; call common routine to build node|13845
||err|1,151|26,notany argument is not a string or expression|||13846
||mov|11,-(xs)|7,xr||; stack result|13847
||lcw|7,xr|||; get next code word|13848
||bri|9,(xr)|||; execute it|13849
||ejc|||||13850
;
;      opsyn
;
|s_ops|ent||||; entry point|13854
||jsr|6,gtsmi|||; load third argument|13855
||err|1,152|26,opsyn third argument is not integer|||13856
||err|1,153|26,opsyn third argument is negative or too large|||13857
||mov|8,wb|8,wc||; if ok, save third argumnet|13858
||mov|7,xr|10,(xs)+||; load second argument|13859
||jsr|6,gtnvr|||; locate variable block|13860
||err|1,154|26,opsyn second arg is not natural variable name|||13861
||mov|7,xl|13,vrfnc(xr)||; if ok, load function block pointer|13862
||bnz|8,wb|6,sops2||; jump if operator opsyn case|13863
;
;      here for function opsyn (third arg zero)
;
||mov|7,xr|10,(xs)+||; load first argument|13867
||jsr|6,gtnvr|||; get vrblk pointer|13868
||err|1,155|26,opsyn first arg is not natural variable name|||13869
;
;      merge here to perform function definition
;
|sops1|jsr|6,dffnc|||; call function definer|13873
||brn|6,exnul|||; exit with null result|13874
;
;      here for operator opsyn (third arg non-zero)
;
|sops2|jsr|6,gtstg|||; get operator name|13878
||ppm|6,sops5|||; jump if not string|13879
||bne|8,wa|18,=num01|6,sops5|; error if not one char long|13880
||plc|7,xr|||; else point to character|13881
||lch|8,wc|9,(xr)||; load character name|13882
||ejc|||||13883
;
;      opsyn (continued)
;
;      now set to search for matching unary or binary operator
;      name as appropriate. note that there are =opbun undefined
;      binary operators and =opuun undefined unary operators.
;
||mov|8,wa|20,=r_uub||; point to unop pointers in case|13891
||mov|7,xr|21,=opnsu||; point to names of unary operators|13892
||add|8,wb|18,=opbun||; add no. of undefined binary ops|13893
||beq|8,wb|18,=opuun|6,sops3|; jump if unop (third arg was 1)|13894
||mov|8,wa|20,=r_uba||; else point to binary operator ptrs|13895
||mov|7,xr|21,=opsnb||; point to names of binary operators|13896
||mov|8,wb|18,=opbun||; set number of undefined binops|13897
;
;      merge here to check list (wb = number to check)
;
|sops3|lct|8,wb|8,wb||; set counter to control loop|13901
;
;      loop to search for name match
;
|sops4|beq|8,wc|9,(xr)|6,sops6|; jump if names match|13905
||ica|8,wa|||; else push pointer to function ptr|13906
||ica|7,xr|||; bump pointer|13907
||bct|8,wb|6,sops4||; loop back till all checked|13908
;
;      here if bad operator name
;
|sops5|erb|1,156|26,opsyn first arg is not correct operator name|||13912
;
;      come here on finding a match in the operator name table
;
|sops6|mov|7,xr|8,wa||; copy pointer to function block ptr|13916
||sub|7,xr|19,*vrfnc||; make it look like dummy vrblk|13917
||brn|6,sops1|||; merge back to define operator|13918
||ejc|||||13919
;
;      output
;
|s_oup|ent||||; entry point|13944
||mov|8,wb|18,=num03||; output flag|13945
||jsr|6,ioput|||; call input/output assoc. routine|13946
||err|1,157|26,output third argument is not a string|||13947
||err|1,158|26,inappropriate second argument for output|||13948
||err|1,159|26,inappropriate first argument for output|||13949
||err|1,160|26,inappropriate file specification for output|||13950
||ppm|6,exfal|||; fail if file does not exist|13951
||err|1,161|26,output file cannot be written to|||13952
||err|1,290|26,output channel currently in use|||13953
||brn|6,exnul|||; return null string|13954
||ejc|||||13955
;
;      pos
;
|s_pos|ent||||; entry point|13959
||mov|8,wb|22,=p_pos||; set pcode for integer arg case|13960
||mov|8,wa|22,=p_psd||; set pcode for expression arg case|13961
||jsr|6,patin|||; call common routine to build node|13962
||err|1,162|26,pos argument is not integer or expression|||13963
||err|1,163|26,pos argument is negative or too large|||13964
||mov|11,-(xs)|7,xr||; stack result|13965
||lcw|7,xr|||; get next code word|13966
||bri|9,(xr)|||; execute it|13967
||ejc|||||13968
;
;      prototype
;
|s_pro|ent||||; entry point|13972
||mov|7,xr|10,(xs)+||; load argument|13973
||mov|8,wb|13,tblen(xr)||; length if table, vector (=vclen)|13974
||btw|8,wb|||; convert to words|13975
||mov|8,wa|9,(xr)||; load type word of argument block|13976
||beq|8,wa|22,=b_art|6,spro4|; jump if array|13977
||beq|8,wa|22,=b_tbt|6,spro1|; jump if table|13978
||beq|8,wa|22,=b_vct|6,spro3|; jump if vector|13979
||erb|1,164|26,prototype argument is not valid object|||13984
;
;      here for table
;
|spro1|sub|8,wb|18,=tbsi_||; subtract standard fields|13988
;
;      merge for vector
;
|spro2|mti|8,wb|||; convert to integer|13992
||brn|6,exint|||; exit with integer result|13993
;
;      here for vector
;
|spro3|sub|8,wb|18,=vcsi_||; subtract standard fields|13997
||brn|6,spro2|||; merge|13998
;
;      here for array
;
|spro4|add|7,xr|13,arofs(xr)||; point to prototype field|14002
||mov|7,xr|9,(xr)||; load prototype|14003
||mov|11,-(xs)|7,xr||; stack result|14004
||lcw|7,xr|||; get next code word|14005
||bri|9,(xr)|||; execute it|14006
||ejc|||||14016
;
;      remdr
;
|s_rmd|ent||||; entry point|14020
||jsr|6,arith|||; get two integers or two reals|14022
||err|1,166|26,remdr first argument is not numeric|||14023
||err|1,165|26,remdr second argument is not numeric|||14024
||ppm|6,srm06|||; if real|14025
;
;      both arguments integer
;
||zer|8,wb|||; set positive flag|14042
||ldi|13,icval(xr)|||; load left argument value|14043
||ige|6,srm01|||; jump if positive|14044
||mnz|8,wb|||; set negative flag|14045
|srm01|rmi|13,icval(xl)|||; get remainder|14046
||iov|6,srm05|||; error if overflow|14047
;
;      make sign of result match sign of first argument
;
||bze|8,wb|6,srm03||; if result should be positive|14051
||ile|6,exint|||; if should be negative, and is|14052
|srm02|ngi||||; adjust sign of result|14053
||brn|6,exint|||; return result|14054
|srm03|ilt|6,srm02|||; should be pos, and result negative|14055
||brn|6,exint|||; should be positive, and is|14056
;
;      fail first argument
;
|srm04|erb|1,166|26,remdr first argument is not numeric|||14060
;
;      fail if overflow
;
|srm05|erb|1,167|26,remdr caused integer overflow|||14064
;
;      here with 1st argument in (xr), 2nd in (xl), both real
;
;      result = n1 - chop(n1/n2)*n2
;
|srm06|zer|8,wb|||; set positive flag|14071
||ldr|13,rcval(xr)|||; load left argument value|14072
||rge|6,srm07|||; jump if positive|14073
||mnz|8,wb|||; set negative flag|14074
|srm07|dvr|13,rcval(xl)|||; compute n1/n2|14075
||rov|6,srm10|||; jump if overflow|14076
||chp||||; chop result|14077
||mlr|13,rcval(xl)|||; times n2|14078
||sbr|13,rcval(xr)|||; compute difference|14079
;
;      make sign of result match sign of first argument
;      -result is in ra at this point
;
||bze|8,wb|6,srm09||; if result should be positive|14084
||rle|6,exrea|||; if should be negative, and is|14085
|srm08|ngr||||; adjust sign of result|14086
||brn|6,exrea|||; return result|14087
|srm09|rlt|6,srm08|||; should be pos, and result negative|14088
||brn|6,exrea|||; should be positive, and is|14089
;
;      fail if overflow
;
|srm10|erb|1,312|26,remdr caused real overflow|||14093
||ejc|||||14095
;
;      replace
;
;      the actual replace operation uses an scblk whose cfp_a
;      chars contain the translated versions of all the chars.
;      the table pointer is remembered from call to call and
;      the table is only built when the arguments change.
;
;      we also perform an optimization gleaned from spitbol 370.
;      if the second argument is &alphabet, there is no need to
;      to build a replace table.  the third argument can be
;      used directly as the replace table.
;
|s_rpl|ent||||; entry point|14109
||jsr|6,gtstg|||; load third argument as string|14110
||err|1,168|26,replace third argument is not a string|||14111
||mov|7,xl|7,xr||; save third arg ptr|14112
||jsr|6,gtstg|||; get second argument|14113
||err|1,169|26,replace second argument is not a string|||14114
;
;      check to see if this is the same table as last time
;
||bne|7,xr|3,r_ra2|6,srpl1|; jump if 2nd argument different|14118
||beq|7,xl|3,r_ra3|6,srpl4|; jump if args same as last time|14119
;
;      here we build a new replace table (note wa = 2nd arg len)
;
|srpl1|mov|8,wb|13,sclen(xl)||; load 3rd argument length|14123
||bne|8,wa|8,wb|6,srpl6|; jump if arguments not same length|14124
||beq|7,xr|3,kvalp|6,srpl5|; jump if 2nd arg is alphabet string|14125
||bze|8,wb|6,srpl6||; jump if null 2nd argument|14126
||mov|3,r_ra3|7,xl||; save third arg for next time in|14127
||mov|3,r_ra2|7,xr||; save second arg for next time in|14128
||mov|7,xl|3,kvalp||; point to alphabet string|14129
||mov|8,wa|13,sclen(xl)||; load alphabet scblk length|14130
||mov|7,xr|3,r_rpt||; point to current table (if any)|14131
||bnz|7,xr|6,srpl2||; jump if we already have a table|14132
;
;      here we allocate a new table
;
||jsr|6,alocs|||; allocate new table|14136
||mov|8,wa|8,wc||; keep scblk length|14137
||mov|3,r_rpt|7,xr||; save table pointer for next time|14138
;
;      merge here with pointer to new table block in (xr)
;
|srpl2|ctb|8,wa|2,scsi_||; compute length of scblk|14142
||mvw||||; copy to get initial table values|14143
||ejc|||||14144
;
;      replace (continued)
;
;      now we must plug selected entries as required. note that
;      we are short of index registers for the following loop.
;      hence the need to repeatedly re-initialise char ptr xl
;
||mov|7,xl|3,r_ra2||; point to second argument|14152
||lct|8,wb|8,wb||; number of chars to plug|14153
||zer|8,wc|||; zero char offset|14154
||mov|7,xr|3,r_ra3||; point to 3rd arg|14155
||plc|7,xr|||; get char ptr for 3rd arg|14156
;
;      loop to plug chars
;
|srpl3|mov|7,xl|3,r_ra2||; point to 2nd arg|14160
||plc|7,xl|8,wc||; point to next char|14161
||icv|8,wc|||; increment offset|14162
||lch|8,wa|9,(xl)||; get next char|14163
||mov|7,xl|3,r_rpt||; point to translate table|14164
||psc|7,xl|8,wa||; convert char to offset into table|14165
||lch|8,wa|10,(xr)+||; get translated char|14166
||sch|8,wa|9,(xl)||; store in table|14167
||csc|7,xl|||; complete store characters|14168
||bct|8,wb|6,srpl3||; loop till done|14169
||ejc|||||14170
;
;      replace (continued)
;
;      here to use r_rpt as replace table.
;
|srpl4|mov|7,xl|3,r_rpt||; replace table to use|14176
;
;      here to perform translate using table in xl.
;
|srpl5|jsr|6,gtstg|||; get first argument|14181
||err|1,170|26,replace first argument is not a string|||14182
||bze|8,wa|6,exnul||; return null if null argument|14191
||mov|11,-(xs)|7,xl||; stack replace table to use|14192
||mov|7,xl|7,xr||; copy pointer|14193
||mov|8,wc|8,wa||; save length|14194
||ctb|8,wa|2,schar||; get scblk length|14195
||jsr|6,alloc|||; allocate space for copy|14196
||mov|8,wb|7,xr||; save address of copy|14197
||mvw||||; move scblk contents to copy|14198
||mov|7,xr|10,(xs)+||; unstack replace table|14199
||plc|7,xr|||; point to chars of table|14200
||mov|7,xl|8,wb||; point to string to translate|14201
||plc|7,xl|||; point to chars of string|14202
||mov|8,wa|8,wc||; set number of chars to translate|14203
||trc||||; perform translation|14204
|srpl8|mov|11,-(xs)|8,wb||; stack result|14205
||lcw|7,xr|||; load next code word|14206
||bri|9,(xr)|||; execute it|14207
;
;      error point
;
|srpl6|erb|1,171|26,null or unequally long 2nd, 3rd args to replace|||14211
||ejc|||||14226
;
;      rewind
;
|s_rew|ent||||; entry point|14230
||jsr|6,iofcb|||; call fcblk routine|14231
||err|1,172|26,rewind argument is not a suitable name|||14232
||err|1,173|26,rewind argument is null|||14233
||err|1,174|26,rewind file does not exist|||14234
||jsr|6,sysrw|||; call system rewind function|14235
||err|1,174|26,rewind file does not exist|||14236
||err|1,175|26,rewind file does not permit rewind|||14237
||err|1,176|26,rewind caused non-recoverable error|||14238
||brn|6,exnul|||; exit with null result if no error|14239
||ejc|||||14240
;
;      reverse
;
|s_rvs|ent||||; entry point|14244
||jsr|6,gtstg|||; load string argument|14246
||err|1,177|26,reverse argument is not a string|||14247
||bze|8,wa|6,exixr||; return argument if null|14253
||mov|7,xl|7,xr||; else save pointer to string arg|14254
||jsr|6,alocs|||; allocate space for new scblk|14255
||mov|11,-(xs)|7,xr||; store scblk ptr on stack as result|14256
||psc|7,xr|||; prepare to store in new scblk|14257
||plc|7,xl|8,wc||; point past last char in argument|14258
||lct|8,wc|8,wc||; set loop counter|14259
;
;      loop to move chars in reverse order
;
|srvs1|lch|8,wb|11,-(xl)||; load next char from argument|14263
||sch|8,wb|10,(xr)+||; store in result|14264
||bct|8,wc|6,srvs1||; loop till all moved|14265
;
;      here when complete to execute next code word
;
|srvs4|csc|7,xr|||; complete store characters|14269
||zer|7,xl|||; clear garbage xl|14270
|srvs2|lcw|7,xr|||; load next code word|14271
||bri|9,(xr)|||; execute it|14272
||ejc|||||14296
;
;      rpad
;
|s_rpd|ent||||; entry point|14300
||jsr|6,gtstg|||; get pad character|14301
||err|1,178|26,rpad third argument is not a string|||14302
||plc|7,xr|||; point to character (null is blank)|14303
||lch|8,wb|9,(xr)||; load pad character|14304
||jsr|6,gtsmi|||; get pad length|14305
||err|1,179|26,rpad second argument is not integer|||14306
||ppm|6,srpd3|||; skip if negative or large|14307
;
;      merge to check first arg.
;
|srpd1|jsr|6,gtstg|||; get first argument (string to pad)|14311
||err|1,180|26,rpad first argument is not a string|||14312
||bge|8,wa|8,wc|6,exixr|; return 1st arg if too long to pad|14313
||mov|7,xl|7,xr||; else move ptr to string to pad|14314
;
;      now we are ready for the pad
;
;      (xl)		     pointer to string to pad
;      (wb)		     pad character
;      (wc)		     length to pad string to
;
||mov|8,wa|8,wc||; copy length|14322
||jsr|6,alocs|||; allocate scblk for new string|14323
||mov|11,-(xs)|7,xr||; save as result|14324
||mov|8,wa|13,sclen(xl)||; load length of argument|14325
||sub|8,wc|8,wa||; calculate number of pad characters|14326
||psc|7,xr|||; point to chars in result string|14327
||lct|8,wc|8,wc||; set counter for pad loop|14328
;
;      copy argument string
;
||bze|8,wa|6,srpd2||; jump if argument is null|14332
||plc|7,xl|||; else point to argument chars|14333
||mvc||||; move characters to result string|14334
||zer|7,xl|||; clear garbage xl|14335
;
;      loop to supply pad characters
;
|srpd2|sch|8,wb|10,(xr)+||; store pad character, bump ptr|14339
||bct|8,wc|6,srpd2||; loop till all pad chars stored|14340
||csc|7,xr|||; complete character storing|14341
||lcw|7,xr|||; load next code word|14342
||bri|9,(xr)|||; execute it|14343
;
;      here if 2nd arg is negative or large
;
|srpd3|zer|8,wc|||; zero pad count|14347
||brn|6,srpd1|||; merge|14348
||ejc|||||14349
;
;      rtab
;
|s_rtb|ent||||; entry point|14353
||mov|8,wb|22,=p_rtb||; set pcode for integer arg case|14354
||mov|8,wa|22,=p_rtd||; set pcode for expression arg case|14355
||jsr|6,patin|||; call common routine to build node|14356
||err|1,181|26,rtab argument is not integer or expression|||14357
||err|1,182|26,rtab argument is negative or too large|||14358
||mov|11,-(xs)|7,xr||; stack result|14359
||lcw|7,xr|||; get next code word|14360
||bri|9,(xr)|||; execute it|14361
||ejc|||||14362
;
;      set
;
|s_set|ent||||; entry point|14367
||mov|3,r_io2|10,(xs)+||; save third arg (whence)|14368
||mov|3,r_io1|10,(xs)+||; save second arg (offset)|14375
||jsr|6,iofcb|||; call fcblk routine|14377
||err|1,291|26,set first argument is not a suitable name|||14378
||err|1,292|26,set first argument is null|||14379
||err|1,295|26,set file does not exist|||14380
||mov|8,wb|3,r_io1||; load second arg|14383
||mov|8,wc|3,r_io2||; load third arg|14385
||jsr|6,sysst|||; call system set routine|14386
||err|1,293|26,inappropriate second argument to set|||14387
||err|1,294|26,inappropriate third argument to set|||14388
||err|1,295|26,set file does not exist|||14389
||err|1,296|26,set file does not permit setting file pointer|||14390
||err|1,297|26,set caused non-recoverable i/o error|||14391
||brn|6,exint|||; otherwise return position|14396
||ejc|||||14398
;
;      tab
;
|s_tab|ent||||; entry point|14403
||mov|8,wb|22,=p_tab||; set pcode for integer arg case|14404
||mov|8,wa|22,=p_tbd||; set pcode for expression arg case|14405
||jsr|6,patin|||; call common routine to build node|14406
||err|1,183|26,tab argument is not integer or expression|||14407
||err|1,184|26,tab argument is negative or too large|||14408
||mov|11,-(xs)|7,xr||; stack result|14409
||lcw|7,xr|||; get next code word|14410
||bri|9,(xr)|||; execute it|14411
||ejc|||||14412
;
;      rpos
;
|s_rps|ent||||; entry point|14416
||mov|8,wb|22,=p_rps||; set pcode for integer arg case|14417
||mov|8,wa|22,=p_rpd||; set pcode for expression arg case|14418
||jsr|6,patin|||; call common routine to build node|14419
||err|1,185|26,rpos argument is not integer or expression|||14420
||err|1,186|26,rpos argument is negative or too large|||14421
||mov|11,-(xs)|7,xr||; stack result|14422
||lcw|7,xr|||; get next code word|14423
||bri|9,(xr)|||; execute it|14424
||ejc|||||14427
;
;      rsort
;
|s_rsr|ent||||; entry point|14431
||mnz|8,wa|||; mark as rsort|14432
||jsr|6,sorta|||; call sort routine|14433
||ppm|6,exfal|||; if conversion fails, so shall we|14434
||brn|6,exsid|||; return, setting idval|14435
||ejc|||||14437
;
;      setexit
;
|s_stx|ent||||; entry point|14441
||mov|7,xr|10,(xs)+||; load argument|14442
||mov|8,wa|3,stxvr||; load old vrblk pointer|14443
||zer|7,xl|||; load zero in case null arg|14444
||beq|7,xr|21,=nulls|6,sstx1|; jump if null argument (reset call)|14445
||jsr|6,gtnvr|||; else get specified vrblk|14446
||ppm|6,sstx2|||; jump if not natural variable|14447
||mov|7,xl|13,vrlbl(xr)||; else load label|14448
||beq|7,xl|21,=stndl|6,sstx2|; jump if label is not defined|14449
||bne|9,(xl)|22,=b_trt|6,sstx1|; jump if not trapped|14450
||mov|7,xl|13,trlbl(xl)||; else load ptr to real label code|14451
;
;      here to set/reset setexit trap
;
|sstx1|mov|3,stxvr|7,xr||; store new vrblk pointer (or null)|14455
||mov|3,r_sxc|7,xl||; store new code ptr (or zero)|14456
||beq|8,wa|21,=nulls|6,exnul|; return null if null result|14457
||mov|7,xr|8,wa||; else copy vrblk pointer|14458
||brn|6,exvnm|||; and return building nmblk|14459
;
;      here if bad argument
;
|sstx2|erb|1,187|26,setexit argument is not label name or null|||14463
;
;      sin
;
|s_sin|ent||||; entry point|14468
||mov|7,xr|10,(xs)+||; get argument|14469
||jsr|6,gtrea|||; convert to real|14470
||err|1,308|26,sin argument not numeric|||14471
||ldr|13,rcval(xr)|||; load accumulator with argument|14472
||sin||||; take sine|14473
||rno|6,exrea|||; if no overflow, return result in ra|14474
||erb|1,323|26,sin argument is out of range|||14475
||ejc|||||14476
;
;      sqrt
;
|s_sqr|ent||||; entry point|14482
||mov|7,xr|10,(xs)+||; get argument|14483
||jsr|6,gtrea|||; convert to real|14484
||err|1,313|26,sqrt argument not numeric|||14485
||ldr|13,rcval(xr)|||; load accumulator with argument|14486
||rlt|6,ssqr1|||; negative number|14487
||sqr||||; take square root|14488
||brn|6,exrea|||; no overflow possible, result in ra|14489
;
;      here if bad argument
;
|ssqr1|erb|1,314|26,sqrt argument negative|||14493
||ejc|||||14494
||ejc|||||14498
;
;      sort
;
|s_srt|ent||||; entry point|14502
||zer|8,wa|||; mark as sort|14503
||jsr|6,sorta|||; call sort routine|14504
||ppm|6,exfal|||; if conversion fails, so shall we|14505
||brn|6,exsid|||; return, setting idval|14506
||ejc|||||14508
;
;      span
;
|s_spn|ent||||; entry point|14512
||mov|8,wb|22,=p_sps||; set pcode for single char arg|14513
||mov|7,xl|22,=p_spn||; set pcode for multi-char arg|14514
||mov|8,wc|22,=p_spd||; set pcode for expression arg|14515
||jsr|6,patst|||; call common routine to build node|14516
||err|1,188|26,span argument is not a string or expression|||14517
||mov|11,-(xs)|7,xr||; stack result|14518
||lcw|7,xr|||; get next code word|14519
||bri|9,(xr)|||; execute it|14520
||ejc|||||14521
;
;      size
;
|s_si_|ent||||; entry point|14525
||jsr|6,gtstg|||; load string argument|14527
||err|1,189|26,size argument is not a string|||14528
;
;      merge with bfblk or scblk ptr in xr.  wa has length.
;
||mti|8,wa|||; load length as integer|14536
||brn|6,exint|||; exit with integer result|14537
||ejc|||||14538
;
;      stoptr
;
|s_stt|ent||||; entry point|14542
||zer|7,xl|||; indicate stoptr case|14543
||jsr|6,trace|||; call trace procedure|14544
||err|1,190|26,stoptr first argument is not appropriate name|||14545
||err|1,191|26,stoptr second argument is not trace type|||14546
||brn|6,exnul|||; return null|14547
||ejc|||||14548
;
;      substr
;
|s_sub|ent||||; entry point|14552
||jsr|6,gtsmi|||; load third argument|14553
||err|1,192|26,substr third argument is not integer|||14554
||ppm|6,exfal|||; jump if negative or too large|14555
||mov|3,sbssv|7,xr||; save third argument|14556
||jsr|6,gtsmi|||; load second argument|14557
||err|1,193|26,substr second argument is not integer|||14558
||ppm|6,exfal|||; jump if out of range|14559
||mov|8,wc|7,xr||; save second argument|14560
||bze|8,wc|6,exfal||; jump if second argument zero|14561
||dcv|8,wc|||; else decrement for ones origin|14562
||jsr|6,gtstg|||; load first argument|14564
||err|1,194|26,substr first argument is not a string|||14565
;
;      merge with bfblk or scblk ptr in xr.  wa has length
;
||mov|8,wb|8,wc||; copy second arg to wb|14573
||mov|8,wc|3,sbssv||; reload third argument|14574
||bnz|8,wc|6,ssub2||; skip if third arg given|14575
||mov|8,wc|8,wa||; else get string length|14576
||bgt|8,wb|8,wc|6,exfal|; fail if improper|14577
||sub|8,wc|8,wb||; reduce by offset to start|14578
;
;      merge
;
|ssub2|mov|7,xl|8,wa||; save string length|14582
||mov|8,wa|8,wc||; set length of substring|14583
||add|8,wc|8,wb||; add 2nd arg to 3rd arg|14584
||bgt|8,wc|7,xl|6,exfal|; jump if improper substring|14585
||mov|7,xl|7,xr||; copy pointer to first arg|14586
||jsr|6,sbstr|||; build substring|14587
||mov|11,-(xs)|7,xr||; stack result|14588
||lcw|7,xr|||; get next code word|14589
||bri|9,(xr)|||; execute it|14590
||ejc|||||14591
;
;      table
;
|s_tbl|ent||||; entry point|14595
||mov|7,xl|10,(xs)+||; get initial lookup value|14596
||ica|7,xs|||; pop second argument|14597
||jsr|6,gtsmi|||; load argument|14598
||err|1,195|26,table argument is not integer|||14599
||err|1,196|26,table argument is out of range|||14600
||bnz|8,wc|6,stbl1||; jump if non-zero|14601
||mov|8,wc|18,=tbnbk||; else supply default value|14602
;
;      merge here with number of headers in wc
;
|stbl1|jsr|6,tmake|||; make table|14606
||brn|6,exsid|||; exit setting idval|14607
||ejc|||||14608
;
;      tan
;
|s_tan|ent||||; entry point|14613
||mov|7,xr|10,(xs)+||; get argument|14614
||jsr|6,gtrea|||; convert to real|14615
||err|1,309|26,tan argument not numeric|||14616
||ldr|13,rcval(xr)|||; load accumulator with argument|14617
||tan||||; take tangent|14618
||rno|6,exrea|||; if no overflow, return result in ra|14619
||erb|1,310|26,tan produced real overflow or argument is out of range|||14620
||ejc|||||14621
;
;      time
;
|s_tim|ent||||; entry point|14626
||jsr|6,systm|||; get timer value|14627
||sbi|3,timsx|||; subtract starting time|14628
||brn|6,exint|||; exit with integer value|14629
||ejc|||||14630
;
;      trace
;
|s_tra|ent||||; entry point|14634
||beq|13,num03(xs)|21,=nulls|6,str02|; jump if first argument is null|14635
||mov|7,xr|10,(xs)+||; load fourth argument|14636
||zer|7,xl|||; tentatively set zero pointer|14637
||beq|7,xr|21,=nulls|6,str01|; jump if 4th argument is null|14638
||jsr|6,gtnvr|||; else point to vrblk|14639
||ppm|6,str03|||; jump if not variable name|14640
||mov|7,xl|7,xr||; else save vrblk in trfnc|14641
;
;      here with vrblk or zero in xl
;
|str01|mov|7,xr|10,(xs)+||; load third argument (tag)|14645
||zer|8,wb|||; set zero as trtyp value for now|14646
||jsr|6,trbld|||; build trblk for trace call|14647
||mov|7,xl|7,xr||; move trblk pointer for trace|14648
||jsr|6,trace|||; call trace procedure|14649
||err|1,198|26,trace first argument is not appropriate name|||14650
||err|1,199|26,trace second argument is not trace type|||14651
||brn|6,exnul|||; return null|14652
;
;      here to call system trace toggle routine
;
|str02|jsr|6,systt|||; call it|14656
||add|7,xs|19,*num04||; pop trace arguments|14657
||brn|6,exnul|||; return|14658
;
;      here for bad fourth argument
;
|str03|erb|1,197|26,trace fourth arg is not function name or null|||14662
||ejc|||||14663
;
;      trim
;
|s_trm|ent||||; entry point|14667
||jsr|6,gtstg|||; load argument as string|14669
||err|1,200|26,trim argument is not a string|||14670
||bze|8,wa|6,exnul||; return null if argument is null|14676
||mov|7,xl|7,xr||; copy string pointer|14677
||ctb|8,wa|2,schar||; get block length|14678
||jsr|6,alloc|||; allocate copy same size|14679
||mov|8,wb|7,xr||; save pointer to copy|14680
||mvw||||; copy old string block to new|14681
||mov|7,xr|8,wb||; restore ptr to new block|14682
||jsr|6,trimr|||; trim blanks (wb is non-zero)|14683
||mov|11,-(xs)|7,xr||; stack result|14684
||lcw|7,xr|||; get next code word|14685
||bri|9,(xr)|||; execute it|14686
||ejc|||||14729
;
;      unload
;
|s_unl|ent||||; entry point|14733
||mov|7,xr|10,(xs)+||; load argument|14734
||jsr|6,gtnvr|||; point to vrblk|14735
||err|1,201|26,unload argument is not natural variable name|||14736
||mov|7,xl|21,=stndf||; get ptr to undefined function|14737
||jsr|6,dffnc|||; undefine named function|14738
||brn|6,exnul|||; return null as result|14739
||ttl|27,s p i t b o l -- utility routines||||14761
;
;      the following section contains utility routines used for
;      various purposes throughout the system. these differ
;      from the procedures in the utility procedures section in
;      they are not in procedure form and they do not return
;      to their callers. they are accessed with a branch type
;      instruction after setting the registers to appropriate
;      parameter values.
;
;      the register values required for each routine are
;      documented at the start of each routine. registers not
;      mentioned may contain any values except that xr,xl
;      can only contain proper collectable pointers.
;
;      some of these routines will tolerate garbage pointers
;      in xl,xr on entry. this is always documented and in
;      each case, the routine clears these garbage values before
;      exiting after completing its task.
;
;      the routines have names consisting of five letters
;      and are assembled in alphabetical order.
||ejc|||||14783
;      arref -- array reference
;
;      (xl)		     may be non-collectable
;      (xr)		     number of subscripts
;      (wb)		     set zero/nonzero for value/name
;			     the value in wb must be collectable
;      stack		     subscripts and array operand
;      brn  arref	     jump to call function
;
;      arref continues by executing the next code word with
;      the result name or value placed on top of the stack.
;      to deal with the problem of accessing subscripts in the
;      order of stacking, xl is used as a subscript pointer
;      working below the stack pointer.
;
|arref|rtn|||||14799
||mov|8,wa|7,xr||; copy number of subscripts|14800
||mov|7,xt|7,xs||; point to stack front|14801
||wtb|7,xr|||; convert to byte offset|14802
||add|7,xt|7,xr||; point to array operand on stack|14803
||ica|7,xt|||; final value for stack popping|14804
||mov|3,arfxs|7,xt||; keep for later|14805
||mov|7,xr|11,-(xt)||; load array operand pointer|14806
||mov|3,r_arf|7,xr||; keep array pointer|14807
||mov|7,xr|7,xt||; save pointer to subscripts|14808
||mov|7,xl|3,r_arf||; point xl to possible vcblk or tbblk|14809
||mov|8,wc|9,(xl)||; load first word|14810
||beq|8,wc|22,=b_art|6,arf01|; jump if arblk|14811
||beq|8,wc|22,=b_vct|6,arf07|; jump if vcblk|14812
||beq|8,wc|22,=b_tbt|6,arf10|; jump if tbblk|14813
||erb|1,235|26,subscripted operand is not table or array|||14814
;
;      here for array (arblk)
;
|arf01|bne|8,wa|13,arndm(xl)|6,arf09|; jump if wrong number of dims|14818
||ldi|4,intv0|||; get initial subscript of zero|14819
||mov|7,xt|7,xr||; point before subscripts|14820
||zer|8,wa|||; initial offset to bounds|14821
||brn|6,arf03|||; jump into loop|14822
;
;      loop to compute subscripts by multiplications
;
|arf02|mli|13,ardm2(xr)|||; multiply total by next dimension|14826
;
;      merge here first time
;
|arf03|mov|7,xr|11,-(xt)||; load next subscript|14830
||sti|3,arfsi|||; save current subscript|14831
||ldi|13,icval(xr)|||; load integer value in case|14832
||beq|9,(xr)|22,=b_icl|6,arf04|; jump if it was an integer|14833
||ejc|||||14834
;
;      arref (continued)
;
;
||jsr|6,gtint|||; convert to integer|14839
||ppm|6,arf12|||; jump if not integer|14840
||ldi|13,icval(xr)|||; if ok, load integer value|14841
;
;      here with integer subscript in (ia)
;
|arf04|mov|7,xr|3,r_arf||; point to array|14845
||add|7,xr|8,wa||; offset to next bounds|14846
||sbi|13,arlbd(xr)|||; subtract low bound to compare|14847
||iov|6,arf13|||; out of range fail if overflow|14848
||ilt|6,arf13|||; out of range fail if too small|14849
||sbi|13,ardim(xr)|||; subtract dimension|14850
||ige|6,arf13|||; out of range fail if too large|14851
||adi|13,ardim(xr)|||; else restore subscript offset|14852
||adi|3,arfsi|||; add to current total|14853
||add|8,wa|19,*ardms||; point to next bounds|14854
||bne|7,xt|7,xs|6,arf02|; loop back if more to go|14855
;
;      here with integer subscript computed
;
||mfi|8,wa|||; get as one word integer|14859
||wtb|8,wa|||; convert to offset|14860
||mov|7,xl|3,r_arf||; point to arblk|14861
||add|8,wa|13,arofs(xl)||; add offset past bounds|14862
||ica|8,wa|||; adjust for arpro field|14863
||bnz|8,wb|6,arf08||; exit with name if name call|14864
;
;      merge here to get value for value call
;
|arf05|jsr|6,acess|||; get value|14868
||ppm|6,arf13|||; fail if acess fails|14869
;
;      return value
;
|arf06|mov|7,xs|3,arfxs||; pop stack entries|14873
||zer|3,r_arf|||; finished with array pointer|14874
||mov|11,-(xs)|7,xr||; stack result|14875
||lcw|7,xr|||; get next code word|14876
||bri|9,(xr)|||; execute it|14877
||ejc|||||14878
;
;      arref (continued)
;
;      here for vector
;
|arf07|bne|8,wa|18,=num01|6,arf09|; error if more than 1 subscript|14884
||mov|7,xr|9,(xs)||; else load subscript|14885
||jsr|6,gtint|||; convert to integer|14886
||ppm|6,arf12|||; error if not integer|14887
||ldi|13,icval(xr)|||; else load integer value|14888
||sbi|4,intv1|||; subtract for ones offset|14889
||mfi|8,wa|6,arf13||; get subscript as one word|14890
||add|8,wa|18,=vcvls||; add offset for standard fields|14891
||wtb|8,wa|||; convert offset to bytes|14892
||bge|8,wa|13,vclen(xl)|6,arf13|; fail if out of range subscript|14893
||bze|8,wb|6,arf05||; back to get value if value call|14894
;
;      return name
;
|arf08|mov|7,xs|3,arfxs||; pop stack entries|14898
||zer|3,r_arf|||; finished with array pointer|14899
||brn|6,exnam|||; else exit with name|14900
;
;      here if subscript count is wrong
;
|arf09|erb|1,236|26,array referenced with wrong number of subscripts|||14904
;
;      table
;
|arf10|bne|8,wa|18,=num01|6,arf11|; error if more than 1 subscript|14908
||mov|7,xr|9,(xs)||; else load subscript|14909
||jsr|6,tfind|||; call table search routine|14910
||ppm|6,arf13|||; fail if failed|14911
||bnz|8,wb|6,arf08||; exit with name if name call|14912
||brn|6,arf06|||; else exit with value|14913
;
;      here for bad table reference
;
|arf11|erb|1,237|26,table referenced with more than one subscript|||14917
;
;      here for bad subscript
;
|arf12|erb|1,238|26,array subscript is not integer|||14921
;
;      here to signal failure
;
|arf13|zer|3,r_arf|||; finished with array pointer|14925
||brn|6,exfal|||; fail|14926
||ejc|||||14927
;
;      cfunc -- call a function
;
;      cfunc is used to call a snobol level function. it is
;      used by the apply function (s_app), the function
;      trace routine (trxeq) and the main function call entry
;      (o_fnc, o_fns). in the latter cases, cfunc is used only
;      if the number of arguments is incorrect.
;
;      (xl)		     pointer to function block
;      (wa)		     actual number of arguments
;      (xs)		     points to stacked arguments
;      brn  cfunc	     jump to call function
;
;      cfunc continues by executing the function
;
|cfunc|rtn|||||14944
||blt|8,wa|13,fargs(xl)|6,cfnc1|; jump if too few arguments|14945
||beq|8,wa|13,fargs(xl)|6,cfnc3|; jump if correct number of args|14946
;
;      here if too many arguments supplied, pop them off
;
||mov|8,wb|8,wa||; copy actual number|14950
||sub|8,wb|13,fargs(xl)||; get number of extra args|14951
||wtb|8,wb|||; convert to bytes|14952
||add|7,xs|8,wb||; pop off unwanted arguments|14953
||brn|6,cfnc3|||; jump to go off to function|14954
;
;      here if too few arguments
;
|cfnc1|mov|8,wb|13,fargs(xl)||; load required number of arguments|14958
||beq|8,wb|18,=nini9|6,cfnc3|; jump if case of var num of args|14959
||sub|8,wb|8,wa||; calculate number missing|14960
||lct|8,wb|8,wb||; set counter to control loop|14961
;
;      loop to supply extra null arguments
;
|cfnc2|mov|11,-(xs)|21,=nulls||; stack a null argument|14965
||bct|8,wb|6,cfnc2||; loop till proper number stacked|14966
;
;      merge here to jump to function
;
|cfnc3|bri|9,(xl)|||; jump through fcode field|14970
||ejc|||||14971
;
;      exfal -- exit signalling snobol failure
;
;      (xl,xr)		     may be non-collectable
;      brn  exfal	     jump to fail
;
;      exfal continues by executing the appropriate fail goto
;
|exfal|rtn|||||14980
||mov|7,xs|3,flptr||; pop stack|14981
||mov|7,xr|9,(xs)||; load failure offset|14982
||add|7,xr|3,r_cod||; point to failure code location|14983
||lcp|7,xr|||; set code pointer|14984
||lcw|7,xr|||; load next code word|14985
||mov|7,xl|9,(xr)||; load entry address|14986
||bri|7,xl|||; jump to execute next code word|14987
||ejc|||||14988
;
;      exint -- exit with integer result
;
;      (xl,xr)		     may be non-collectable
;      (ia)		     integer value
;      brn  exint	     jump to exit with integer
;
;      exint continues by executing the next code word
;      which it does by falling through to exixr
;
|exint|rtn|||||14999
||zer|7,xl|||; clear dud value|15000
||jsr|6,icbld|||; build icblk|15001
||ejc|||||15002
;      exixr -- exit with result in (xr)
;
;      (xr)		     result
;      (xl)		     may be non-collectable
;      brn  exixr	     jump to exit with result in (xr)
;
;      exixr continues by executing the next code word
;      which it does by falling through to exits.
|exixr|rtn|||||15011
;
||mov|11,-(xs)|7,xr||; stack result|15013
;
;
;      exits -- exit with result if any stacked
;
;      (xr,xl)		     may be non-collectable
;
;      brn  exits	     enter exits routine
;
|exits|rtn|||||15022
||lcw|7,xr|||; load next code word|15023
||mov|7,xl|9,(xr)||; load entry address|15024
||bri|7,xl|||; jump to execute next code word|15025
||ejc|||||15026
;
;      exnam -- exit with name in (xl,wa)
;
;      (xl)		     name base
;      (wa)		     name offset
;      (xr)		     may be non-collectable
;      brn  exnam	     jump to exit with name in (xl,wa)
;
;      exnam continues by executing the next code word
;
|exnam|rtn|||||15037
||mov|11,-(xs)|7,xl||; stack name base|15038
||mov|11,-(xs)|8,wa||; stack name offset|15039
||lcw|7,xr|||; load next code word|15040
||bri|9,(xr)|||; execute it|15041
||ejc|||||15042
;
;      exnul -- exit with null result
;
;      (xl,xr)		     may be non-collectable
;      brn  exnul	     jump to exit with null value
;
;      exnul continues by executing the next code word
;
|exnul|rtn|||||15051
||mov|11,-(xs)|21,=nulls||; stack null value|15052
||lcw|7,xr|||; load next code word|15053
||mov|7,xl|9,(xr)||; load entry address|15054
||bri|7,xl|||; jump to execute next code word|15055
||ejc|||||15056
;
;      exrea -- exit with real result
;
;      (xl,xr)		     may be non-collectable
;      (ra)		     real value
;      brn  exrea	     jump to exit with real value
;
;      exrea continues by executing the next code word
;
|exrea|rtn|||||15068
||zer|7,xl|||; clear dud value|15069
||jsr|6,rcbld|||; build rcblk|15070
||brn|6,exixr|||; jump to exit with result in xr|15071
||ejc|||||15073
;
;      exsid -- exit setting id field
;
;      exsid is used to exit after building any of the following
;      blocks (arblk, tbblk, pdblk, vcblk). it sets the idval.
;
;      (xr)		     ptr to block with idval field
;      (xl)		     may be non-collectable
;      brn  exsid	     jump to exit after setting id field
;
;      exsid continues by executing the next code word
;
|exsid|rtn|||||15086
||mov|8,wa|3,curid||; load current id value|15087
||bne|8,wa|3,mxint|6,exsi1|; jump if no overflow|15088
||zer|8,wa|||; else reset for wraparound|15089
;
;      here with old idval in wa
;
|exsi1|icv|8,wa|||; bump id value|15093
||mov|3,curid|8,wa||; store for next time|15094
||mov|13,idval(xr)|8,wa||; store id value|15095
||brn|6,exixr|||; exit with result in (xr)|15096
||ejc|||||15097
;
;      exvnm -- exit with name of variable
;
;      exvnm exits after stacking a value which is a nmblk
;      referencing the name of a given natural variable.
;
;      (xr)		     vrblk pointer
;      (xl)		     may be non-collectable
;      brn  exvnm	     exit with vrblk pointer in xr
;
|exvnm|rtn|||||15108
||mov|7,xl|7,xr||; copy name base pointer|15109
||mov|8,wa|19,*nmsi_||; set size of nmblk|15110
||jsr|6,alloc|||; allocate nmblk|15111
||mov|9,(xr)|22,=b_nml||; store type word|15112
||mov|13,nmbas(xr)|7,xl||; store name base|15113
||mov|13,nmofs(xr)|19,*vrval||; store name offset|15114
||brn|6,exixr|||; exit with result in xr|15115
||ejc|||||15116
;
;      flpop -- fail and pop in pattern matching
;
;      flpop pops the node and cursor on the stack and then
;      drops through into failp to cause pattern failure
;
;      (xl,xr)		     may be non-collectable
;      brn  flpop	     jump to fail and pop stack
;
|flpop|rtn|||||15126
||add|7,xs|19,*num02||; pop two entries off stack|15127
||ejc|||||15128
;
;      failp -- failure in matching pattern node
;
;      failp is used after failing to match a pattern node.
;      see pattern match routines for details of use.
;
;      (xl,xr)		     may be non-collectable
;      brn  failp	     signal failure to match
;
;      failp continues by matching an alternative from the stack
;
|failp|rtn|||||15140
||mov|7,xr|10,(xs)+||; load alternative node pointer|15141
||mov|8,wb|10,(xs)+||; restore old cursor|15142
||mov|7,xl|9,(xr)||; load pcode entry pointer|15143
||bri|7,xl|||; jump to execute code for node|15144
||ejc|||||15145
;
;      indir -- compute indirect reference
;
;      (wb)		     nonzero/zero for by name/value
;      brn  indir	     jump to get indirect ref on stack
;
;      indir continues by executing the next code word
;
|indir|rtn|||||15154
||mov|7,xr|10,(xs)+||; load argument|15155
||beq|9,(xr)|22,=b_nml|6,indr2|; jump if a name|15156
||jsr|6,gtnvr|||; else convert to variable|15157
||err|1,239|26,indirection operand is not name|||15158
||bze|8,wb|6,indr1||; skip if by value|15159
||mov|11,-(xs)|7,xr||; else stack vrblk ptr|15160
||mov|11,-(xs)|19,*vrval||; stack name offset|15161
||lcw|7,xr|||; load next code word|15162
||mov|7,xl|9,(xr)||; load entry address|15163
||bri|7,xl|||; jump to execute next code word|15164
;
;      here to get value of natural variable
;
|indr1|bri|9,(xr)|||; jump through vrget field of vrblk|15168
;
;      here if operand is a name
;
|indr2|mov|7,xl|13,nmbas(xr)||; load name base|15172
||mov|8,wa|13,nmofs(xr)||; load name offset|15173
||bnz|8,wb|6,exnam||; exit if called by name|15174
||jsr|6,acess|||; else get value first|15175
||ppm|6,exfal|||; fail if access fails|15176
||brn|6,exixr|||; else return with value in xr|15177
||ejc|||||15178
;
;      match -- initiate pattern match
;
;      (wb)		     match type code
;      brn  match	     jump to initiate pattern match
;
;      match continues by executing the pattern match. see
;      pattern match routines (p_xxx) for full details.
;
|match|rtn|||||15188
||mov|7,xr|10,(xs)+||; load pattern operand|15189
||jsr|6,gtpat|||; convert to pattern|15190
||err|1,240|26,pattern match right operand is not pattern|||15191
||mov|7,xl|7,xr||; if ok, save pattern pointer|15192
||bnz|8,wb|6,mtch1||; jump if not match by name|15193
||mov|8,wa|9,(xs)||; else load name offset|15194
||mov|11,-(xs)|7,xl||; save pattern pointer|15195
||mov|7,xl|13,num02(xs)||; load name base|15196
||jsr|6,acess|||; access subject value|15197
||ppm|6,exfal|||; fail if access fails|15198
||mov|7,xl|9,(xs)||; restore pattern pointer|15199
||mov|9,(xs)|7,xr||; stack subject string val for merge|15200
||zer|8,wb|||; restore type code|15201
;
;      merge here with subject value on stack
;
|mtch1|jsr|6,gtstg|||; convert subject to string|15206
||err|1,241|26,pattern match left operand is not a string|||15207
||mov|11,-(xs)|8,wb||; stack match type code|15208
||mov|3,r_pms|7,xr||; if ok, store subject string pointer|15216
||mov|3,pmssl|8,wa||; and length|15217
||zer|11,-(xs)|||; stack initial cursor (zero)|15218
||zer|8,wb|||; set initial cursor|15219
||mov|3,pmhbs|7,xs||; set history stack base ptr|15220
||zer|3,pmdfl|||; reset pattern assignment flag|15221
||mov|7,xr|7,xl||; set initial node pointer|15222
||bnz|3,kvanc|6,mtch2||; jump if anchored|15223
;
;      here for unanchored
;
||mov|11,-(xs)|7,xr||; stack initial node pointer|15227
||mov|11,-(xs)|21,=nduna||; stack pointer to anchor move node|15228
||bri|9,(xr)|||; start match of first node|15229
;
;      here in anchored mode
;
|mtch2|zer|11,-(xs)|||; dummy cursor value|15233
||mov|11,-(xs)|21,=ndabo||; stack pointer to abort node|15234
||bri|9,(xr)|||; start match of first node|15235
||ejc|||||15236
;
;      retrn -- return from function
;
;      (wa)		     string pointer for return type
;      brn  retrn	     jump to return from (snobol) func
;
;      retrn continues by executing the code at the return point
;      the stack is cleaned of any garbage left by other
;      routines which may have altered flptr since function
;      entry by using flprt, reserved for use only by
;      function call and return.
;
|retrn|rtn|||||15249
||bnz|3,kvfnc|6,rtn01||; jump if not level zero|15250
||erb|1,242|26,function return from level zero|||15251
;
;      here if not level zero return
;
|rtn01|mov|7,xs|3,flprt||; pop stack|15255
||ica|7,xs|||; remove failure offset|15256
||mov|7,xr|10,(xs)+||; pop pfblk pointer|15257
||mov|3,flptr|10,(xs)+||; pop failure pointer|15258
||mov|3,flprt|10,(xs)+||; pop old flprt|15259
||mov|8,wb|10,(xs)+||; pop code pointer offset|15260
||mov|8,wc|10,(xs)+||; pop old code block pointer|15261
||add|8,wb|8,wc||; make old code pointer absolute|15262
||lcp|8,wb|||; restore old code pointer|15263
||mov|3,r_cod|8,wc||; restore old code block pointer|15264
||dcv|3,kvfnc|||; decrement function level|15265
||mov|8,wb|3,kvtra||; load trace|15266
||add|8,wb|3,kvftr||; add ftrace|15267
||bze|8,wb|6,rtn06||; jump if no tracing possible|15268
;
;      here if there may be a trace
;
||mov|11,-(xs)|8,wa||; save function return type|15272
||mov|11,-(xs)|7,xr||; save pfblk pointer|15273
||mov|3,kvrtn|8,wa||; set rtntype for trace function|15274
||mov|7,xl|3,r_fnc||; load fnclevel trblk ptr (if any)|15275
||jsr|6,ktrex|||; execute possible fnclevel trace|15276
||mov|7,xl|13,pfvbl(xr)||; load vrblk ptr (sgd13)|15277
||bze|3,kvtra|6,rtn02||; jump if trace is off|15278
||mov|7,xr|13,pfrtr(xr)||; else load return trace trblk ptr|15279
||bze|7,xr|6,rtn02||; jump if not return traced|15280
||dcv|3,kvtra|||; else decrement trace count|15281
||bze|13,trfnc(xr)|6,rtn03||; jump if print trace|15282
||mov|8,wa|19,*vrval||; else set name offset|15283
||mov|3,kvrtn|13,num01(xs)||; make sure rtntype is set right|15284
||jsr|6,trxeq|||; execute full trace|15285
||ejc|||||15286
;
;      retrn (continued)
;
;      here to test for ftrace
;
|rtn02|bze|3,kvftr|6,rtn05||; jump if ftrace is off|15292
||dcv|3,kvftr|||; else decrement ftrace|15293
;
;      here for print trace of function return
;
|rtn03|jsr|6,prtsn|||; print statement number|15297
||mov|7,xr|13,num01(xs)||; load return type|15298
||jsr|6,prtst|||; print it|15299
||mov|8,wa|18,=ch_bl||; load blank|15300
||jsr|6,prtch|||; print it|15301
||mov|7,xl|12,0(xs)||; load pfblk ptr|15302
||mov|7,xl|13,pfvbl(xl)||; load function vrblk ptr|15303
||mov|8,wa|19,*vrval||; set vrblk name offset|15304
||bne|7,xr|21,=scfrt|6,rtn04|; jump if not freturn case|15305
;
;      for freturn, just print function name
;
||jsr|6,prtnm|||; print name|15309
||jsr|6,prtnl|||; terminate print line|15310
||brn|6,rtn05|||; merge|15311
;
;      here for return or nreturn, print function name = value
;
|rtn04|jsr|6,prtnv|||; print name = value|15315
;
;      here after completing trace
;
|rtn05|mov|7,xr|10,(xs)+||; pop pfblk pointer|15319
||mov|8,wa|10,(xs)+||; pop return type string|15320
;
;      merge here if no trace required
;
|rtn06|mov|3,kvrtn|8,wa||; set rtntype keyword|15324
||mov|7,xl|13,pfvbl(xr)||; load pointer to fn vrblk|15325
||ejc|||||15326
;      retrn (continued)
;
;      get value of function
;
|rtn07|mov|3,rtnbp|7,xl||; save block pointer|15331
||mov|7,xl|13,vrval(xl)||; load value|15332
||beq|9,(xl)|22,=b_trt|6,rtn07|; loop back if trapped|15333
||mov|3,rtnfv|7,xl||; else save function result value|15334
||mov|3,rtnsv|10,(xs)+||; save original function value|15335
||mov|7,xl|10,(xs)+||; pop saved pointer|15339
||bze|7,xl|6,rtn7c||; no action if none|15340
||bze|3,kvpfl|6,rtn7c||; jump if no profiling|15341
||jsr|6,prflu|||; else profile last func stmt|15342
||beq|3,kvpfl|18,=num02|6,rtn7a|; branch on value of profile keywd|15343
;
;      here if &profile = 1. start time must be frigged to
;      appear earlier than it actually is, by amount used before
;      the call.
;
||ldi|3,pfstm|||; load current time|15349
||sbi|13,icval(xl)|||; frig by subtracting saved amount|15350
||brn|6,rtn7b|||; and merge|15351
;
;      here if &profile = 2
;
|rtn7a|ldi|13,icval(xl)|||; load saved time|15355
;
;      both profile types merge here
;
|rtn7b|sti|3,pfstm|||; store back correct start time|15359
;
;      merge here if no profiling
;
|rtn7c|mov|8,wb|13,fargs(xr)||; get number of args|15363
||add|8,wb|13,pfnlo(xr)||; add number of locals|15365
||bze|8,wb|6,rtn10||; jump if no args/locals|15366
||lct|8,wb|8,wb||; else set loop counter|15367
||add|7,xr|13,pflen(xr)||; and point to end of pfblk|15368
;
;      loop to restore functions and locals
;
|rtn08|mov|7,xl|11,-(xr)||; load next vrblk pointer|15372
;
;      loop to find value block
;
|rtn09|mov|8,wa|7,xl||; save block pointer|15376
||mov|7,xl|13,vrval(xl)||; load pointer to next value|15377
||beq|9,(xl)|22,=b_trt|6,rtn09|; loop back if trapped|15378
||mov|7,xl|8,wa||; else restore last block pointer|15379
||mov|13,vrval(xl)|10,(xs)+||; restore old variable value|15380
||bct|8,wb|6,rtn08||; loop till all processed|15381
;
;      now restore function value and exit
;
|rtn10|mov|7,xl|3,rtnbp||; restore ptr to last function block|15385
||mov|13,vrval(xl)|3,rtnsv||; restore old function value|15386
||mov|7,xr|3,rtnfv||; reload function result|15387
||mov|7,xl|3,r_cod||; point to new code block|15388
||mov|3,kvlst|3,kvstn||; set lastno from stno|15389
||mov|3,kvstn|13,cdstm(xl)||; reset proper stno value|15390
||mov|3,kvlln|3,kvlin||; set lastline from line|15392
||mov|3,kvlin|13,cdsln(xl)||; reset proper line value|15393
||mov|8,wa|3,kvrtn||; load return type|15395
||beq|8,wa|21,=scrtn|6,exixr|; exit with result in xr if return|15396
||beq|8,wa|21,=scfrt|6,exfal|; fail if freturn|15397
||ejc|||||15398
;
;      retrn (continued)
;
;      here for nreturn
;
||beq|9,(xr)|22,=b_nml|6,rtn11|; jump if is a name|15404
||jsr|6,gtnvr|||; else try convert to variable name|15405
||err|1,243|26,function result in nreturn is not name|||15406
||mov|7,xl|7,xr||; if ok, copy vrblk (name base) ptr|15407
||mov|8,wa|19,*vrval||; set name offset|15408
||brn|6,rtn12|||; and merge|15409
;
;      here if returned result is a name
;
|rtn11|mov|7,xl|13,nmbas(xr)||; load name base|15413
||mov|8,wa|13,nmofs(xr)||; load name offset|15414
;
;      merge here with returned name in (xl,wa)
;
|rtn12|mov|7,xr|7,xl||; preserve xl|15418
||lcw|8,wb|||; load next word|15419
||mov|7,xl|7,xr||; restore xl|15420
||beq|8,wb|21,=ofne_|6,exnam|; exit if called by name|15421
||mov|11,-(xs)|8,wb||; else save code word|15422
||jsr|6,acess|||; get value|15423
||ppm|6,exfal|||; fail if access fails|15424
||mov|7,xl|7,xr||; if ok, copy result|15425
||mov|7,xr|9,(xs)||; reload next code word|15426
||mov|9,(xs)|7,xl||; store result on stack|15427
||mov|7,xl|9,(xr)||; load routine address|15428
||bri|7,xl|||; jump to execute next code word|15429
||ejc|||||15430
;
;      stcov -- signal statement counter overflow
;
;      brn  stcov	     jump to signal statement count oflo
;
;      permit up to 10 more statements to be obeyed so that
;      setexit trap can regain control.
;      stcov continues by issuing the error message
;
|stcov|rtn|||||15440
||icv|3,errft|||; fatal error|15441
||ldi|4,intvt|||; get 10|15442
||adi|3,kvstl|||; add to former limit|15443
||sti|3,kvstl|||; store as new stlimit|15444
||ldi|4,intvt|||; get 10|15445
||sti|3,kvstc|||; set as new count|15446
||jsr|6,stgcc|||; recompute countdown counters|15447
||erb|1,244|26,statement count exceeds value of stlimit keyword|||15448
||ejc|||||15449
;
;      stmgo -- start execution of new statement
;
;      (xr)		     pointer to cdblk for new statement
;      brn  stmgo	     jump to execute new statement
;
;      stmgo continues by executing the next statement
;
|stmgo|rtn|||||15458
||mov|3,r_cod|7,xr||; set new code block pointer|15459
||dcv|3,stmct|||; see if time to check something|15460
||bze|3,stmct|6,stgo2||; jump if so|15461
||mov|3,kvlst|3,kvstn||; set lastno|15462
||mov|3,kvstn|13,cdstm(xr)||; set stno|15463
||mov|3,kvlln|3,kvlin||; set lastline|15465
||mov|3,kvlin|13,cdsln(xr)||; set line|15466
||add|7,xr|19,*cdcod||; point to first code word|15468
||lcp|7,xr|||; set code pointer|15469
;
;      here to execute first code word of statement
;
|stgo1|lcw|7,xr|||; load next code word|15473
||zer|7,xl|||; clear garbage xl|15474
||bri|9,(xr)|||; execute it|15475
;
;      check profiling, polling, stlimit, statement tracing
;
|stgo2|bze|3,kvpfl|6,stgo3||; skip if no profiling|15479
||jsr|6,prflu|||; else profile the statement in kvstn|15480
;
;      here when finished with profiling
;
|stgo3|mov|3,kvlst|3,kvstn||; set lastno|15484
||mov|3,kvstn|13,cdstm(xr)||; set stno|15485
||mov|3,kvlln|3,kvlin||; set lastline|15487
||mov|3,kvlin|13,cdsln(xr)||; set line|15488
||add|7,xr|19,*cdcod||; point to first code word|15490
||lcp|7,xr|||; set code pointer|15491
;
;      here to check for polling
;
||mov|11,-(xs)|3,stmcs||; save present count start on stack|15496
||dcv|3,polct|||; poll interval within stmct|15497
||bnz|3,polct|6,stgo4||; jump if not poll time yet|15498
||zer|8,wa|||; =0 for poll|15499
||mov|8,wb|3,kvstn||; statement number|15500
||mov|7,xl|7,xr||; make collectable|15501
||jsr|6,syspl|||; allow interactive access|15502
||err|1,320|26,user interrupt|||15503
||ppm||||; single step|15504
||ppm||||; expression evaluation|15505
||mov|7,xr|7,xl||; restore code block pointer|15506
||mov|3,polcs|8,wa||; poll interval start value|15507
||jsr|6,stgcc|||; recompute counter values|15508
;
;      check statement limit
;
|stgo4|ldi|3,kvstc|||; get stmt count|15513
||ilt|6,stgo5|||; omit counting if negative|15514
||mti|10,(xs)+|||; reload start value of counter|15515
||ngi||||; negate|15516
||adi|3,kvstc|||; stmt count minus counter|15517
||sti|3,kvstc|||; replace it|15518
||ile|6,stcov|||; fail if stlimit reached|15519
||bze|3,r_stc|6,stgo5||; jump if no statement trace|15520
||zer|7,xr|||; clear garbage value in xr|15521
||mov|7,xl|3,r_stc||; load pointer to stcount trblk|15522
||jsr|6,ktrex|||; execute keyword trace|15523
;
;      reset stmgo counter
;
|stgo5|mov|3,stmct|3,stmcs||; reset counter|15527
||brn|6,stgo1|||; fetch next code word|15528
||ejc|||||15529
;
;      stopr -- terminate run
;
;      (xr)		     points to ending message
;      brn stopr	     jump to terminate run
;
;      terminate run and print statistics.  on entry xr points
;      to ending message or is zero if message	printed already.
;
|stopr|rtn|||||15539
||bze|7,xr|6,stpra||; skip if sysax already called|15541
||jsr|6,sysax|||; call after execution proc|15542
|stpra|add|3,dname|3,rsmem||; use the reserve memory|15543
||bne|7,xr|21,=endms|6,stpr0|; skip if not normal end message|15547
||bnz|3,exsts|6,stpr3||; skip if exec stats suppressed|15548
||zer|3,erich|||; clear errors to int.ch. flag|15549
;
;      look to see if an ending message is supplied
;
|stpr0|jsr|6,prtpg|||; eject printer|15553
||bze|7,xr|6,stpr1||; skip if no message|15554
||jsr|6,prtst|||; print message|15555
;
;      merge here if no message to print
;
|stpr1|jsr|6,prtis|||; print blank line|15559
||bnz|3,gbcfl|6,stpr5||; if in garbage collection, skip|15561
||mov|7,xr|21,=stpm7||; point to message /in file xxx/|15562
||jsr|6,prtst|||; print it|15563
||mov|3,profs|18,=prtmf||; set column offset|15564
||mov|8,wc|3,kvstn||; get statement number|15565
||jsr|6,filnm|||; get file name|15566
||mov|7,xr|7,xl||; prepare to print|15567
||jsr|6,prtst|||; print file name|15568
||jsr|6,prtis|||; print to interactive channel|15569
||mov|7,xr|3,r_cod||; get code pointer|15576
||mti|13,cdsln(xr)|||; get source line number|15577
||mov|7,xr|21,=stpm6||; point to message /in line xxx/|15578
||jsr|6,prtmx|||; print it|15579
|stpr5|mti|3,kvstn|||; get statement number|15581
||mov|7,xr|21,=stpm1||; point to message /in statement xxx/|15582
||jsr|6,prtmx|||; print it|15583
||jsr|6,systm|||; get current time|15584
||sbi|3,timsx|||; minus start time = elapsed exec tim|15585
||sti|3,stpti|||; save for later|15586
||mov|7,xr|21,=stpm3||; point to msg /execution time msec /|15587
||jsr|6,prtmx|||; print it|15588
||ldi|3,kvstl|||; get statement limit|15589
||ilt|6,stpr2|||; skip if negative|15590
||sbi|3,kvstc|||; minus counter = course count|15591
||sti|3,stpsi|||; save|15592
||mov|8,wa|3,stmcs||; refine with counter start value|15593
||sub|8,wa|3,stmct||; minus current counter|15594
||mti|8,wa|||; convert to integer|15595
||adi|3,stpsi|||; add in course count|15596
||sti|3,stpsi|||; save|15597
||mov|7,xr|21,=stpm2||; point to message /stmts executed/|15598
||jsr|6,prtmx|||; print it|15599
||ldi|3,stpti|||; reload elapsed time|15602
||mli|4,intth|||; *1000 (microsecs)|15603
||iov|6,stpr2|||; jump if we cannot compute|15604
||dvi|3,stpsi|||; divide by statement count|15605
||iov|6,stpr2|||; jump if overflow|15606
||mov|7,xr|21,=stpm4||; point to msg (mcsec per statement /|15607
||jsr|6,prtmx|||; print it|15608
||ejc|||||15610
;
;      stopr (continued)
;
;      merge to skip message (overflow or negative stlimit)
;
|stpr2|mti|3,gbcnt|||; load count of collections|15616
||mov|7,xr|21,=stpm5||; point to message /regenerations /|15617
||jsr|6,prtmx|||; print it|15618
||jsr|6,prtmm|||; print memory usage|15619
||jsr|6,prtis|||; one more blank for luck|15620
;
;      check if dump requested
;
|stpr3|jsr|6,prflr|||; print profile if wanted|15627
;
||mov|7,xr|3,kvdmp||; load dump keyword|15629
||jsr|6,dumpr|||; execute dump if requested|15631
||mov|7,xl|3,r_fcb||; get fcblk chain head|15632
||mov|8,wa|3,kvabe||; load abend value|15633
||mov|8,wb|3,kvcod||; load code value|15634
||jsr|6,sysej|||; exit to system|15635
;
;      here after sysea call and suppressing error msg print
;
|stpr4|rtn|||||15640
||add|3,dname|3,rsmem||; use the reserve memory|15641
||bze|3,exsts|6,stpr1||; if execution stats requested|15642
||brn|6,stpr3|||; check if dump or profile needed|15643
||ejc|||||15646
;
;      succp -- signal successful match of a pattern node
;
;      see pattern match routines for details
;
;      (xr)		     current node
;      (wb)		     current cursor
;      (xl)		     may be non-collectable
;      brn  succp	     signal successful pattern match
;
;      succp continues by matching the successor node
;
|succp|rtn|||||15659
||mov|7,xr|13,pthen(xr)||; load successor node|15660
||mov|7,xl|9,(xr)||; load node code entry address|15661
||bri|7,xl|||; jump to match successor node|15662
||ejc|||||15663
;
;      sysab -- print /abnormal end/ and terminate
;
|sysab|rtn|||||15667
||mov|7,xr|21,=endab||; point to message|15668
||mov|3,kvabe|18,=num01||; set abend flag|15669
||jsr|6,prtnl|||; skip to new line|15670
||brn|6,stopr|||; jump to pack up|15671
||ejc|||||15672
;
;      systu -- print /time up/ and terminate
;
|systu|rtn|||||15676
||mov|7,xr|21,=endtu||; point to message|15677
||mov|8,wa|4,strtu||; get chars /tu/|15678
||mov|3,kvcod|8,wa||; put in kvcod|15679
||mov|8,wa|3,timup||; check state of timeup switch|15680
||mnz|3,timup|||; set switch|15681
||bnz|8,wa|6,stopr||; stop run if already set|15682
||erb|1,245|26,translation/execution time expired|||15683
||ttl|27,s p i t b o l -- utility procedures||||15684
;
;      the following section contains procedures which are
;      used for various purposes throughout the system.
;
;      each procedure is preceded by a description of the
;      calling sequence. usually the arguments are in registers
;      but arguments can also occur on the stack and as
;      parameters assembled after the jsr instruction.
;
;      the following considerations apply to these descriptions.
;
;      1)   the stack pointer (xs) is not changed unless the
;	    change is explicitly documented in the call.
;
;      2)   registers whose entry values are not mentioned
;	    may contain any value except that xl,xr may only
;	    contain proper (collectable) pointer values.
;	    this condition on means that the called routine
;	    may if it chooses preserve xl,xr by stacking.
;
;      3)   registers not mentioned on exit contain the same
;	    values as they did on entry except that values in
;	    xr,xl may have been relocated by the collector.
;
;      4)   registers which are destroyed on exit may contain
;	    any value except that values in xl,xr are proper
;	    (collectable) pointers.
;
;      5)   the code pointer register points to the current
;	    code location on entry and is unchanged on exit.
;
;      in the above description, a collectable pointer is one
;      which either points outside the dynamic region or
;      points to the start of a block in the dynamic region.
;
;      in those cases where the calling sequence contains
;      parameters which are used as alternate return points,
;      these parameters may be replaced by error codes
;      assembled with the err instruction. this will result
;      in the posting of the error if the return is taken.
;
;      the procedures all have names consisting of five letters
;      and are in alphabetical order by their names.
||ejc|||||15728
;
;      acess - access variable value with trace/input checks
;
;      acess loads the value of a variable. trace and input
;      associations are tested for and executed as required.
;      acess also handles the special cases of pseudo-variables.
;
;      (xl)		     variable name base
;      (wa)		     variable name offset
;      jsr  acess	     call to access value
;      ppm  loc		     transfer loc if access failure
;      (xr)		     variable value
;      (wa,wb,wc)	     destroyed
;      (xl,ra)		     destroyed
;
;      failure can occur if an input association causes an end
;      of file condition or if the evaluation of an expression
;      associated with an expression variable fails.
;
|acess|prc|25,r|1,1||; entry point (recursive)|15748
||mov|7,xr|7,xl||; copy name base|15749
||add|7,xr|8,wa||; point to variable location|15750
||mov|7,xr|9,(xr)||; load variable value|15751
;
;      loop here to check for successive trblks
;
|acs02|bne|9,(xr)|22,=b_trt|6,acs18|; jump if not trapped|15755
;
;      here if trapped
;
||beq|7,xr|21,=trbkv|6,acs12|; jump if keyword variable|15759
||bne|7,xr|21,=trbev|6,acs05|; jump if not expression variable|15760
;
;      here for expression variable, evaluate variable
;
||mov|7,xr|13,evexp(xl)||; load expression pointer|15764
||zer|8,wb|||; evaluate by value|15765
||jsr|6,evalx|||; evaluate expression|15766
||ppm|6,acs04|||; jump if evaluation failure|15767
||brn|6,acs02|||; check value for more trblks|15768
||ejc|||||15769
;
;      acess (continued)
;
;      here on reading end of file
;
|acs03|add|7,xs|19,*num03||; pop trblk ptr, name base and offset|15775
||mov|3,dnamp|7,xr||; pop unused scblk|15776
;
;      merge here when evaluation of expression fails
;
|acs04|exi|1,1|||; take alternate (failure) return|15780
;
;      here if not keyword or expression variable
;
|acs05|mov|8,wb|13,trtyp(xr)||; load trap type code|15784
||bnz|8,wb|6,acs10||; jump if not input association|15785
||bze|3,kvinp|6,acs09||; ignore input assoc if input is off|15786
;
;      here for input association
;
||mov|11,-(xs)|7,xl||; stack name base|15790
||mov|11,-(xs)|8,wa||; stack name offset|15791
||mov|11,-(xs)|7,xr||; stack trblk pointer|15792
||mov|3,actrm|3,kvtrm||; temp to hold trim keyword|15793
||mov|7,xl|13,trfpt(xr)||; get file ctrl blk ptr or zero|15794
||bnz|7,xl|6,acs06||; jump if not standard input file|15795
||beq|13,trter(xr)|21,=v_ter|6,acs21|; jump if terminal|15796
;
;      here to read from standard input file
;
||mov|8,wa|3,cswin||; length for read buffer|15800
||jsr|6,alocs|||; build string of appropriate length|15801
||jsr|6,sysrd|||; read next standard input image|15802
||ppm|6,acs03|||; jump to fail exit if end of file|15803
||brn|6,acs07|||; else merge with other file case|15804
;
;      here for input from other than standard input file
;
|acs06|mov|8,wa|7,xl||; fcblk ptr|15808
||jsr|6,sysil|||; get input record max length (to wa)|15809
||bnz|8,wc|6,acs6a||; jump if not binary file|15810
||mov|3,actrm|8,wc||; disable trim for binary file|15811
|acs6a|jsr|6,alocs|||; allocate string of correct size|15812
||mov|8,wa|7,xl||; fcblk ptr|15813
||jsr|6,sysin|||; call system input routine|15814
||ppm|6,acs03|||; jump to fail exit if end of file|15815
||ppm|6,acs22|||; error|15816
||ppm|6,acs23|||; error|15817
||ejc|||||15818
;
;      acess (continued)
;
;      merge here after obtaining input record
;
|acs07|mov|8,wb|3,actrm||; load trim indicator|15824
||jsr|6,trimr|||; trim record as required|15825
||mov|8,wb|7,xr||; copy result pointer|15826
||mov|7,xr|9,(xs)||; reload pointer to trblk|15827
;
;      loop to chase to end of trblk chain and store value
;
|acs08|mov|7,xl|7,xr||; save pointer to this trblk|15831
||mov|7,xr|13,trnxt(xr)||; load forward pointer|15832
||beq|9,(xr)|22,=b_trt|6,acs08|; loop if this is another trblk|15833
||mov|13,trnxt(xl)|8,wb||; else store result at end of chain|15834
||mov|7,xr|10,(xs)+||; restore initial trblk pointer|15835
||mov|8,wa|10,(xs)+||; restore name offset|15836
||mov|7,xl|10,(xs)+||; restore name base pointer|15837
;
;      come here to move to next trblk
;
|acs09|mov|7,xr|13,trnxt(xr)||; load forward ptr to next value|15841
||brn|6,acs02|||; back to check if trapped|15842
;
;      here to check for access trace trblk
;
|acs10|bne|8,wb|18,=trtac|6,acs09|; loop back if not access trace|15846
||bze|3,kvtra|6,acs09||; ignore access trace if trace off|15847
||dcv|3,kvtra|||; else decrement trace count|15848
||bze|13,trfnc(xr)|6,acs11||; jump if print trace|15849
||ejc|||||15850
;
;      acess (continued)
;
;      here for full function trace
;
||jsr|6,trxeq|||; call routine to execute trace|15856
||brn|6,acs09|||; jump for next trblk|15857
;
;      here for case of print trace
;
|acs11|jsr|6,prtsn|||; print statement number|15861
||jsr|6,prtnv|||; print name = value|15862
||brn|6,acs09|||; jump back for next trblk|15863
;
;      here for keyword variable
;
|acs12|mov|7,xr|13,kvnum(xl)||; load keyword number|15867
||bge|7,xr|18,=k_v__|6,acs14|; jump if not one word value|15868
||mti|15,kvabe(xr)|||; else load value as integer|15869
;
;      common exit with keyword value as integer in (ia)
;
|acs13|jsr|6,icbld|||; build icblk|15873
||brn|6,acs18|||; jump to exit|15874
;
;      here if not one word keyword value
;
|acs14|bge|7,xr|18,=k_s__|6,acs15|; jump if special case|15878
||sub|7,xr|18,=k_v__||; else get offset|15879
||wtb|7,xr|||; convert to byte offset|15880
||add|7,xr|21,=ndabo||; point to pattern value|15881
||brn|6,acs18|||; jump to exit|15882
;
;      here if special keyword case
;
|acs15|mov|7,xl|3,kvrtn||; load rtntype in case|15886
||ldi|3,kvstl|||; load stlimit in case|15887
||sub|7,xr|18,=k_s__||; get case number|15888
||bsw|7,xr|2,k__n_||; switch on keyword number|15889
||iff|2,k__al|6,acs16||; jump if alphabet|15903
||iff|2,k__rt|6,acs17||; rtntype|15903
||iff|2,k__sc|6,acs19||; stcount|15903
||iff|2,k__et|6,acs20||; errtext|15903
||iff|2,k__fl|6,acs26||; file|15903
||iff|2,k__lf|6,acs27||; lastfile|15903
||iff|2,k__sl|6,acs13||; stlimit|15903
||iff|2,k__lc|6,acs24||; lcase|15903
||iff|2,k__uc|6,acs25||; ucase|15903
||esw||||; end switch on keyword number|15903
||ejc|||||15904
;
;      acess (continued)
;
;      lcase
;
|acs24|mov|7,xr|21,=lcase||; load pointer to lcase string|15911
||brn|6,acs18|||; common return|15912
;
;      ucase
;
|acs25|mov|7,xr|21,=ucase||; load pointer to ucase string|15916
||brn|6,acs18|||; common return|15917
;
;      file
;
|acs26|mov|8,wc|3,kvstn||; load current stmt number|15923
||brn|6,acs28|||; merge to obtain file name|15924
;
;      lastfile
;
|acs27|mov|8,wc|3,kvlst||; load last stmt number|15928
;
;      merge here to map statement number in wc to file name
;
|acs28|jsr|6,filnm|||; obtain file name for this stmt|15932
||brn|6,acs17|||; merge to return string in xl|15933
;      alphabet
;
|acs16|mov|7,xl|3,kvalp||; load pointer to alphabet string|15937
;
;      rtntype merges here
;
|acs17|mov|7,xr|7,xl||; copy string ptr to proper reg|15941
;
;      common return point
;
|acs18|exi||||; return to acess caller|15945
;
;      here for stcount (ia has stlimit)
;
|acs19|ilt|6,acs29|||; if counting suppressed|15949
||mov|8,wa|3,stmcs||; refine with counter start value|15950
||sub|8,wa|3,stmct||; minus current counter|15951
||mti|8,wa|||; convert to integer|15952
||adi|3,kvstl|||; add stlimit|15953
|acs29|sbi|3,kvstc|||; stcount = limit - left|15954
||brn|6,acs13|||; merge back with integer result|15955
;
;      errtext
;
|acs20|mov|7,xr|3,r_etx||; get errtext string|15959
||brn|6,acs18|||; merge with result|15960
;
;      here to read a record from terminal
;
|acs21|mov|8,wa|18,=rilen||; buffer length|15964
||jsr|6,alocs|||; allocate buffer|15965
||jsr|6,sysri|||; read record|15966
||ppm|6,acs03|||; endfile|15967
||brn|6,acs07|||; merge with record read|15968
;
;      error returns
;
|acs22|mov|3,dnamp|7,xr||; pop unused scblk|15972
||erb|1,202|26,input from file caused non-recoverable error|||15973
;
|acs23|mov|3,dnamp|7,xr||; pop unused scblk|15975
||erb|1,203|26,input file record has incorrect format|||15976
||enp||||; end procedure acess|15977
||ejc|||||15978
;
;      acomp -- compare two arithmetic values
;
;      1(xs)		     first argument
;      0(xs)		     second argument
;      jsr  acomp	     call to compare values
;      ppm  loc		     transfer loc if arg1 is non-numeric
;      ppm  loc		     transfer loc if arg2 is non-numeric
;      ppm  loc		     transfer loc for arg1 lt arg2
;      ppm  loc		     transfer loc for arg1 eq arg2
;      ppm  loc		     transfer loc for arg1 gt arg2
;      (normal return is never given)
;      (wa,wb,wc,ia,ra)	     destroyed
;      (xl,xr)		     destroyed
;
|acomp|prc|25,n|1,5||; entry point|15994
||jsr|6,arith|||; load arithmetic operands|15995
||ppm|6,acmp7|||; jump if first arg non-numeric|15996
||ppm|6,acmp8|||; jump if second arg non-numeric|15997
||ppm|6,acmp4|||; jump if real arguments|16000
;
;      here for integer arguments
;
||sbi|13,icval(xl)|||; subtract to compare|16005
||iov|6,acmp3|||; jump if overflow|16006
||ilt|6,acmp5|||; else jump if arg1 lt arg2|16007
||ieq|6,acmp2|||; jump if arg1 eq arg2|16008
;
;      here if arg1 gt arg2
;
|acmp1|exi|1,5|||; take gt exit|16012
;
;      here if arg1 eq arg2
;
|acmp2|exi|1,4|||; take eq exit|16016
||ejc|||||16017
;
;      acomp (continued)
;
;      here for integer overflow on subtract
;
|acmp3|ldi|13,icval(xl)|||; load second argument|16023
||ilt|6,acmp1|||; gt if negative|16024
||brn|6,acmp5|||; else lt|16025
;
;      here for real operands
;
|acmp4|sbr|13,rcval(xl)|||; subtract to compare|16031
||rov|6,acmp6|||; jump if overflow|16032
||rgt|6,acmp1|||; else jump if arg1 gt|16033
||req|6,acmp2|||; jump if arg1 eq arg2|16034
;
;      here if arg1 lt arg2
;
|acmp5|exi|1,3|||; take lt exit|16039
;
;      here if overflow on real subtraction
;
|acmp6|ldr|13,rcval(xl)|||; reload arg2|16045
||rlt|6,acmp1|||; gt if negative|16046
||brn|6,acmp5|||; else lt|16047
;
;      here if arg1 non-numeric
;
|acmp7|exi|1,1|||; take error exit|16052
;
;      here if arg2 non-numeric
;
|acmp8|exi|1,2|||; take error exit|16056
||enp||||; end procedure acomp|16057
||ejc|||||16058
;
;      alloc		     allocate block of dynamic storage
;
;      (wa)		     length required in bytes
;      jsr  alloc	     call to allocate block
;      (xr)		     pointer to allocated block
;
;      a possible alternative to aov ... and following stmt is -
;      mov  dname,xr .	sub  wa,xr .  blo xr,dnamp,aloc2 .
;      mov  dnamp,xr .	add  wa,xr
;
|alloc|prc|25,e|1,0||; entry point|16070
;
;      common exit point
;
|aloc1|mov|7,xr|3,dnamp||; point to next available loc|16074
||aov|8,wa|7,xr|6,aloc2|; point past allocated block|16075
||bgt|7,xr|3,dname|6,aloc2|; jump if not enough room|16076
||mov|3,dnamp|7,xr||; store new pointer|16077
||sub|7,xr|8,wa||; point back to start of allocated bk|16078
||exi||||; return to caller|16079
;
;      here if insufficient room, try a garbage collection
;
|aloc2|mov|3,allsv|8,wb||; save wb|16083
|alc2a|zer|8,wb|||; set no upward move for gbcol|16084
||jsr|6,gbcol|||; garbage collect|16085
||mov|8,wb|7,xr||; remember new sediment size|16087
;
;      see if room after gbcol or sysmm call
;
|aloc3|mov|7,xr|3,dnamp||; point to first available loc|16092
||aov|8,wa|7,xr|6,alc3a|; point past new block|16093
||blo|7,xr|3,dname|6,aloc4|; jump if there is room now|16094
;
;      failed again, see if we can get more core
;
|alc3a|jsr|6,sysmm|||; try to get more memory|16098
||wtb|7,xr|||; convert to baus (sgd05)|16099
||add|3,dname|7,xr||; bump ptr by amount obtained|16100
||bnz|7,xr|6,aloc3||; jump if got more core|16101
||bze|3,dnams|6,alc3b||; jump if there was no sediment|16103
||zer|3,dnams|||; try collecting the sediment|16104
||brn|6,alc2a|||;|16105
;
;      sysmm failed and there was no sediment to collect
;
|alc3b|add|3,dname|3,rsmem||; get the reserve memory|16109
||zer|3,rsmem|||; only permissible once|16113
||icv|3,errft|||; fatal error|16114
||erb|1,204|26,memory overflow|||16115
||ejc|||||16116
;
;      here after successful garbage collection
;
|aloc4|sti|3,allia|||; save ia|16120
||mov|3,dnams|8,wb||; record new sediment size|16122
||mov|8,wb|3,dname||; get dynamic end adrs|16124
||sub|8,wb|3,dnamp||; compute free store|16125
||btw|8,wb|||; convert bytes to words|16126
||mti|8,wb|||; put free store in ia|16127
||mli|3,alfsf|||; multiply by free store factor|16128
||iov|6,aloc5|||; jump if overflowed|16129
||mov|8,wb|3,dname||; dynamic end adrs|16130
||sub|8,wb|3,dnamb||; compute total amount of dynamic|16131
||btw|8,wb|||; convert to words|16132
||mov|3,aldyn|8,wb||; store it|16133
||sbi|3,aldyn|||; subtract from scaled up free store|16134
||igt|6,aloc5|||; jump if sufficient free store|16135
||jsr|6,sysmm|||; try to get more store|16136
||wtb|7,xr|||; convert to baus (sgd05)|16137
||add|3,dname|7,xr||; adjust dynamic end adrs|16138
;
;      merge to restore ia and wb
;
|aloc5|ldi|3,allia|||; recover ia|16142
||mov|8,wb|3,allsv||; restore wb|16143
||brn|6,aloc1|||; jump back to exit|16144
||enp||||; end procedure alloc|16145
||ejc|||||16146
;
;      alocs -- allocate string block
;
;      alocs is used to build a frame for a string block into
;      which the actual characters are placed by the caller.
;      all strings are created with a call to alocs (the
;      exceptions occur in trimr and s_rpl procedures).
;
;      (wa)		     length of string to be allocated
;      jsr  alocs	     call to allocate scblk
;      (xr)		     pointer to resulting scblk
;      (wa)		     destroyed
;      (wc)		     character count (entry value of wa)
;
;      the resulting scblk has the type word and the length
;      filled in and the last word is cleared to zero characters
;      to ensure correct right padding of the final word.
;
|alocs|prc|25,e|1,0||; entry point|16206
||bgt|8,wa|3,kvmxl|6,alcs2|; jump if length exceeds maxlength|16207
||mov|8,wc|8,wa||; else copy length|16208
||ctb|8,wa|2,scsi_||; compute length of scblk in bytes|16209
||mov|7,xr|3,dnamp||; point to next available location|16210
||aov|8,wa|7,xr|6,alcs0|; point past block|16211
||blo|7,xr|3,dname|6,alcs1|; jump if there is room|16212
;
;      insufficient memory
;
|alcs0|zer|7,xr|||; else clear garbage xr value|16216
||jsr|6,alloc|||; and use standard allocator|16217
||add|7,xr|8,wa||; point past end of block to merge|16218
;
;      merge here with xr pointing beyond new block
;
|alcs1|mov|3,dnamp|7,xr||; set updated storage pointer|16222
||zer|11,-(xr)|||; store zero chars in last word|16223
||dca|8,wa|||; decrement length|16224
||sub|7,xr|8,wa||; point back to start of block|16225
||mov|9,(xr)|22,=b_scl||; set type word|16226
||mov|13,sclen(xr)|8,wc||; store length in chars|16227
||exi||||; return to alocs caller|16228
;
;      come here if string is too long
;
|alcs2|erb|1,205|26,string length exceeds value of maxlngth keyword|||16232
||enp||||; end procedure alocs|16233
||ejc|||||16234
;
;      alost -- allocate space in static region
;
;      (wa)		     length required in bytes
;      jsr  alost	     call to allocate space
;      (xr)		     pointer to allocated block
;      (wb)		     destroyed
;
;      note that the coding ensures that the resulting value
;      of state is always less than dnamb. this fact is used
;      in testing a variable name for being in the static region
;
|alost|prc|25,e|1,0||; entry point|16247
;
;      merge back here after allocating new chunk
;
|alst1|mov|7,xr|3,state||; point to current end of area|16251
||aov|8,wa|7,xr|6,alst2|; point beyond proposed block|16252
||bge|7,xr|3,dnamb|6,alst2|; jump if overlap with dynamic area|16253
||mov|3,state|7,xr||; else store new pointer|16254
||sub|7,xr|8,wa||; point back to start of block|16255
||exi||||; return to alost caller|16256
;
;      here if no room, prepare to move dynamic storage up
;
|alst2|mov|3,alsta|8,wa||; save wa|16260
||bge|8,wa|19,*e_sts|6,alst3|; skip if requested chunk is large|16261
||mov|8,wa|19,*e_sts||; else set to get large enough chunk|16262
;
;      here with amount to move up in wa
;
|alst3|jsr|6,alloc|||; allocate block to ensure room|16266
||mov|3,dnamp|7,xr||; and delete it|16267
||mov|8,wb|8,wa||; copy move up amount|16268
||jsr|6,gbcol|||; call gbcol to move dynamic area up|16269
||mov|3,dnams|7,xr||; remember new sediment size|16271
||mov|8,wa|3,alsta||; restore wa|16273
||brn|6,alst1|||; loop back to try again|16274
||enp||||; end procedure alost|16275
||ejc|||||16276
;
;      arith -- fetch arithmetic operands
;
;      arith is used by functions and operators which expect
;      two numeric arguments (operands) which must both be
;      integer or both be real. arith fetches two arguments from
;      the stack and performs any necessary conversions.
;
;      1(xs)		     first argument (left operand)
;      0(xs)		     second argument (right operand)
;      jsr  arith	     call to fetch numeric arguments
;      ppm  loc		     transfer loc for opnd 1 non-numeric
;      ppm  loc		     transfer loc for opnd 2 non-numeric
;      ppm  loc		     transfer loc for real operands
;
;      for integer args, control returns past the parameters
;
;      (ia)		     left operand value
;      (xr)		     ptr to icblk for left operand
;      (xl)		     ptr to icblk for right operand
;      (xs)		     popped twice
;      (wa,wb,ra)	     destroyed
;
;      for real arguments, control returns to the location
;      specified by the third parameter.
;
;      (ra)		     left operand value
;      (xr)		     ptr to rcblk for left operand
;      (xl)		     ptr to rcblk for right operand
;      (wa,wb,wc)	     destroyed
;      (xs)		     popped twice
||ejc|||||16350
;
;      arith (continued)
;
;      entry point
;
|arith|prc|25,n|1,3||; entry point|16359
||mov|7,xl|10,(xs)+||; load right operand|16361
||mov|7,xr|10,(xs)+||; load left operand|16362
||mov|8,wa|9,(xl)||; get right operand type word|16363
||beq|8,wa|22,=b_icl|6,arth1|; jump if integer|16364
||beq|8,wa|22,=b_rcl|6,arth4|; jump if real|16367
||mov|11,-(xs)|7,xr||; else replace left arg on stack|16369
||mov|7,xr|7,xl||; copy left arg pointer|16370
||jsr|6,gtnum|||; convert to numeric|16371
||ppm|6,arth6|||; jump if unconvertible|16372
||mov|7,xl|7,xr||; else copy converted result|16373
||mov|8,wa|9,(xl)||; get right operand type word|16374
||mov|7,xr|10,(xs)+||; reload left argument|16375
||beq|8,wa|22,=b_rcl|6,arth4|; jump if right arg is real|16378
;
;      here if right arg is an integer
;
|arth1|bne|9,(xr)|22,=b_icl|6,arth3|; jump if left arg not integer|16383
;
;      exit for integer case
;
|arth2|ldi|13,icval(xr)|||; load left operand value|16387
||exi||||; return to arith caller|16388
;
;      here for right operand integer, left operand not
;
|arth3|jsr|6,gtnum|||; convert left arg to numeric|16392
||ppm|6,arth7|||; jump if not convertible|16393
||beq|8,wa|22,=b_icl|6,arth2|; jump back if integer-integer|16394
;
;      here we must convert real-integer to real-real
;
||mov|11,-(xs)|7,xr||; put left arg back on stack|16400
||ldi|13,icval(xl)|||; load right argument value|16401
||itr||||; convert to real|16402
||jsr|6,rcbld|||; get real block for right arg, merge|16403
||mov|7,xl|7,xr||; copy right arg ptr|16404
||mov|7,xr|10,(xs)+||; load left argument|16405
||brn|6,arth5|||; merge for real-real case|16406
||ejc|||||16407
;
;      arith (continued)
;
;      here if right argument is real
;
|arth4|beq|9,(xr)|22,=b_rcl|6,arth5|; jump if left arg real|16413
||jsr|6,gtrea|||; else convert to real|16414
||ppm|6,arth7|||; error if unconvertible|16415
;
;      here for real-real
;
|arth5|ldr|13,rcval(xr)|||; load left operand value|16419
||exi|1,3|||; take real-real exit|16420
;
;      here for error converting right argument
;
|arth6|ica|7,xs|||; pop unwanted left arg|16425
||exi|1,2|||; take appropriate error exit|16426
;
;      here for error converting left operand
;
|arth7|exi|1,1|||; take appropriate error return|16430
||enp||||; end procedure arith|16431
||ejc|||||16432
;
;      asign -- perform assignment
;
;      asign performs the assignment of a value to a variable
;      with appropriate checks for output associations and
;      value trace associations which are executed as required.
;      asign also handles the special cases of assignment to
;      pattern and expression variables.
;
;      (wb)		     value to be assigned
;      (xl)		     base pointer for variable
;      (wa)		     offset for variable
;      jsr  asign	     call to assign value to variable
;      ppm  loc		     transfer loc for failure
;      (xr,xl,wa,wb,wc)	     destroyed
;      (ra)		     destroyed
;
;      failure occurs if the evaluation of an expression
;      associated with an expression variable fails.
;
|asign|prc|25,r|1,1||; entry point (recursive)|16453
;
;      merge back here to assign result to expression variable.
;
|asg01|add|7,xl|8,wa||; point to variable value|16457
||mov|7,xr|9,(xl)||; load variable value|16458
||beq|9,(xr)|22,=b_trt|6,asg02|; jump if trapped|16459
||mov|9,(xl)|8,wb||; else perform assignment|16460
||zer|7,xl|||; clear garbage value in xl|16461
||exi||||; and return to asign caller|16462
;
;      here if value is trapped
;
|asg02|sub|7,xl|8,wa||; restore name base|16466
||beq|7,xr|21,=trbkv|6,asg14|; jump if keyword variable|16467
||bne|7,xr|21,=trbev|6,asg04|; jump if not expression variable|16468
;
;      here for assignment to expression variable
;
||mov|7,xr|13,evexp(xl)||; point to expression|16472
||mov|11,-(xs)|8,wb||; store value to assign on stack|16473
||mov|8,wb|18,=num01||; set for evaluation by name|16474
||jsr|6,evalx|||; evaluate expression by name|16475
||ppm|6,asg03|||; jump if evaluation fails|16476
||mov|8,wb|10,(xs)+||; else reload value to assign|16477
||brn|6,asg01|||; loop back to perform assignment|16478
||ejc|||||16479
;
;      asign (continued)
;
;      here for failure during expression evaluation
;
|asg03|ica|7,xs|||; remove stacked value entry|16485
||exi|1,1|||; take failure exit|16486
;
;      here if not keyword or expression variable
;
|asg04|mov|11,-(xs)|7,xr||; save ptr to first trblk|16490
;
;      loop to chase down trblk chain and assign value at end
;
|asg05|mov|8,wc|7,xr||; save ptr to this trblk|16494
||mov|7,xr|13,trnxt(xr)||; point to next trblk|16495
||beq|9,(xr)|22,=b_trt|6,asg05|; loop back if another trblk|16496
||mov|7,xr|8,wc||; else point back to last trblk|16497
||mov|13,trval(xr)|8,wb||; store value at end of chain|16498
||mov|7,xr|10,(xs)+||; restore ptr to first trblk|16499
;
;      loop to process trblk entries on chain
;
|asg06|mov|8,wb|13,trtyp(xr)||; load type code of trblk|16503
||beq|8,wb|18,=trtvl|6,asg08|; jump if value trace|16504
||beq|8,wb|18,=trtou|6,asg10|; jump if output association|16505
;
;      here to move to next trblk on chain
;
|asg07|mov|7,xr|13,trnxt(xr)||; point to next trblk on chain|16509
||beq|9,(xr)|22,=b_trt|6,asg06|; loop back if another trblk|16510
||exi||||; else end of chain, return to caller|16511
;
;      here to process value trace
;
|asg08|bze|3,kvtra|6,asg07||; ignore value trace if trace off|16515
||dcv|3,kvtra|||; else decrement trace count|16516
||bze|13,trfnc(xr)|6,asg09||; jump if print trace|16517
||jsr|6,trxeq|||; else execute function trace|16518
||brn|6,asg07|||; and loop back|16519
||ejc|||||16520
;
;      asign (continued)
;
;      here for print trace
;
|asg09|jsr|6,prtsn|||; print statement number|16526
||jsr|6,prtnv|||; print name = value|16527
||brn|6,asg07|||; loop back for next trblk|16528
;
;      here for output association
;
|asg10|bze|3,kvoup|6,asg07||; ignore output assoc if output off|16532
|asg1b|mov|7,xl|7,xr||; copy trblk pointer|16533
||mov|7,xr|13,trnxt(xr)||; point to next trblk|16534
||beq|9,(xr)|22,=b_trt|6,asg1b|; loop back if another trblk|16535
||mov|7,xr|7,xl||; else point back to last trblk|16536
||mov|11,-(xs)|13,trval(xr)||; stack value to output|16538
||jsr|6,gtstg|||; convert to string|16544
||ppm|6,asg12|||; get datatype name if unconvertible|16545
;
;      merge with string or buffer to output in xr
;
|asg11|mov|8,wa|13,trfpt(xl)||; fcblk ptr|16549
||bze|8,wa|6,asg13||; jump if standard output file|16550
;
;      here for output to file
;
|asg1a|jsr|6,sysou|||; call system output routine|16554
||err|1,206|26,output caused file overflow|||16555
||err|1,207|26,output caused non-recoverable error|||16556
||exi||||; else all done, return to caller|16557
;
;      if not printable, get datatype name instead
;
|asg12|jsr|6,dtype|||; call datatype routine|16561
||brn|6,asg11|||; merge|16562
;
;      here to print a string to standard output or terminal
;
|asg13|beq|13,trter(xl)|21,=v_ter|6,asg1a|; jump if terminal output|16567
||icv|8,wa|||; signal standard output|16568
||brn|6,asg1a|||; use sysou to perform output|16569
||ejc|||||16584
;
;      asign (continued)
;
;      here for keyword assignment
;
|asg14|mov|7,xl|13,kvnum(xl)||; load keyword number|16590
||beq|7,xl|18,=k_etx|6,asg19|; jump if errtext|16591
||mov|7,xr|8,wb||; copy value to be assigned|16592
||jsr|6,gtint|||; convert to integer|16593
||err|1,208|26,keyword value assigned is not integer|||16594
||ldi|13,icval(xr)|||; else load value|16595
||beq|7,xl|18,=k_stl|6,asg16|; jump if special case of stlimit|16596
||mfi|8,wa|6,asg18||; else get addr integer, test ovflow|16597
||bgt|8,wa|3,mxlen|6,asg18|; fail if too large|16598
||beq|7,xl|18,=k_ert|6,asg17|; jump if special case of errtype|16599
||beq|7,xl|18,=k_pfl|6,asg21|; jump if special case of profile|16602
||beq|7,xl|18,=k_mxl|6,asg24|; jump if special case of maxlngth|16604
||beq|7,xl|18,=k_fls|6,asg26|; jump if special case of fullscan|16605
||blt|7,xl|18,=k_p__|6,asg15|; jump unless protected|16606
||erb|1,209|26,keyword in assignment is protected|||16607
;
;      here to do assignment if not protected
;
|asg15|mov|15,kvabe(xl)|8,wa||; store new value|16611
||exi||||; return to asign caller|16612
;
;      here for special case of stlimit
;
;      since stcount is maintained as (stlimit-stcount)
;      it is also necessary to modify stcount appropriately.
;
|asg16|sbi|3,kvstl|||; subtract old limit|16619
||adi|3,kvstc|||; add old counter|16620
||sti|3,kvstc|||; store course counter value|16621
||ldi|3,kvstl|||; check if counting suppressed|16622
||ilt|6,asg25|||; do not refine if so|16623
||mov|8,wa|3,stmcs||; refine with counter breakout|16624
||sub|8,wa|3,stmct||; values|16625
||mti|8,wa|||; convert to integer|16626
||ngi||||; current-start value|16627
||adi|3,kvstc|||; add in course counter value|16628
||sti|3,kvstc|||; save refined value|16629
|asg25|ldi|13,icval(xr)|||; reload new limit value|16630
||sti|3,kvstl|||; store new limit value|16631
||jsr|6,stgcc|||; recompute countdown counters|16632
||exi||||; return to asign caller|16633
;
;      here for special case of errtype
;
|asg17|ble|8,wa|18,=nini9|6,error|; ok to signal if in range|16637
;
;      here if value assigned is out of range
;
|asg18|erb|1,210|26,keyword value assigned is negative or too large|||16641
;
;      here for special case of errtext
;
|asg19|mov|11,-(xs)|8,wb||; stack value|16645
||jsr|6,gtstg|||; convert to string|16646
||err|1,211|26,value assigned to keyword errtext not a string|||16647
||mov|3,r_etx|7,xr||; make assignment|16648
||exi||||; return to caller|16649
;
;      here for keyword profile
;
|asg21|bgt|8,wa|18,=num02|6,asg18|; moan if not 0,1, or 2|16663
||bze|8,wa|6,asg15||; just assign if zero|16664
||bze|3,pfdmp|6,asg22||; branch if first assignment|16665
||beq|8,wa|3,pfdmp|6,asg23|; also if same value as before|16666
||erb|1,268|26,inconsistent value assigned to keyword profile|||16667
;
|asg22|mov|3,pfdmp|8,wa||; note value on first assignment|16669
|asg23|mov|3,kvpfl|8,wa||; store new value|16670
||jsr|6,stgcc|||; recompute countdown counts|16671
||jsr|6,systm|||; get the time|16672
||sti|3,pfstm|||; fudge some kind of start time|16673
||exi||||; return to asign caller|16674
;
;      here for keyword maxlngth
;
|asg24|bge|8,wa|18,=mnlen|6,asg15|; if acceptable value|16679
||erb|1,287|26,value assigned to keyword maxlngth is too small|||16680
;
;      here for keyword fullscan
;
|asg26|bnz|8,wa|6,asg15||; if acceptable value|16684
||erb|1,274|26,value assigned to keyword fullscan is zero|||16685
;
||enp||||; end procedure asign|16687
||ejc|||||16688
;
;      asinp -- assign during pattern match
;
;      asinp is like asign and has a similar calling sequence
;      and effect. the difference is that the global pattern
;      variables are saved and restored if required.
;
;      (xl)		     base pointer for variable
;      (wa)		     offset for variable
;      (wb)		     value to be assigned
;      jsr  asinp	     call to assign value to variable
;      ppm  loc		     transfer loc if failure
;      (xr,xl)		     destroyed
;      (wa,wb,wc,ra)	     destroyed
;
|asinp|prc|25,r|1,1||; entry point, recursive|16704
||add|7,xl|8,wa||; point to variable|16705
||mov|7,xr|9,(xl)||; load current contents|16706
||beq|9,(xr)|22,=b_trt|6,asnp1|; jump if trapped|16707
||mov|9,(xl)|8,wb||; else perform assignment|16708
||zer|7,xl|||; clear garbage value in xl|16709
||exi||||; return to asinp caller|16710
;
;      here if variable is trapped
;
|asnp1|sub|7,xl|8,wa||; restore base pointer|16714
||mov|11,-(xs)|3,pmssl||; stack subject string length|16715
||mov|11,-(xs)|3,pmhbs||; stack history stack base ptr|16716
||mov|11,-(xs)|3,r_pms||; stack subject string pointer|16717
||mov|11,-(xs)|3,pmdfl||; stack dot flag|16718
||jsr|6,asign|||; call full-blown assignment routine|16719
||ppm|6,asnp2|||; jump if failure|16720
||mov|3,pmdfl|10,(xs)+||; restore dot flag|16721
||mov|3,r_pms|10,(xs)+||; restore subject string pointer|16722
||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|16723
||mov|3,pmssl|10,(xs)+||; restore subject string length|16724
||exi||||; return to asinp caller|16725
;
;      here if failure in asign call
;
|asnp2|mov|3,pmdfl|10,(xs)+||; restore dot flag|16729
||mov|3,r_pms|10,(xs)+||; restore subject string pointer|16730
||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|16731
||mov|3,pmssl|10,(xs)+||; restore subject string length|16732
||exi|1,1|||; take failure exit|16733
||enp||||; end procedure asinp|16734
||ejc|||||16735
;
;      blkln -- determine length of block
;
;      blkln determines the length of a block in dynamic store.
;
;      (wa)		     first word of block
;      (xr)		     pointer to block
;      jsr  blkln	     call to get block length
;      (wa)		     length of block in bytes
;      (xl)		     destroyed
;
;      blkln is used by the garbage collector and is not
;      permitted to call gbcol directly or indirectly.
;
;      the first word stored in the block (i.e. at xr) may
;      be anything, but the contents of wa must be correct.
;
|blkln|prc|25,e|1,0||; entry point|16753
||mov|7,xl|8,wa||; copy first word|16754
||lei|7,xl|||; get entry id (bl_xx)|16755
||bsw|7,xl|2,bl___|6,bln00|; switch on block type|16756
||iff|2,bl_ar|6,bln01||; arblk|16796
||iff|2,bl_cd|6,bln12||; cdblk|16796
||iff|2,bl_ex|6,bln12||; exblk|16796
||iff|2,bl_ic|6,bln07||; icblk|16796
||iff|2,bl_nm|6,bln03||; nmblk|16796
||iff|2,bl_p0|6,bln02||; p0blk|16796
||iff|2,bl_p1|6,bln03||; p1blk|16796
||iff|2,bl_p2|6,bln04||; p2blk|16796
||iff|2,bl_rc|6,bln09||; rcblk|16796
||iff|2,bl_sc|6,bln10||; scblk|16796
||iff|2,bl_se|6,bln02||; seblk|16796
||iff|2,bl_tb|6,bln01||; tbblk|16796
||iff|2,bl_vc|6,bln01||; vcblk|16796
||iff|1,13|6,bln00|||16796
||iff|1,14|6,bln00|||16796
||iff|1,15|6,bln00|||16796
||iff|2,bl_pd|6,bln08||; pdblk|16796
||iff|2,bl_tr|6,bln05||; trblk|16796
||iff|1,18|6,bln00|||16796
||iff|1,19|6,bln00|||16796
||iff|1,20|6,bln00|||16796
||iff|2,bl_ct|6,bln06||; ctblk|16796
||iff|2,bl_df|6,bln01||; dfblk|16796
||iff|2,bl_ef|6,bln01||; efblk|16796
||iff|2,bl_ev|6,bln03||; evblk|16796
||iff|2,bl_ff|6,bln05||; ffblk|16796
||iff|2,bl_kv|6,bln03||; kvblk|16796
||iff|2,bl_pf|6,bln01||; pfblk|16796
||iff|2,bl_te|6,bln04||; teblk|16796
||esw||||; end of jump table on block type|16796
||ejc|||||16797
;
;      blkln (continued)
;
;      here for blocks with length in second word
;
|bln00|mov|8,wa|13,num01(xr)||; load length|16803
||exi||||; return to blkln caller|16804
;
;      here for length in third word (ar,cd,df,ef,ex,pf,tb,vc)
;
|bln01|mov|8,wa|13,num02(xr)||; load length from third word|16808
||exi||||; return to blkln caller|16809
;
;      here for two word blocks (p0,se)
;
|bln02|mov|8,wa|19,*num02||; load length (two words)|16813
||exi||||; return to blkln caller|16814
;
;      here for three word blocks (nm,p1,ev,kv)
;
|bln03|mov|8,wa|19,*num03||; load length (three words)|16818
||exi||||; return to blkln caller|16819
;
;      here for four word blocks (p2,te,bc)
;
|bln04|mov|8,wa|19,*num04||; load length (four words)|16823
||exi||||; return to blkln caller|16824
;
;      here for five word blocks (ff,tr)
;
|bln05|mov|8,wa|19,*num05||; load length|16828
||exi||||; return to blkln caller|16829
||ejc|||||16830
;
;      blkln (continued)
;
;      here for ctblk
;
|bln06|mov|8,wa|19,*ctsi_||; set size of ctblk|16836
||exi||||; return to blkln caller|16837
;
;      here for icblk
;
|bln07|mov|8,wa|19,*icsi_||; set size of icblk|16841
||exi||||; return to blkln caller|16842
;
;      here for pdblk
;
|bln08|mov|7,xl|13,pddfp(xr)||; point to dfblk|16846
||mov|8,wa|13,dfpdl(xl)||; load pdblk length from dfblk|16847
||exi||||; return to blkln caller|16848
;
;      here for rcblk
;
|bln09|mov|8,wa|19,*rcsi_||; set size of rcblk|16854
||exi||||; return to blkln caller|16855
;
;      here for scblk
;
|bln10|mov|8,wa|13,sclen(xr)||; load length in characters|16860
||ctb|8,wa|2,scsi_||; calculate length in bytes|16861
||exi||||; return to blkln caller|16862
;
;      here for length in fourth word (cd,ex)
;
|bln12|mov|8,wa|13,num03(xr)||; load length from cdlen/exlen|16876
||exi||||; return to blkln caller|16877
||enp||||; end procedure blkln|16879
||ejc|||||16880
;
;      copyb -- copy a block
;
;      (xs)		     block to be copied
;      jsr  copyb	     call to copy block
;      ppm  loc		     return if block has no idval field
;			     normal return if idval field
;      (xr)		     copy of block
;      (xs)		     popped
;      (xl,wa,wb,wc)	     destroyed
;
|copyb|prc|25,n|1,1||; entry point|16892
||mov|7,xr|9,(xs)||; load argument|16893
||beq|7,xr|21,=nulls|6,cop10|; return argument if it is null|16894
||mov|8,wa|9,(xr)||; else load type word|16895
||mov|8,wb|8,wa||; copy type word|16896
||jsr|6,blkln|||; get length of argument block|16897
||mov|7,xl|7,xr||; copy pointer|16898
||jsr|6,alloc|||; allocate block of same size|16899
||mov|9,(xs)|7,xr||; store pointer to copy|16900
||mvw||||; copy contents of old block to new|16901
||zer|7,xl|||; clear garbage xl|16902
||mov|7,xr|9,(xs)||; reload pointer to start of copy|16903
||beq|8,wb|22,=b_tbt|6,cop05|; jump if table|16904
||beq|8,wb|22,=b_vct|6,cop01|; jump if vector|16905
||beq|8,wb|22,=b_pdt|6,cop01|; jump if program defined|16906
||bne|8,wb|22,=b_art|6,cop10|; return copy if not array|16911
;
;      here for array (arblk)
;
||add|7,xr|13,arofs(xr)||; point to prototype field|16915
||brn|6,cop02|||; jump to merge|16916
;
;      here for vector, program defined
;
|cop01|add|7,xr|19,*pdfld||; point to pdfld = vcvls|16920
;
;      merge here for arblk, vcblk, pdblk to delete trap
;      blocks from all value fields (the copy is untrapped)
;
|cop02|mov|7,xl|9,(xr)||; load next pointer|16925
;
;      loop to get value at end of trblk chain
;
|cop03|bne|9,(xl)|22,=b_trt|6,cop04|; jump if not trapped|16929
||mov|7,xl|13,trval(xl)||; else point to next value|16930
||brn|6,cop03|||; and loop back|16931
||ejc|||||16932
;
;      copyb (continued)
;
;      here with untrapped value in xl
;
|cop04|mov|10,(xr)+|7,xl||; store real value, bump pointer|16938
||bne|7,xr|3,dnamp|6,cop02|; loop back if more to go|16939
||brn|6,cop09|||; else jump to exit|16940
;
;      here to copy a table
;
|cop05|zer|13,idval(xr)|||; zero id to stop dump blowing up|16944
||mov|8,wa|19,*tesi_||; set size of teblk|16945
||mov|8,wc|19,*tbbuk||; set initial offset|16946
;
;      loop through buckets in table
;
|cop06|mov|7,xr|9,(xs)||; load table pointer|16950
||beq|8,wc|13,tblen(xr)|6,cop09|; jump to exit if all done|16951
||mov|8,wb|8,wc||; else copy offset|16952
||sub|8,wb|19,*tenxt||; subtract link offset to merge|16953
||add|7,xr|8,wb||; next bucket header less link offset|16954
||ica|8,wc|||; bump offset|16955
;
;      loop through teblks on one chain
;
|cop07|mov|7,xl|13,tenxt(xr)||; load pointer to next teblk|16959
||mov|13,tenxt(xr)|9,(xs)||; set end of chain pointer in case|16960
||beq|9,(xl)|22,=b_tbt|6,cop06|; back for next bucket if chain end|16961
||sub|7,xr|8,wb||; point to head of previous block|16962
||mov|11,-(xs)|7,xr||; stack ptr to previous block|16963
||mov|8,wa|19,*tesi_||; set size of teblk|16964
||jsr|6,alloc|||; allocate new teblk|16965
||mov|11,-(xs)|7,xr||; stack ptr to new teblk|16966
||mvw||||; copy old teblk to new teblk|16967
||mov|7,xr|10,(xs)+||; restore pointer to new teblk|16968
||mov|7,xl|10,(xs)+||; restore pointer to previous block|16969
||add|7,xl|8,wb||; add offset back in|16970
||mov|13,tenxt(xl)|7,xr||; link new block to previous|16971
||mov|7,xl|7,xr||; copy pointer to new block|16972
;
;      loop to set real value after removing trap chain
;
|cop08|mov|7,xl|13,teval(xl)||; load value|16976
||beq|9,(xl)|22,=b_trt|6,cop08|; loop back if trapped|16977
||mov|13,teval(xr)|7,xl||; store untrapped value in teblk|16978
||zer|8,wb|||; zero offset within teblk|16979
||brn|6,cop07|||; back for next teblk|16980
;
;      common exit point
;
|cop09|mov|7,xr|10,(xs)+||; load pointer to block|16984
||exi||||; return|16985
;
;      alternative return
;
|cop10|exi|1,1|||; return|16989
||ejc|||||16990
||enp||||; end procedure copyb|17008
;
;      cdgcg -- generate code for complex goto
;
;      used by cmpil to process complex goto tree
;
;      (wb)		     must be collectable
;      (xr)		     expression pointer
;      jsr  cdgcg	     call to generate complex goto
;      (xl,xr,wa)	     destroyed
;
|cdgcg|prc|25,e|1,0||; entry point|17019
||mov|7,xl|13,cmopn(xr)||; get unary goto operator|17020
||mov|7,xr|13,cmrop(xr)||; point to goto operand|17021
||beq|7,xl|21,=opdvd|6,cdgc2|; jump if direct goto|17022
||jsr|6,cdgnm|||; generate opnd by name if not direct|17023
;
;      return point
;
|cdgc1|mov|8,wa|7,xl||; goto operator|17027
||jsr|6,cdwrd|||; generate it|17028
||exi||||; return to caller|17029
;
;      direct goto
;
|cdgc2|jsr|6,cdgvl|||; generate operand by value|17033
||brn|6,cdgc1|||; merge to return|17034
||enp||||; end procedure cdgcg|17035
||ejc|||||17036
;
;      cdgex -- build expression block
;
;      cdgex is passed a pointer to an expression tree (see
;      expan) and returns an expression (seblk or exblk).
;
;      (wa)		     0 if by value, 1 if by name
;      (wc)		     some collectable value
;      (wb)		     integer in range 0 le x le mxlen
;      (xl)		     ptr to expression tree
;      jsr  cdgex	     call to build expression
;      (xr)		     ptr to seblk or exblk
;      (xl,wa,wb)	     destroyed
;
|cdgex|prc|25,r|1,0||; entry point, recursive|17053
||blo|9,(xl)|22,=b_vr_|6,cdgx1|; jump if not variable|17054
;
;      here for natural variable, build seblk
;
||mov|8,wa|19,*sesi_||; set size of seblk|17058
||jsr|6,alloc|||; allocate space for seblk|17059
||mov|9,(xr)|22,=b_sel||; set type word|17060
||mov|13,sevar(xr)|7,xl||; store vrblk pointer|17061
||exi||||; return to cdgex caller|17062
;
;      here if not variable, build exblk
;
|cdgx1|mov|7,xr|7,xl||; copy tree pointer|17066
||mov|11,-(xs)|8,wc||; save wc|17067
||mov|7,xl|3,cwcof||; save current offset|17068
||bze|8,wa|6,cdgx2||; jump if by value|17070
||mov|8,wa|9,(xr)||; get type word|17072
||bne|8,wa|22,=b_cmt|6,cdgx2|; call by value if not cmblk|17073
||bge|13,cmtyp(xr)|18,=c__nm|6,cdgx2|; jump if cmblk only by value|17074
||ejc|||||17075
;
;      cdgex (continued)
;
;      here if expression can be evaluated by name
;
||jsr|6,cdgnm|||; generate code by name|17081
||mov|8,wa|21,=ornm_||; load return by name word|17082
||brn|6,cdgx3|||; merge with value case|17083
;
;      here if expression can only be evaluated by value
;
|cdgx2|jsr|6,cdgvl|||; generate code by value|17087
||mov|8,wa|21,=orvl_||; load return by value word|17088
;
;      merge here to construct exblk
;
|cdgx3|jsr|6,cdwrd|||; generate return word|17092
||jsr|6,exbld|||; build exblk|17093
||mov|8,wc|10,(xs)+||; restore wc|17094
||exi||||; return to cdgex caller|17095
||enp||||; end procedure cdgex|17096
||ejc|||||17097
;
;      cdgnm -- generate code by name
;
;      cdgnm is called during the compilation process to
;      generate code by name for an expression. see cdblk
;      description for details of code generated. the input
;      to cdgnm is an expression tree as generated by expan.
;
;      cdgnm is a recursive procedure which proceeds by making
;      recursive calls to generate code for operands.
;
;      (wb)		     integer in range 0 le n le dnamb
;      (xr)		     ptr to tree generated by expan
;      (wc)		     constant flag (see below)
;      jsr  cdgnm	     call to generate code by name
;      (xr,wa)		     destroyed
;      (wc)		     set non-zero if non-constant
;
;      wc is set to a non-zero (collectable) value if the
;      expression for which code is generated cannot be
;      evaluated at compile time, otherwise wc is unchanged.
;
;      the code is generated in the current ccblk (see cdwrd).
;
|cdgnm|prc|25,r|1,0||; entry point, recursive|17122
||mov|11,-(xs)|7,xl||; save entry xl|17123
||mov|11,-(xs)|8,wb||; save entry wb|17124
||chk||||; check for stack overflow|17125
||mov|8,wa|9,(xr)||; load type word|17126
||beq|8,wa|22,=b_cmt|6,cgn04|; jump if cmblk|17127
||bhi|8,wa|22,=b_vr_|6,cgn02|; jump if simple variable|17128
;
;      merge here for operand yielding value (e.g. constant)
;
|cgn01|erb|1,212|26,syntax error: value used where name is required|||17132
;
;      here for natural variable reference
;
|cgn02|mov|8,wa|21,=olvn_||; load variable load call|17136
||jsr|6,cdwrd|||; generate it|17137
||mov|8,wa|7,xr||; copy vrblk pointer|17138
||jsr|6,cdwrd|||; generate vrblk pointer|17139
||ejc|||||17140
;
;      cdgnm (continued)
;
;      here to exit with wc set correctly
;
|cgn03|mov|8,wb|10,(xs)+||; restore entry wb|17146
||mov|7,xl|10,(xs)+||; restore entry xl|17147
||exi||||; return to cdgnm caller|17148
;
;      here for cmblk
;
|cgn04|mov|7,xl|7,xr||; copy cmblk pointer|17152
||mov|7,xr|13,cmtyp(xr)||; load cmblk type|17153
||bge|7,xr|18,=c__nm|6,cgn01|; error if not name operand|17154
||bsw|7,xr|2,c__nm||; else switch on type|17155
||iff|2,c_arr|6,cgn05||; array reference|17163
||iff|2,c_fnc|6,cgn08||; function call|17163
||iff|2,c_def|6,cgn09||; deferred expression|17163
||iff|2,c_ind|6,cgn10||; indirect reference|17163
||iff|2,c_key|6,cgn11||; keyword reference|17163
||iff|2,c_ubo|6,cgn08||; undefined binary op|17163
||iff|2,c_uuo|6,cgn08||; undefined unary op|17163
||esw||||; end switch on cmblk type|17163
;
;      here to generate code for array reference
;
|cgn05|mov|8,wb|19,*cmopn||; point to array operand|17167
;
;      loop to generate code for array operand and subscripts
;
|cgn06|jsr|6,cmgen|||; generate code for next operand|17171
||mov|8,wc|13,cmlen(xl)||; load length of cmblk|17172
||blt|8,wb|8,wc|6,cgn06|; loop till all generated|17173
;
;      generate appropriate array call
;
||mov|8,wa|21,=oaon_||; load one-subscript case call|17177
||beq|8,wc|19,*cmar1|6,cgn07|; jump to exit if one subscript case|17178
||mov|8,wa|21,=oamn_||; else load multi-subscript case call|17179
||jsr|6,cdwrd|||; generate call|17180
||mov|8,wa|8,wc||; copy cmblk length|17181
||btw|8,wa|||; convert to words|17182
||sub|8,wa|18,=cmvls||; calculate number of subscripts|17183
||ejc|||||17184
;
;      cdgnm (continued)
;
;      here to exit generating word (non-constant)
;
|cgn07|mnz|8,wc|||; set result non-constant|17190
||jsr|6,cdwrd|||; generate word|17191
||brn|6,cgn03|||; back to exit|17192
;
;      here to generate code for functions and undefined oprs
;
|cgn08|mov|7,xr|7,xl||; copy cmblk pointer|17196
||jsr|6,cdgvl|||; gen code by value for call|17197
||mov|8,wa|21,=ofne_||; get extra call for by name|17198
||brn|6,cgn07|||; back to generate and exit|17199
;
;      here to generate code for defered expression
;
|cgn09|mov|7,xr|13,cmrop(xl)||; check if variable|17203
||bhi|9,(xr)|22,=b_vr_|6,cgn02|; treat *variable as simple var|17204
||mov|7,xl|7,xr||; copy ptr to expression tree|17205
||mov|8,wa|18,=num01||; return name|17207
||jsr|6,cdgex|||; else build exblk|17209
||mov|8,wa|21,=olex_||; set call to load expr by name|17210
||jsr|6,cdwrd|||; generate it|17211
||mov|8,wa|7,xr||; copy exblk pointer|17212
||jsr|6,cdwrd|||; generate exblk pointer|17213
||brn|6,cgn03|||; back to exit|17214
;
;      here to generate code for indirect reference
;
|cgn10|mov|7,xr|13,cmrop(xl)||; get operand|17218
||jsr|6,cdgvl|||; generate code by value for it|17219
||mov|8,wa|21,=oinn_||; load call for indirect by name|17220
||brn|6,cgn12|||; merge|17221
;
;      here to generate code for keyword reference
;
|cgn11|mov|7,xr|13,cmrop(xl)||; get operand|17225
||jsr|6,cdgnm|||; generate code by name for it|17226
||mov|8,wa|21,=okwn_||; load call for keyword by name|17227
;
;      keyword, indirect merge here
;
|cgn12|jsr|6,cdwrd|||; generate code for operator|17231
||brn|6,cgn03|||; exit|17232
||enp||||; end procedure cdgnm|17233
||ejc|||||17234
;
;      cdgvl -- generate code by value
;
;      cdgvl is called during the compilation process to
;      generate code by value for an expression. see cdblk
;      description for details of the code generated. the input
;      to cdgvl is an expression tree as generated by expan.
;
;      cdgvl is a recursive procedure which proceeds by making
;      recursive calls to generate code for operands.
;
;      (wb)		     integer in range 0 le n le dnamb
;      (xr)		     ptr to tree generated by expan
;      (wc)		     constant flag (see below)
;      jsr  cdgvl	     call to generate code by value
;      (xr,wa)		     destroyed
;      (wc)		     set non-zero if non-constant
;
;      wc is set to a non-zero (collectable) value if the
;      expression for which code is generated cannot be
;      evaluated at compile time, otherwise wc is unchanged.
;
;      if wc is non-zero on entry, then preevaluation is not
;      allowed regardless of the nature of the operand.
;
;      the code is generated in the current ccblk (see cdwrd).
;
|cdgvl|prc|25,r|1,0||; entry point, recursive|17262
||mov|8,wa|9,(xr)||; load type word|17263
||beq|8,wa|22,=b_cmt|6,cgv01|; jump if cmblk|17264
||blt|8,wa|22,=b_vra|6,cgv00|; jump if icblk, rcblk, scblk|17265
||bnz|13,vrlen(xr)|6,cgvl0||; jump if not system variable|17266
||mov|11,-(xs)|7,xr||; stack xr|17267
||mov|7,xr|13,vrsvp(xr)||; point to svblk|17268
||mov|8,wa|13,svbit(xr)||; get svblk property bits|17269
||mov|7,xr|10,(xs)+||; recover xr|17270
||anb|8,wa|4,btkwv||; check if constant keyword value|17271
||beq|8,wa|4,btkwv|6,cgv00|; jump if constant keyword value|17272
;
;      here for variable value reference
;
|cgvl0|mnz|8,wc|||; indicate non-constant value|17276
;
;      merge here for simple constant (icblk,rcblk,scblk)
;      and for variables corresponding to constant keywords.
;
|cgv00|mov|8,wa|7,xr||; copy ptr to var or constant|17281
||jsr|6,cdwrd|||; generate as code word|17282
||exi||||; return to caller|17283
||ejc|||||17284
;
;      cdgvl (continued)
;
;      here for tree node (cmblk)
;
|cgv01|mov|11,-(xs)|8,wb||; save entry wb|17290
||mov|11,-(xs)|7,xl||; save entry xl|17291
||mov|11,-(xs)|8,wc||; save entry constant flag|17292
||mov|11,-(xs)|3,cwcof||; save initial code offset|17293
||chk||||; check for stack overflow|17294
;
;      prepare to generate code for cmblk. wc is set to the
;      value of cswno (zero if -optimise, 1 if -noopt) to
;      start with and is reset non-zero for any non-constant
;      code generated. if it is still zero after generating all
;      the cmblk code, then its value is computed as the result.
;
||mov|7,xl|7,xr||; copy cmblk pointer|17302
||mov|7,xr|13,cmtyp(xr)||; load cmblk type|17303
||mov|8,wc|3,cswno||; reset constant flag|17304
||ble|7,xr|18,=c_pr_|6,cgv02|; jump if not predicate value|17305
||mnz|8,wc|||; else force non-constant case|17306
;
;      here with wc set appropriately
;
|cgv02|bsw|7,xr|2,c__nv||; switch to appropriate generator|17310
||iff|2,c_arr|6,cgv03||; array reference|17330
||iff|2,c_fnc|6,cgv05||; function call|17330
||iff|2,c_def|6,cgv14||; deferred expression|17330
||iff|2,c_ind|6,cgv31||; indirect reference|17330
||iff|2,c_key|6,cgv27||; keyword reference|17330
||iff|2,c_ubo|6,cgv29||; undefined binop|17330
||iff|2,c_uuo|6,cgv30||; undefined unop|17330
||iff|2,c_bvl|6,cgv18||; binops with val opds|17330
||iff|2,c_uvl|6,cgv19||; unops with valu opnd|17330
||iff|2,c_alt|6,cgv18||; alternation|17330
||iff|2,c_cnc|6,cgv24||; concatenation|17330
||iff|2,c_cnp|6,cgv24||; concatenation (not pattern match)|17330
||iff|2,c_unm|6,cgv27||; unops with name opnd|17330
||iff|2,c_bvn|6,cgv26||; binary _ and .|17330
||iff|2,c_ass|6,cgv21||; assignment|17330
||iff|2,c_int|6,cgv31||; interrogation|17330
||iff|2,c_neg|6,cgv28||; negation|17330
||iff|2,c_sel|6,cgv15||; selection|17330
||iff|2,c_pmt|6,cgv18||; pattern match|17330
||esw||||; end switch on cmblk type|17330
||ejc|||||17331
;
;      cdgvl (continued)
;
;      here to generate code for array reference
;
|cgv03|mov|8,wb|19,*cmopn||; set offset to array operand|17337
;
;      loop to generate code for array operand and subscripts
;
|cgv04|jsr|6,cmgen|||; gen value code for next operand|17341
||mov|8,wc|13,cmlen(xl)||; load cmblk length|17342
||blt|8,wb|8,wc|6,cgv04|; loop back if more to go|17343
;
;      generate call to appropriate array reference routine
;
||mov|8,wa|21,=oaov_||; set one subscript call in case|17347
||beq|8,wc|19,*cmar1|6,cgv32|; jump to exit if 1-sub case|17348
||mov|8,wa|21,=oamv_||; else set call for multi-subscripts|17349
||jsr|6,cdwrd|||; generate call|17350
||mov|8,wa|8,wc||; copy length of cmblk|17351
||sub|8,wa|19,*cmvls||; subtract standard length|17352
||btw|8,wa|||; get number of words|17353
||brn|6,cgv32|||; jump to generate subscript count|17354
;
;      here to generate code for function call
;
|cgv05|mov|8,wb|19,*cmvls||; set offset to first argument|17358
;
;      loop to generate code for arguments
;
|cgv06|beq|8,wb|13,cmlen(xl)|6,cgv07|; jump if all generated|17362
||jsr|6,cmgen|||; else gen value code for next arg|17363
||brn|6,cgv06|||; back to generate next argument|17364
;
;      here to generate actual function call
;
|cgv07|sub|8,wb|19,*cmvls||; get number of arg ptrs (bytes)|17368
||btw|8,wb|||; convert bytes to words|17369
||mov|7,xr|13,cmopn(xl)||; load function vrblk pointer|17370
||bnz|13,vrlen(xr)|6,cgv12||; jump if not system function|17371
||mov|7,xl|13,vrsvp(xr)||; load svblk ptr if system var|17372
||mov|8,wa|13,svbit(xl)||; load bit mask|17373
||anb|8,wa|4,btffc||; test for fast function call allowed|17374
||zrb|8,wa|6,cgv12||; jump if not|17375
||ejc|||||17376
;
;      cdgvl (continued)
;
;      here if fast function call is allowed
;
||mov|8,wa|13,svbit(xl)||; reload bit indicators|17382
||anb|8,wa|4,btpre||; test for preevaluation ok|17383
||nzb|8,wa|6,cgv08||; jump if preevaluation permitted|17384
||mnz|8,wc|||; else set result non-constant|17385
;
;      test for correct number of args for fast call
;
|cgv08|mov|7,xl|13,vrfnc(xr)||; load ptr to svfnc field|17389
||mov|8,wa|13,fargs(xl)||; load svnar field value|17390
||beq|8,wa|8,wb|6,cgv11|; jump if argument count is correct|17391
||bhi|8,wa|8,wb|6,cgv09|; jump if too few arguments given|17392
;
;      here if too many arguments, prepare to generate o_pops
;
||sub|8,wb|8,wa||; get number of extra args|17396
||lct|8,wb|8,wb||; set as count to control loop|17397
||mov|8,wa|21,=opop_||; set pop call|17398
||brn|6,cgv10|||; jump to common loop|17399
;
;      here if too few arguments, prepare to generate nulls
;
|cgv09|sub|8,wa|8,wb||; get number of missing arguments|17403
||lct|8,wb|8,wa||; load as count to control loop|17404
||mov|8,wa|21,=nulls||; load ptr to null constant|17405
;
;      loop to generate calls to fix argument count
;
|cgv10|jsr|6,cdwrd|||; generate one call|17409
||bct|8,wb|6,cgv10||; loop till all generated|17410
;
;      here after adjusting arg count as required
;
|cgv11|mov|8,wa|7,xl||; copy pointer to svfnc field|17414
||brn|6,cgv36|||; jump to generate call|17415
||ejc|||||17416
;
;      cdgvl (continued)
;
;      come here if fast call is not permitted
;
|cgv12|mov|8,wa|21,=ofns_||; set one arg call in case|17422
||beq|8,wb|18,=num01|6,cgv13|; jump if one arg case|17423
||mov|8,wa|21,=ofnc_||; else load call for more than 1 arg|17424
||jsr|6,cdwrd|||; generate it|17425
||mov|8,wa|8,wb||; copy argument count|17426
;
;      one arg case merges here
;
|cgv13|jsr|6,cdwrd|||; generate =o_fns or arg count|17430
||mov|8,wa|7,xr||; copy vrblk pointer|17431
||brn|6,cgv32|||; jump to generate vrblk ptr|17432
;
;      here for deferred expression
;
|cgv14|mov|7,xl|13,cmrop(xl)||; point to expression tree|17436
||zer|8,wa|||; return value|17438
||jsr|6,cdgex|||; build exblk or seblk|17440
||mov|8,wa|7,xr||; copy block ptr|17441
||jsr|6,cdwrd|||; generate ptr to exblk or seblk|17442
||brn|6,cgv34|||; jump to exit, constant test|17443
;
;      here to generate code for selection
;
|cgv15|zer|11,-(xs)|||; zero ptr to chain of forward jumps|17447
||zer|11,-(xs)|||; zero ptr to prev o_slc forward ptr|17448
||mov|8,wb|19,*cmvls||; point to first alternative|17449
||mov|8,wa|21,=osla_||; set initial code word|17450
;
;      0(xs)		     is the offset to the previous word
;			     which requires filling in with an
;			     offset to the following o_slc,o_sld
;
;      1(xs)		     is the head of a chain of offset
;			     pointers indicating those locations
;			     to be filled with offsets past
;			     the end of all the alternatives
;
|cgv16|jsr|6,cdwrd|||; generate o_slc (o_sla first time)|17461
||mov|9,(xs)|3,cwcof||; set current loc as ptr to fill in|17462
||jsr|6,cdwrd|||; generate garbage word there for now|17463
||jsr|6,cmgen|||; gen value code for alternative|17464
||mov|8,wa|21,=oslb_||; load o_slb pointer|17465
||jsr|6,cdwrd|||; generate o_slb call|17466
||mov|8,wa|13,num01(xs)||; load old chain ptr|17467
||mov|13,num01(xs)|3,cwcof||; set current loc as new chain head|17468
||jsr|6,cdwrd|||; generate forward chain link|17469
||ejc|||||17470
;
;      cdgvl (continued)
;
;      now to fill in the skip offset to o_slc,o_sld
;
||mov|7,xr|9,(xs)||; load offset to word to plug|17476
||add|7,xr|3,r_ccb||; point to actual location to plug|17477
||mov|9,(xr)|3,cwcof||; plug proper offset in|17478
||mov|8,wa|21,=oslc_||; load o_slc ptr for next alternative|17479
||mov|7,xr|8,wb||; copy offset (destroy garbage xr)|17480
||ica|7,xr|||; bump extra time for test|17481
||blt|7,xr|13,cmlen(xl)|6,cgv16|; loop back if not last alternative|17482
;
;      here to generate code for last alternative
;
||mov|8,wa|21,=osld_||; get header call|17486
||jsr|6,cdwrd|||; generate o_sld call|17487
||jsr|6,cmgen|||; generate code for last alternative|17488
||ica|7,xs|||; pop offset ptr|17489
||mov|7,xr|10,(xs)+||; load chain ptr|17490
;
;      loop to plug offsets past structure
;
|cgv17|add|7,xr|3,r_ccb||; make next ptr absolute|17494
||mov|8,wa|9,(xr)||; load forward ptr|17495
||mov|9,(xr)|3,cwcof||; plug required offset|17496
||mov|7,xr|8,wa||; copy forward ptr|17497
||bnz|8,wa|6,cgv17||; loop back if more to go|17498
||brn|6,cgv33|||; else jump to exit (not constant)|17499
;
;      here for binary ops with value operands
;
|cgv18|mov|7,xr|13,cmlop(xl)||; load left operand pointer|17503
||jsr|6,cdgvl|||; gen value code for left operand|17504
;
;      here for unary ops with value operand (binops merge)
;
|cgv19|mov|7,xr|13,cmrop(xl)||; load right (only) operand ptr|17508
||jsr|6,cdgvl|||; gen code by value|17509
||ejc|||||17510
;
;      cdgvl (continued)
;
;      merge here to generate operator call from cmopn field
;
|cgv20|mov|8,wa|13,cmopn(xl)||; load operator call pointer|17516
||brn|6,cgv36|||; jump to generate it with cons test|17517
;
;      here for assignment
;
|cgv21|mov|7,xr|13,cmlop(xl)||; load left operand pointer|17521
||blo|9,(xr)|22,=b_vr_|6,cgv22|; jump if not variable|17522
;
;      here for assignment to simple variable
;
||mov|7,xr|13,cmrop(xl)||; load right operand ptr|17526
||jsr|6,cdgvl|||; generate code by value|17527
||mov|8,wa|13,cmlop(xl)||; reload left operand vrblk ptr|17528
||add|8,wa|19,*vrsto||; point to vrsto field|17529
||brn|6,cgv32|||; jump to generate store ptr|17530
;
;      here if not simple variable assignment
;
|cgv22|jsr|6,expap|||; test for pattern match on left side|17534
||ppm|6,cgv23|||; jump if not pattern match|17535
;
;      here for pattern replacement
;
||mov|13,cmlop(xl)|13,cmrop(xr)||; save pattern ptr in safe place|17539
||mov|7,xr|13,cmlop(xr)||; load subject ptr|17540
||jsr|6,cdgnm|||; gen code by name for subject|17541
||mov|7,xr|13,cmlop(xl)||; load pattern ptr|17542
||jsr|6,cdgvl|||; gen code by value for pattern|17543
||mov|8,wa|21,=opmn_||; load match by name call|17544
||jsr|6,cdwrd|||; generate it|17545
||mov|7,xr|13,cmrop(xl)||; load replacement value ptr|17546
||jsr|6,cdgvl|||; gen code by value|17547
||mov|8,wa|21,=orpl_||; load replace call|17548
||brn|6,cgv32|||; jump to gen and exit (not constant)|17549
;
;      here for assignment to complex variable
;
|cgv23|mnz|8,wc|||; inhibit pre-evaluation|17553
||jsr|6,cdgnm|||; gen code by name for left side|17554
||brn|6,cgv31|||; merge with unop circuit|17555
||ejc|||||17556
;
;      cdgvl (continued)
;
;      here for concatenation
;
|cgv24|mov|7,xr|13,cmlop(xl)||; load left operand ptr|17562
||bne|9,(xr)|22,=b_cmt|6,cgv18|; ordinary binop if not cmblk|17563
||mov|8,wb|13,cmtyp(xr)||; load cmblk type code|17564
||beq|8,wb|18,=c_int|6,cgv25|; special case if interrogation|17565
||beq|8,wb|18,=c_neg|6,cgv25|; or negation|17566
||bne|8,wb|18,=c_fnc|6,cgv18|; else ordinary binop if not function|17567
||mov|7,xr|13,cmopn(xr)||; else load function vrblk ptr|17568
||bnz|13,vrlen(xr)|6,cgv18||; ordinary binop if not system var|17569
||mov|7,xr|13,vrsvp(xr)||; else point to svblk|17570
||mov|8,wa|13,svbit(xr)||; load bit indicators|17571
||anb|8,wa|4,btprd||; test for predicate function|17572
||zrb|8,wa|6,cgv18||; ordinary binop if not|17573
;
;      here if left arg of concatenation is predicate function
;
|cgv25|mov|7,xr|13,cmlop(xl)||; reload left arg|17577
||jsr|6,cdgvl|||; gen code by value|17578
||mov|8,wa|21,=opop_||; load pop call|17579
||jsr|6,cdwrd|||; generate it|17580
||mov|7,xr|13,cmrop(xl)||; load right operand|17581
||jsr|6,cdgvl|||; gen code by value as result code|17582
||brn|6,cgv33|||; exit (not constant)|17583
;
;      here to generate code for pattern, immediate assignment
;
|cgv26|mov|7,xr|13,cmlop(xl)||; load left operand|17587
||jsr|6,cdgvl|||; gen code by value, merge|17588
;
;      here for unops with arg by name (binary _ . merge)
;
|cgv27|mov|7,xr|13,cmrop(xl)||; load right operand ptr|17592
||jsr|6,cdgnm|||; gen code by name for right arg|17593
||mov|7,xr|13,cmopn(xl)||; get operator code word|17594
||bne|9,(xr)|22,=o_kwv|6,cgv20|; gen call unless keyword value|17595
||ejc|||||17596
;
;      cdgvl (continued)
;
;      here for keyword by value. this is constant only if
;      the operand is one of the special system variables with
;      the svckw bit set to indicate a constant keyword value.
;      note that the only constant operand by name is a variable
;
||bnz|8,wc|6,cgv20||; gen call if non-constant (not var)|17605
||mnz|8,wc|||; else set non-constant in case|17606
||mov|7,xr|13,cmrop(xl)||; load ptr to operand vrblk|17607
||bnz|13,vrlen(xr)|6,cgv20||; gen (non-constant) if not sys var|17608
||mov|7,xr|13,vrsvp(xr)||; else load ptr to svblk|17609
||mov|8,wa|13,svbit(xr)||; load bit mask|17610
||anb|8,wa|4,btckw||; test for constant keyword|17611
||zrb|8,wa|6,cgv20||; go gen if not constant|17612
||zer|8,wc|||; else set result constant|17613
||brn|6,cgv20|||; and jump back to generate call|17614
;
;      here to generate code for negation
;
|cgv28|mov|8,wa|21,=onta_||; get initial word|17618
||jsr|6,cdwrd|||; generate it|17619
||mov|8,wb|3,cwcof||; save next offset|17620
||jsr|6,cdwrd|||; generate gunk word for now|17621
||mov|7,xr|13,cmrop(xl)||; load right operand ptr|17622
||jsr|6,cdgvl|||; gen code by value|17623
||mov|8,wa|21,=ontb_||; load end of evaluation call|17624
||jsr|6,cdwrd|||; generate it|17625
||mov|7,xr|8,wb||; copy offset to word to plug|17626
||add|7,xr|3,r_ccb||; point to actual word to plug|17627
||mov|9,(xr)|3,cwcof||; plug word with current offset|17628
||mov|8,wa|21,=ontc_||; load final call|17629
||brn|6,cgv32|||; jump to generate it (not constant)|17630
;
;      here to generate code for undefined binary operator
;
|cgv29|mov|7,xr|13,cmlop(xl)||; load left operand ptr|17634
||jsr|6,cdgvl|||; generate code by value|17635
||ejc|||||17636
;
;      cdgvl (continued)
;
;      here to generate code for undefined unary operator
;
|cgv30|mov|8,wb|18,=c_uo_||; set unop code + 1|17642
||sub|8,wb|13,cmtyp(xl)||; set number of args (1 or 2)|17643
;
;      merge here for undefined operators
;
||mov|7,xr|13,cmrop(xl)||; load right (only) operand pointer|17647
||jsr|6,cdgvl|||; gen value code for right operand|17648
||mov|7,xr|13,cmopn(xl)||; load pointer to operator dv|17649
||mov|7,xr|13,dvopn(xr)||; load pointer offset|17650
||wtb|7,xr|||; convert word offset to bytes|17651
||add|7,xr|20,=r_uba||; point to proper function ptr|17652
||sub|7,xr|19,*vrfnc||; set standard function offset|17653
||brn|6,cgv12|||; merge with function call circuit|17654
;
;      here to generate code for interrogation, indirection
;
|cgv31|mnz|8,wc|||; set non constant|17658
||brn|6,cgv19|||; merge|17659
;
;      here to exit generating a word, result not constant
;
|cgv32|jsr|6,cdwrd|||; generate word, merge|17663
;
;      here to exit with no word generated, not constant
;
|cgv33|mnz|8,wc|||; indicate result is not constant|17667
;
;      common exit point
;
|cgv34|ica|7,xs|||; pop initial code offset|17671
||mov|8,wa|10,(xs)+||; restore old constant flag|17672
||mov|7,xl|10,(xs)+||; restore entry xl|17673
||mov|8,wb|10,(xs)+||; restore entry wb|17674
||bnz|8,wc|6,cgv35||; jump if not constant|17675
||mov|8,wc|8,wa||; else restore entry constant flag|17676
;
;      here to return after dealing with wc setting
;
|cgv35|exi||||; return to cdgvl caller|17680
;
;      exit here to generate word and test for constant
;
|cgv36|jsr|6,cdwrd|||; generate word|17684
||bnz|8,wc|6,cgv34||; jump to exit if not constant|17685
||ejc|||||17686
;
;      cdgvl (continued)
;
;      here to preevaluate constant sub-expression
;
||mov|8,wa|21,=orvl_||; load call to return value|17692
||jsr|6,cdwrd|||; generate it|17693
||mov|7,xl|9,(xs)||; load initial code offset|17694
||jsr|6,exbld|||; build exblk for expression|17695
||zer|8,wb|||; set to evaluate by value|17696
||jsr|6,evalx|||; evaluate expression|17697
||ppm||||; should not fail|17698
||mov|8,wa|9,(xr)||; load type word of result|17699
||blo|8,wa|22,=p_aaa|6,cgv37|; jump if not pattern|17700
||mov|8,wa|21,=olpt_||; else load special pattern load call|17701
||jsr|6,cdwrd|||; generate it|17702
;
;      merge here to generate pointer to resulting constant
;
|cgv37|mov|8,wa|7,xr||; copy constant pointer|17706
||jsr|6,cdwrd|||; generate ptr|17707
||zer|8,wc|||; set result constant|17708
||brn|6,cgv34|||; jump back to exit|17709
||enp||||; end procedure cdgvl|17710
||ejc|||||17711
;
;      cdwrd -- generate one word of code
;
;      cdwrd writes one word into the current code block under
;      construction. a new, larger, block is allocated if there
;      is insufficient room in the current block. cdwrd ensures
;      that there are at least four words left in the block
;      after entering the new word. this guarantees that any
;      extra space at the end can be split off as a ccblk.
;
;      (wa)		     word to be generated
;      jsr  cdwrd	     call to generate word
;
|cdwrd|prc|25,e|1,0||; entry point|17729
||mov|11,-(xs)|7,xr||; save entry xr|17730
||mov|11,-(xs)|8,wa||; save code word to be generated|17731
;
;      merge back here after allocating larger block
;
|cdwd1|mov|7,xr|3,r_ccb||; load ptr to ccblk being built|17735
||bnz|7,xr|6,cdwd2||; jump if block allocated|17736
;
;      here we allocate an entirely fresh block
;
||mov|8,wa|19,*e_cbs||; load initial length|17740
||jsr|6,alloc|||; allocate ccblk|17741
||mov|9,(xr)|22,=b_cct||; store type word|17742
||mov|3,cwcof|19,*cccod||; set initial offset|17743
||mov|13,cclen(xr)|8,wa||; store block length|17744
||zer|13,ccsln(xr)|||; zero line number|17746
||mov|3,r_ccb|7,xr||; store ptr to new block|17748
;
;      here we have a block we can use
;
|cdwd2|mov|8,wa|3,cwcof||; load current offset|17752
||add|8,wa|19,*num05||; adjust for test (five words)|17754
||blo|8,wa|13,cclen(xr)|6,cdwd4|; jump if room in this block|17758
;
;      here if no room in current block
;
||bge|8,wa|3,mxlen|6,cdwd5|; jump if already at max size|17762
||add|8,wa|19,*e_cbs||; else get new size|17763
||mov|11,-(xs)|7,xl||; save entry xl|17764
||mov|7,xl|7,xr||; copy pointer|17765
||blt|8,wa|3,mxlen|6,cdwd3|; jump if not too large|17766
||mov|8,wa|3,mxlen||; else reset to max allowed size|17767
||ejc|||||17768
;
;      cdwrd (continued)
;
;      here with new block size in wa
;
|cdwd3|jsr|6,alloc|||; allocate new block|17774
||mov|3,r_ccb|7,xr||; store pointer to new block|17775
||mov|10,(xr)+|22,=b_cct||; store type word in new block|17776
||mov|10,(xr)+|8,wa||; store block length|17777
||mov|10,(xr)+|13,ccsln(xl)||; copy source line number word|17779
||add|7,xl|19,*ccuse||; point to ccuse,cccod fields in old|17781
||mov|8,wa|9,(xl)||; load ccuse value|17782
||mvw||||; copy useful words from old block|17783
||mov|7,xl|10,(xs)+||; restore xl|17784
||brn|6,cdwd1|||; merge back to try again|17785
;
;      here with room in current block
;
|cdwd4|mov|8,wa|3,cwcof||; load current offset|17789
||ica|8,wa|||; get new offset|17790
||mov|3,cwcof|8,wa||; store new offset|17791
||mov|13,ccuse(xr)|8,wa||; store in ccblk for gbcol|17792
||dca|8,wa|||; restore ptr to this word|17793
||add|7,xr|8,wa||; point to current entry|17794
||mov|8,wa|10,(xs)+||; reload word to generate|17795
||mov|9,(xr)|8,wa||; store word in block|17796
||mov|7,xr|10,(xs)+||; restore entry xr|17797
||exi||||; return to caller|17798
;
;      here if compiled code is too long for cdblk
;
|cdwd5|erb|1,213|26,syntax error: statement is too complicated.|||17802
||enp||||; end procedure cdwrd|17803
||ejc|||||17804
;
;      cmgen -- generate code for cmblk ptr
;
;      cmgen is a subsidiary procedure used to generate value
;      code for a cmblk ptr from the main code generators.
;
;      (xl)		     cmblk pointer
;      (wb)		     offset to pointer in cmblk
;      jsr  cmgen	     call to generate code
;      (xr,wa)		     destroyed
;      (wb)		     bumped by one word
;
|cmgen|prc|25,r|1,0||; entry point, recursive|17817
||mov|7,xr|7,xl||; copy cmblk pointer|17818
||add|7,xr|8,wb||; point to cmblk pointer|17819
||mov|7,xr|9,(xr)||; load cmblk pointer|17820
||jsr|6,cdgvl|||; generate code by value|17821
||ica|8,wb|||; bump offset|17822
||exi||||; return to caller|17823
||enp||||; end procedure cmgen|17824
||ejc|||||17825
;
;      cmpil (compile source code)
;
;      cmpil is used to convert snobol4 source code to internal
;      form (see cdblk format). it is used both for the initial
;      compile and at run time by the code and convert functions
;      this procedure has control for the entire duration of
;      initial compilation. an error in any procedure called
;      during compilation will lead first to the error section
;      and ultimately back here for resumed compilation. the
;      re-entry points after an error are specially labelled -
;
;      cmpce		     resume after control card error
;      cmple		     resume after label error
;      cmpse		     resume after statement error
;
;      jsr  cmpil	     call to compile code
;      (xr)		     ptr to cdblk for entry statement
;      (xl,wa,wb,wc,ra)	     destroyed
;
;      the following global variables are referenced
;
;      cmpln		     line number of first line of
;			     statement to be compiled
;
;      cmpsn		     number of next statement
;			     to be compiled.
;
;      cswxx		     control card switch values are
;			     changed when relevant control
;			     cards are met.
;
;      cwcof		     offset to next word in code block
;			     being built (see cdwrd).
;
;      lstsn		     number of statement most recently
;			     compiled (initially set to zero).
;
;      r_cim		     current (initial) compiler image
;			     (zero for initial compile call)
;
;      r_cni		     used to point to following image.
;			     (see readr procedure).
;
;      scngo		     goto switch for scane procedure
;
;      scnil		     length of current image excluding
;			     characters removed by -input.
;
;      scnpt		     current scan offset, see scane.
;
;      scnrs		     rescan switch for scane procedure.
;
;      scnse		     offset (in r_cim) of most recently
;			     scanned element. set zero if not
;			     currently scanning items
||ejc|||||17882
;
;      cmpil (continued)
;
;      stage		   stgic  initial compile in progress
;			   stgxc  code/convert compile
;			   stgev  building exblk for eval
;			   stgxt  execute time (outside compile)
;			   stgce  initial compile after end line
;			   stgxe  execute compile after end line
;
;      cmpil also uses a fixed number of locations on the
;      main stack as follows. (the definitions of the actual
;      offsets are in the definitions section).
;
;      cmstm(xs)	     pointer to expan tree for body of
;			     statement (see expan procedure).
;
;      cmsgo(xs)	     pointer to tree representation of
;			     success goto (see procedure scngo)
;			     zero if no success goto is given
;
;      cmfgo(xs)	     like cmsgo for failure goto.
;
;      cmcgo(xs)	     set non-zero only if there is a
;			     conditional goto. used for -fail,
;			     -nofail code generation.
;
;      cmpcd(xs)	     pointer to cdblk for previous
;			     statement. zero for 1st statement.
;
;      cmffp(xs)	     set non-zero if cdfal in previous
;			     cdblk needs filling with forward
;			     pointer, else set to zero.
;
;      cmffc(xs)	     same as cmffp for current cdblk
;
;      cmsop(xs)	     offset to word in previous cdblk
;			     to be filled in with forward ptr
;			     to next cdblk for success goto.
;			     zero if no fill in is required.
;
;      cmsoc(xs)	     same as cmsop for current cdblk.
;
;      cmlbl(xs)	     pointer to vrblk for label of
;			     current statement. zero if no label
;
;      cmtra(xs)	     pointer to cdblk for entry stmnt.
||ejc|||||17930
;
;      cmpil (continued)
;
;      entry point
;
|cmpil|prc|25,e|1,0||; entry point|17936
||lct|8,wb|18,=cmnen||; set number of stack work locations|17937
;
;      loop to initialize stack working locations
;
|cmp00|zer|11,-(xs)|||; store a zero, make one entry|17941
||bct|8,wb|6,cmp00||; loop back until all set|17942
||mov|3,cmpxs|7,xs||; save stack pointer for error sec|17943
||sss|3,cmpss|||; save s-r stack pointer if any|17944
;
;      loop through statements
;
|cmp01|mov|8,wb|3,scnpt||; set scan pointer offset|17948
||mov|3,scnse|8,wb||; set start of element location|17949
||mov|8,wa|21,=ocer_||; point to compile error call|17950
||jsr|6,cdwrd|||; generate as temporary cdfal|17951
||blt|8,wb|3,scnil|6,cmp04|; jump if chars left on this image|17952
;
;      loop here after comment or control card
;      also special entry after control card error
;
|cmpce|zer|7,xr|||; clear possible garbage xr value|17957
||bnz|3,cnind|6,cmpc2||; if within include file|17959
||bne|3,stage|18,=stgic|6,cmp02|; skip unless initial compile|17961
|cmpc2|jsr|6,readr|||; read next input image|17962
||bze|7,xr|6,cmp09||; jump if no input available|17963
||jsr|6,nexts|||; acquire next source image|17964
||mov|3,lstsn|3,cmpsn||; store stmt no for use by listr|17965
||mov|3,cmpln|3,rdcln||; store line number at start of stmt|17966
||zer|3,scnpt|||; reset scan pointer|17967
||brn|6,cmp04|||; go process image|17968
;
;      for execute time compile, permit embedded control cards
;      and comments (by skipping to next semi-colon)
;
|cmp02|mov|7,xr|3,r_cim||; get current image|17973
||mov|8,wb|3,scnpt||; get current offset|17974
||plc|7,xr|8,wb||; prepare to get chars|17975
;
;      skip to semi-colon
;
|cmp03|bge|3,scnpt|3,scnil|6,cmp09|; end loop if end of image|17979
||lch|8,wc|10,(xr)+||; get char|17980
||icv|3,scnpt|||; advance offset|17981
||bne|8,wc|18,=ch_sm|6,cmp03|; loop if not semi-colon|17982
||ejc|||||17983
;
;      cmpil (continued)
;
;      here with image available to scan. note that if the input
;      string is null, then everything is ok since null is
;      actually assembled as a word of blanks.
;
|cmp04|mov|7,xr|3,r_cim||; point to current image|17991
||mov|8,wb|3,scnpt||; load current offset|17992
||mov|8,wa|8,wb||; copy for label scan|17993
||plc|7,xr|8,wb||; point to first character|17994
||lch|8,wc|10,(xr)+||; load first character|17995
||beq|8,wc|18,=ch_sm|6,cmp12|; no label if semicolon|17996
||beq|8,wc|18,=ch_as|6,cmpce|; loop back if comment card|17997
||beq|8,wc|18,=ch_mn|6,cmp32|; jump if control card|17998
||mov|3,r_cmp|3,r_cim||; about to destroy r_cim|17999
||mov|7,xl|20,=cmlab||; point to label work string|18000
||mov|3,r_cim|7,xl||; scane is to scan work string|18001
||psc|7,xl|||; point to first character position|18002
||sch|8,wc|10,(xl)+||; store char just loaded|18003
||mov|8,wc|18,=ch_sm||; get a semicolon|18004
||sch|8,wc|9,(xl)||; store after first char|18005
||csc|7,xl|||; finished character storing|18006
||zer|7,xl|||; clear pointer|18007
||zer|3,scnpt|||; start at first character|18008
||mov|11,-(xs)|3,scnil||; preserve image length|18009
||mov|3,scnil|18,=num02||; read 2 chars at most|18010
||jsr|6,scane|||; scan first char for type|18011
||mov|3,scnil|10,(xs)+||; restore image length|18012
||mov|8,wc|7,xl||; note return code|18013
||mov|7,xl|3,r_cmp||; get old r_cim|18014
||mov|3,r_cim|7,xl||; put it back|18015
||mov|3,scnpt|8,wb||; reinstate offset|18016
||bnz|3,scnbl|6,cmp12||; blank seen - cant be label|18017
||mov|7,xr|7,xl||; point to current image|18018
||plc|7,xr|8,wb||; point to first char again|18019
||beq|8,wc|18,=t_var|6,cmp06|; ok if letter|18020
||beq|8,wc|18,=t_con|6,cmp06|; ok if digit|18021
;
;      drop in or jump from error section if scane failed
;
|cmple|mov|3,r_cim|3,r_cmp||; point to bad line|18025
||erb|1,214|26,bad label or misplaced continuation line|||18026
;
;      loop to scan label
;
|cmp05|beq|8,wc|18,=ch_sm|6,cmp07|; skip if semicolon|18030
||icv|8,wa|||; bump offset|18031
||beq|8,wa|3,scnil|6,cmp07|; jump if end of image (label end)|18032
||ejc|||||18033
;
;      cmpil (continued)
;
;      enter loop at this point
;
|cmp06|lch|8,wc|10,(xr)+||; else load next character|18039
||beq|8,wc|18,=ch_ht|6,cmp07|; jump if horizontal tab|18041
||bne|8,wc|18,=ch_bl|6,cmp05|; loop back if non-blank|18046
;
;      here after scanning out label
;
|cmp07|mov|3,scnpt|8,wa||; save updated scan offset|18050
||sub|8,wa|8,wb||; get length of label|18051
||bze|8,wa|6,cmp12||; skip if label length zero|18052
||zer|7,xr|||; clear garbage xr value|18053
||jsr|6,sbstr|||; build scblk for label name|18054
||jsr|6,gtnvr|||; locate/contruct vrblk|18055
||ppm||||; dummy (impossible) error return|18056
||mov|13,cmlbl(xs)|7,xr||; store label pointer|18057
||bnz|13,vrlen(xr)|6,cmp11||; jump if not system label|18058
||bne|13,vrsvp(xr)|21,=v_end|6,cmp11|; jump if not end label|18059
;
;      here for end label scanned out
;
||add|3,stage|18,=stgnd||; adjust stage appropriately|18063
||jsr|6,scane|||; scan out next element|18064
||beq|7,xl|18,=t_smc|6,cmp10|; jump if end of image|18065
||bne|7,xl|18,=t_var|6,cmp08|; else error if not variable|18066
;
;      here check for valid initial transfer
;
||beq|13,vrlbl(xr)|21,=stndl|6,cmp08|; jump if not defined (error)|18070
||mov|13,cmtra(xs)|13,vrlbl(xr)||; else set initial entry pointer|18071
||jsr|6,scane|||; scan next element|18072
||beq|7,xl|18,=t_smc|6,cmp10|; jump if ok (end of image)|18073
;
;      here for bad transfer label
;
|cmp08|erb|1,215|26,syntax error: undefined or erroneous entry label|||18077
;
;      here for end of input (no end label detected)
;
|cmp09|zer|7,xr|||; clear garbage xr value|18081
||add|3,stage|18,=stgnd||; adjust stage appropriately|18082
||beq|3,stage|18,=stgxe|6,cmp10|; jump if code call (ok)|18083
||erb|1,216|26,syntax error: missing end line|||18084
;
;      here after processing end line (merge here on end error)
;
|cmp10|mov|8,wa|21,=ostp_||; set stop call pointer|18088
||jsr|6,cdwrd|||; generate as statement call|18089
||brn|6,cmpse|||; jump to generate as failure|18090
||ejc|||||18091
;
;      cmpil (continued)
;
;      here after processing label other than end
;
|cmp11|bne|3,stage|18,=stgic|6,cmp12|; jump if code call - redef. ok|18097
||beq|13,vrlbl(xr)|21,=stndl|6,cmp12|; else check for redefinition|18098
||zer|13,cmlbl(xs)|||; leave first label decln undisturbed|18099
||erb|1,217|26,syntax error: duplicate label|||18100
;
;      here after dealing with label
;      null statements and statements just containing a
;      constant subject are optimized out by resetting the
;      current ccblk to empty.
;
|cmp12|zer|8,wb|||; set flag for statement body|18107
||jsr|6,expan|||; get tree for statement body|18108
||mov|13,cmstm(xs)|7,xr||; store for later use|18109
||zer|13,cmsgo(xs)|||; clear success goto pointer|18110
||zer|13,cmfgo(xs)|||; clear failure goto pointer|18111
||zer|13,cmcgo(xs)|||; clear conditional goto flag|18112
||jsr|6,scane|||; scan next element|18113
||beq|7,xl|18,=t_col|6,cmp13|; jump if colon (goto)|18114
||bnz|3,cswno|6,cmp18||; jump if not optimizing|18115
||bnz|13,cmlbl(xs)|6,cmp18||; jump if label present|18116
||mov|7,xr|13,cmstm(xs)||; load tree ptr for statement body|18117
||mov|8,wa|9,(xr)||; load type word|18118
||beq|8,wa|22,=b_cmt|6,cmp18|; jump if cmblk|18119
||bge|8,wa|22,=b_vra|6,cmp18|; jump if not icblk, scblk, or rcblk|18120
||mov|7,xl|3,r_ccb||; load ptr to ccblk|18121
||mov|13,ccuse(xl)|19,*cccod||; reset use offset in ccblk|18122
||mov|3,cwcof|19,*cccod||; and in global|18123
||icv|3,cmpsn|||; bump statement number|18124
||brn|6,cmp01|||; generate no code for statement|18125
;
;      loop to process goto fields
;
|cmp13|mnz|3,scngo|||; set goto flag|18129
||jsr|6,scane|||; scan next element|18130
||beq|7,xl|18,=t_smc|6,cmp31|; jump if no fields left|18131
||beq|7,xl|18,=t_sgo|6,cmp14|; jump if s for success goto|18132
||beq|7,xl|18,=t_fgo|6,cmp16|; jump if f for failure goto|18133
;
;      here for unconditional goto (i.e. not f or s)
;
||mnz|3,scnrs|||; set to rescan element not f,s|18137
||jsr|6,scngf|||; scan out goto field|18138
||bnz|13,cmfgo(xs)|6,cmp17||; error if fgoto already|18139
||mov|13,cmfgo(xs)|7,xr||; else set as fgoto|18140
||brn|6,cmp15|||; merge with sgoto circuit|18141
;
;      here for success goto
;
|cmp14|jsr|6,scngf|||; scan success goto field|18145
||mov|13,cmcgo(xs)|18,=num01||; set conditional goto flag|18146
;
;      uncontional goto merges here
;
|cmp15|bnz|13,cmsgo(xs)|6,cmp17||; error if sgoto already given|18150
||mov|13,cmsgo(xs)|7,xr||; else set sgoto|18151
||brn|6,cmp13|||; loop back for next goto field|18152
;
;      here for failure goto
;
|cmp16|jsr|6,scngf|||; scan goto field|18156
||mov|13,cmcgo(xs)|18,=num01||; set conditonal goto flag|18157
||bnz|13,cmfgo(xs)|6,cmp17||; error if fgoto already given|18158
||mov|13,cmfgo(xs)|7,xr||; else store fgoto pointer|18159
||brn|6,cmp13|||; loop back for next field|18160
||ejc|||||18161
;
;      cmpil (continued)
;
;      here for duplicated goto field
;
|cmp17|erb|1,218|26,syntax error: duplicated goto field|||18167
;
;      here to generate code
;
|cmp18|zer|3,scnse|||; stop positional error flags|18171
||mov|7,xr|13,cmstm(xs)||; load tree ptr for statement body|18172
||zer|8,wb|||; collectable value for wb for cdgvl|18173
||zer|8,wc|||; reset constant flag for cdgvl|18174
||jsr|6,expap|||; test for pattern match|18175
||ppm|6,cmp19|||; jump if not pattern match|18176
||mov|13,cmopn(xr)|21,=opms_||; else set pattern match pointer|18177
||mov|13,cmtyp(xr)|18,=c_pmt||;|18178
;
;      here after dealing with special pattern match case
;
|cmp19|jsr|6,cdgvl|||; generate code for body of statement|18182
||mov|7,xr|13,cmsgo(xs)||; load sgoto pointer|18183
||mov|8,wa|7,xr||; copy it|18184
||bze|7,xr|6,cmp21||; jump if no success goto|18185
||zer|13,cmsoc(xs)|||; clear success offset fillin ptr|18186
||bhi|7,xr|3,state|6,cmp20|; jump if complex goto|18187
;
;      here for simple success goto (label)
;
||add|8,wa|19,*vrtra||; point to vrtra field as required|18191
||jsr|6,cdwrd|||; generate success goto|18192
||brn|6,cmp22|||; jump to deal with fgoto|18193
;
;      here for complex success goto
;
|cmp20|beq|7,xr|13,cmfgo(xs)|6,cmp22|; no code if same as fgoto|18197
||zer|8,wb|||; else set ok value for cdgvl in wb|18198
||jsr|6,cdgcg|||; generate code for success goto|18199
||brn|6,cmp22|||; jump to deal with fgoto|18200
;
;      here for no success goto
;
|cmp21|mov|13,cmsoc(xs)|3,cwcof||; set success fill in offset|18204
||mov|8,wa|21,=ocer_||; point to compile error call|18205
||jsr|6,cdwrd|||; generate as temporary value|18206
||ejc|||||18207
;
;      cmpil (continued)
;
;      here to deal with failure goto
;
|cmp22|mov|7,xr|13,cmfgo(xs)||; load failure goto pointer|18213
||mov|8,wa|7,xr||; copy it|18214
||zer|13,cmffc(xs)|||; set no fill in required yet|18215
||bze|7,xr|6,cmp23||; jump if no failure goto given|18216
||add|8,wa|19,*vrtra||; point to vrtra field in case|18217
||blo|7,xr|3,state|6,cmpse|; jump to gen if simple fgoto|18218
;
;      here for complex failure goto
;
||mov|8,wb|3,cwcof||; save offset to o_gof call|18222
||mov|8,wa|21,=ogof_||; point to failure goto call|18223
||jsr|6,cdwrd|||; generate|18224
||mov|8,wa|21,=ofif_||; point to fail in fail word|18225
||jsr|6,cdwrd|||; generate|18226
||jsr|6,cdgcg|||; generate code for failure goto|18227
||mov|8,wa|8,wb||; copy offset to o_gof for cdfal|18228
||mov|8,wb|22,=b_cdc||; set complex case cdtyp|18229
||brn|6,cmp25|||; jump to build cdblk|18230
;
;      here if no failure goto given
;
|cmp23|mov|8,wa|21,=ounf_||; load unexpected failure call in cas|18234
||mov|8,wc|3,cswfl||; get -nofail flag|18235
||orb|8,wc|13,cmcgo(xs)||; check if conditional goto|18236
||zrb|8,wc|6,cmpse||; jump if -nofail and no cond. goto|18237
||mnz|13,cmffc(xs)|||; else set fill in flag|18238
||mov|8,wa|21,=ocer_||; and set compile error for temporary|18239
;
;      merge here with cdfal value in wa, simple cdblk
;      also special entry after statement error
;
|cmpse|mov|8,wb|22,=b_cds||; set cdtyp for simple case|18244
||ejc|||||18245
;
;      cmpil (continued)
;
;      merge here to build cdblk
;
;      (wa)		     cdfal value to be generated
;      (wb)		     cdtyp value to be generated
;
;      at this stage, we chop off an appropriate chunk of the
;      current ccblk and convert it into a cdblk. the remainder
;      of the ccblk is reformatted to be the new ccblk.
;
|cmp25|mov|7,xr|3,r_ccb||; point to ccblk|18258
||mov|7,xl|13,cmlbl(xs)||; get possible label pointer|18259
||bze|7,xl|6,cmp26||; skip if no label|18260
||zer|13,cmlbl(xs)|||; clear flag for next statement|18261
||mov|13,vrlbl(xl)|7,xr||; put cdblk ptr in vrblk label field|18262
;
;      merge after doing label
;
|cmp26|mov|9,(xr)|8,wb||; set type word for new cdblk|18266
||mov|13,cdfal(xr)|8,wa||; set failure word|18267
||mov|7,xl|7,xr||; copy pointer to ccblk|18268
||mov|8,wb|13,ccuse(xr)||; load length gen (= new cdlen)|18269
||mov|8,wc|13,cclen(xr)||; load total ccblk length|18270
||add|7,xl|8,wb||; point past cdblk|18271
||sub|8,wc|8,wb||; get length left for chop off|18272
||mov|9,(xl)|22,=b_cct||; set type code for new ccblk at end|18273
||mov|13,ccuse(xl)|19,*cccod||; set initial code offset|18274
||mov|3,cwcof|19,*cccod||; reinitialise cwcof|18275
||mov|13,cclen(xl)|8,wc||; set new length|18276
||mov|3,r_ccb|7,xl||; set new ccblk pointer|18277
||zer|13,ccsln(xl)|||; initialize new line number|18279
||mov|13,cdsln(xr)|3,cmpln||; set line number in old block|18280
||mov|13,cdstm(xr)|3,cmpsn||; set statement number|18282
||icv|3,cmpsn|||; bump statement number|18283
;
;      set pointers in previous code block as required
;
||mov|7,xl|13,cmpcd(xs)||; load ptr to previous cdblk|18287
||bze|13,cmffp(xs)|6,cmp27||; jump if no failure fill in required|18288
||mov|13,cdfal(xl)|7,xr||; else set failure ptr in previous|18289
;
;      here to deal with success forward pointer
;
|cmp27|mov|8,wa|13,cmsop(xs)||; load success offset|18293
||bze|8,wa|6,cmp28||; jump if no fill in required|18294
||add|7,xl|8,wa||; else point to fill in location|18295
||mov|9,(xl)|7,xr||; store forward pointer|18296
||zer|7,xl|||; clear garbage xl value|18297
||ejc|||||18298
;
;      cmpil (continued)
;
;      now set fill in pointers for this statement
;
|cmp28|mov|13,cmffp(xs)|13,cmffc(xs)||; copy failure fill in flag|18304
||mov|13,cmsop(xs)|13,cmsoc(xs)||; copy success fill in offset|18305
||mov|13,cmpcd(xs)|7,xr||; save ptr to this cdblk|18306
||bnz|13,cmtra(xs)|6,cmp29||; jump if initial entry already set|18307
||mov|13,cmtra(xs)|7,xr||; else set ptr here as default|18308
;
;      here after compiling one statement
;
|cmp29|blt|3,stage|18,=stgce|6,cmp01|; jump if not end line just done|18312
||bze|3,cswls|6,cmp30||; skip if -nolist|18313
||jsr|6,listr|||; list last line|18314
;
;      return
;
|cmp30|mov|7,xr|13,cmtra(xs)||; load initial entry cdblk pointer|18318
||add|7,xs|19,*cmnen||; pop work locations off stack|18319
||exi||||; and return to cmpil caller|18320
;
;      here at end of goto field
;
|cmp31|mov|8,wb|13,cmfgo(xs)||; get fail goto|18324
||orb|8,wb|13,cmsgo(xs)||; or in success goto|18325
||bnz|8,wb|6,cmp18||; ok if non-null field|18326
||erb|1,219|26,syntax error: empty goto field|||18327
;
;      control card found
;
|cmp32|icv|8,wb|||; point past ch_mn|18331
||jsr|6,cncrd|||; process control card|18332
||zer|3,scnse|||; clear start of element loc.|18333
||brn|6,cmpce|||; loop for next statement|18334
||enp||||; end procedure cmpil|18335
||ejc|||||18336
;
;      cncrd -- control card processor
;
;      called to deal with control cards
;
;      r_cim		     points to current image
;      (wb)		     offset to 1st char of control card
;      jsr  cncrd	     call to process control cards
;      (xl,xr,wa,wb,wc,ia)   destroyed
;
|cncrd|prc|25,e|1,0||; entry point|18347
||mov|3,scnpt|8,wb||; offset for control card scan|18348
||mov|8,wa|18,=ccnoc||; number of chars for comparison|18349
||ctw|8,wa|1,0||; convert to word count|18350
||mov|3,cnswc|8,wa||; save word count|18351
;
;      loop here if more than one control card
;
|cnc01|bge|3,scnpt|3,scnil|6,cnc09|; return if end of image|18355
||mov|7,xr|3,r_cim||; point to image|18356
||plc|7,xr|3,scnpt||; char ptr for first char|18357
||lch|8,wa|10,(xr)+||; get first char|18358
||flc|8,wa|||; fold to lower case|18360
||beq|8,wa|18,=ch_li|6,cnc07|; special case of -inxxx|18362
|cnc0a|mnz|3,scncc|||; set flag for scane|18363
||jsr|6,scane|||; scan card name|18364
||zer|3,scncc|||; clear scane flag|18365
||bnz|7,xl|6,cnc06||; fail unless control card name|18366
||mov|8,wa|18,=ccnoc||; no. of chars to be compared|18367
||blt|13,sclen(xr)|8,wa|6,cnc08|; fail if too few chars|18369
||mov|7,xl|7,xr||; point to control card name|18373
||zer|8,wb|||; zero offset for substring|18374
||jsr|6,sbstr|||; extract substring for comparison|18375
||mov|8,wa|13,sclen(xr)||; reload length|18377
||jsr|6,flstg|||; fold to upper case|18378
||mov|3,cnscc|7,xr||; keep control card substring ptr|18380
||mov|7,xr|21,=ccnms||; point to list of standard names|18381
||zer|8,wb|||; initialise name offset|18382
||lct|8,wc|18,=cc_nc||; number of standard names|18383
;
;      try to match name
;
|cnc02|mov|7,xl|3,cnscc||; point to name|18387
||lct|8,wa|3,cnswc||; counter for inner loop|18388
||brn|6,cnc04|||; jump into loop|18389
;
;      inner loop to match card name chars
;
|cnc03|ica|7,xr|||; bump standard names ptr|18393
||ica|7,xl|||; bump name pointer|18394
;
;      here to initiate the loop
;
|cnc04|cne|13,schar(xl)|9,(xr)|6,cnc05|; comp. up to cfp_c chars at once|18398
||bct|8,wa|6,cnc03||; loop if more words to compare|18399
||ejc|||||18400
;
;      cncrd (continued)
;
;      matched - branch on card offset
;
||mov|7,xl|8,wb||; get name offset|18406
||bsw|7,xl|2,cc_nc|6,cnc08|; switch|18408
||iff|2,cc_ca|6,cnc37||; -case|18447
||iff|2,cc_do|6,cnc10||; -double|18447
||iff|1,2|6,cnc08|||18447
||iff|2,cc_du|6,cnc11||; -dump|18447
||iff|2,cc_cp|6,cnc41||; -copy|18447
||iff|2,cc_ej|6,cnc12||; -eject|18447
||iff|2,cc_er|6,cnc13||; -errors|18447
||iff|2,cc_ex|6,cnc14||; -execute|18447
||iff|2,cc_fa|6,cnc15||; -fail|18447
||iff|2,cc_in|6,cnc41||; -include|18447
||iff|2,cc_ln|6,cnc44||; -line|18447
||iff|2,cc_li|6,cnc16||; -list|18447
||iff|2,cc_nr|6,cnc17||; -noerrors|18447
||iff|2,cc_nx|6,cnc18||; -noexecute|18447
||iff|2,cc_nf|6,cnc19||; -nofail|18447
||iff|2,cc_nl|6,cnc20||; -nolist|18447
||iff|2,cc_no|6,cnc21||; -noopt|18447
||iff|2,cc_np|6,cnc22||; -noprint|18447
||iff|2,cc_op|6,cnc24||; -optimise|18447
||iff|2,cc_pr|6,cnc25||; -print|18447
||iff|2,cc_si|6,cnc27||; -single|18447
||iff|2,cc_sp|6,cnc28||; -space|18447
||iff|2,cc_st|6,cnc31||; -stitle|18447
||iff|2,cc_ti|6,cnc32||; -title|18447
||iff|2,cc_tr|6,cnc36||; -trace|18447
||esw||||; end switch|18447
;
;      not matched yet. align std names ptr and try again
;
|cnc05|ica|7,xr|||; bump standard names ptr|18451
||bct|8,wa|6,cnc05||; loop|18452
||icv|8,wb|||; bump names offset|18453
||bct|8,wc|6,cnc02||; continue if more names|18454
||brn|6,cnc08|||; ignore unrecognized control card|18456
;
;      invalid control card name
;
|cnc06|erb|1,247|26,invalid control statement|||18461
;
;      special processing for -inxxx
;
|cnc07|lch|8,wa|10,(xr)+||; get next char|18465
||flc|8,wa|||; fold to lower case|18467
||bne|8,wa|18,=ch_ln|6,cnc0a|; if not letter n|18469
||lch|8,wa|9,(xr)||; get third char|18470
||blt|8,wa|18,=ch_d0|6,cnc0a|; if not digit|18471
||bgt|8,wa|18,=ch_d9|6,cnc0a|; if not digit|18472
||add|3,scnpt|18,=num02||; bump offset past -in|18473
||jsr|6,scane|||; scan integer after -in|18474
||mov|11,-(xs)|7,xr||; stack scanned item|18475
||jsr|6,gtsmi|||; check if integer|18476
||ppm|6,cnc06|||; fail if not integer|18477
||ppm|6,cnc06|||; fail if negative or large|18478
||mov|3,cswin|7,xr||; keep integer|18479
||ejc|||||18480
;
;      cncrd (continued)
;
;      check for more control cards before returning
;
|cnc08|mov|8,wa|3,scnpt||; preserve in case xeq time compile|18486
||jsr|6,scane|||; look for comma|18487
||beq|7,xl|18,=t_cma|6,cnc01|; loop if comma found|18488
||mov|3,scnpt|8,wa||; restore scnpt in case xeq time|18489
;
;      return point
;
|cnc09|exi||||; return|18493
;
;      -double
;
|cnc10|mnz|3,cswdb|||; set switch|18497
||brn|6,cnc08|||; merge|18498
;
;      -dump
;      this is used for system debugging . it has the effect of
;      producing a core dump at compilation time
;
|cnc11|jsr|6,sysdm|||; call dumper|18504
||brn|6,cnc09|||; finished|18505
;
;      -eject
;
|cnc12|bze|3,cswls|6,cnc09||; return if -nolist|18509
||jsr|6,prtps|||; eject|18510
||jsr|6,listt|||; list title|18511
||brn|6,cnc09|||; finished|18512
;
;      -errors
;
|cnc13|zer|3,cswer|||; clear switch|18516
||brn|6,cnc08|||; merge|18517
;
;      -execute
;
|cnc14|zer|3,cswex|||; clear switch|18521
||brn|6,cnc08|||; merge|18522
;
;      -fail
;
|cnc15|mnz|3,cswfl|||; set switch|18526
||brn|6,cnc08|||; merge|18527
;
;      -list
;
|cnc16|mnz|3,cswls|||; set switch|18531
||beq|3,stage|18,=stgic|6,cnc08|; done if compile time|18532
;
;      list code line if execute time compile
;
||zer|3,lstpf|||; permit listing|18536
||jsr|6,listr|||; list line|18537
||brn|6,cnc08|||; merge|18538
||ejc|||||18539
;
;      cncrd (continued)
;
;      -noerrors
;
|cnc17|mnz|3,cswer|||; set switch|18545
||brn|6,cnc08|||; merge|18546
;
;      -noexecute
;
|cnc18|mnz|3,cswex|||; set switch|18550
||brn|6,cnc08|||; merge|18551
;
;      -nofail
;
|cnc19|zer|3,cswfl|||; clear switch|18555
||brn|6,cnc08|||; merge|18556
;
;      -nolist
;
|cnc20|zer|3,cswls|||; clear switch|18560
||brn|6,cnc08|||; merge|18561
;
;      -nooptimise
;
|cnc21|mnz|3,cswno|||; set switch|18565
||brn|6,cnc08|||; merge|18566
;
;      -noprint
;
|cnc22|zer|3,cswpr|||; clear switch|18570
||brn|6,cnc08|||; merge|18571
;
;      -optimise
;
|cnc24|zer|3,cswno|||; clear switch|18575
||brn|6,cnc08|||; merge|18576
;
;      -print
;
|cnc25|mnz|3,cswpr|||; set switch|18580
||brn|6,cnc08|||; merge|18581
||ejc|||||18582
;
;      cncrd (continued)
;
;      -single
;
|cnc27|zer|3,cswdb|||; clear switch|18588
||brn|6,cnc08|||; merge|18589
;
;      -space
;
|cnc28|bze|3,cswls|6,cnc09||; return if -nolist|18593
||jsr|6,scane|||; scan integer after -space|18594
||mov|8,wc|18,=num01||; 1 space in case|18595
||beq|7,xr|18,=t_smc|6,cnc29|; jump if no integer|18596
||mov|11,-(xs)|7,xr||; stack it|18597
||jsr|6,gtsmi|||; check integer|18598
||ppm|6,cnc06|||; fail if not integer|18599
||ppm|6,cnc06|||; fail if negative or large|18600
||bnz|8,wc|6,cnc29||; jump if non zero|18601
||mov|8,wc|18,=num01||; else 1 space|18602
;
;      merge with count of lines to skip
;
|cnc29|add|3,lstlc|8,wc||; bump line count|18606
||lct|8,wc|8,wc||; convert to loop counter|18607
||blt|3,lstlc|3,lstnp|6,cnc30|; jump if fits on page|18608
||jsr|6,prtps|||; eject|18609
||jsr|6,listt|||; list title|18610
||brn|6,cnc09|||; merge|18611
;
;      skip lines
;
|cnc30|jsr|6,prtnl|||; print a blank|18615
||bct|8,wc|6,cnc30||; loop|18616
||brn|6,cnc09|||; merge|18617
||ejc|||||18618
;
;      cncrd (continued)
;
;      -stitl
;
|cnc31|mov|3,cnr_t|20,=r_stl||; ptr to r_stl|18624
||brn|6,cnc33|||; merge|18625
;
;      -title
;
|cnc32|mov|3,r_stl|21,=nulls||; clear subtitle|18629
||mov|3,cnr_t|20,=r_ttl||; ptr to r_ttl|18630
;
;      common processing for -title, -stitl
;
|cnc33|mov|7,xr|21,=nulls||; null in case needed|18634
||mnz|3,cnttl|||; set flag for next listr call|18635
||mov|8,wb|18,=ccofs||; offset to title/subtitle|18636
||mov|8,wa|3,scnil||; input image length|18637
||blo|8,wa|8,wb|6,cnc34|; jump if no chars left|18638
||sub|8,wa|8,wb||; no of chars to extract|18639
||mov|7,xl|3,r_cim||; point to image|18640
||jsr|6,sbstr|||; get title/subtitle|18641
;
;      store title/subtitle
;
|cnc34|mov|7,xl|3,cnr_t||; point to storage location|18645
||mov|9,(xl)|7,xr||; store title/subtitle|18646
||beq|7,xl|20,=r_stl|6,cnc09|; return if stitl|18647
||bnz|3,precl|6,cnc09||; return if extended listing|18648
||bze|3,prich|6,cnc09||; return if regular printer|18649
||mov|7,xl|13,sclen(xr)||; get length of title|18650
||mov|8,wa|7,xl||; copy it|18651
||bze|7,xl|6,cnc35||; jump if null|18652
||add|7,xl|18,=num10||; increment|18653
||bhi|7,xl|3,prlen|6,cnc09|; use default lstp0 val if too long|18654
||add|8,wa|18,=num04||; point just past title|18655
;
;      store offset to page nn message for short title
;
|cnc35|mov|3,lstpo|8,wa||; store offset|18659
||brn|6,cnc09|||; return|18660
;
;      -trace
;      provided for system debugging.  toggles the system label
;      trace switch at compile time
;
|cnc36|jsr|6,systt|||; toggle switch|18666
||brn|6,cnc08|||; merge|18667
;
;      -case
;      sets value of kvcas so that names are folded or not
;      during compilation.
;
|cnc37|jsr|6,scane|||; scan integer after -case|18674
||zer|8,wc|||; get 0 in case none there|18675
||beq|7,xl|18,=t_smc|6,cnc38|; skip if no integer|18676
||mov|11,-(xs)|7,xr||; stack it|18677
||jsr|6,gtsmi|||; check integer|18678
||ppm|6,cnc06|||; fail if not integer|18679
||ppm|6,cnc06|||; fail if negative or too large|18680
|cnc38|mov|3,kvcas|8,wc||; store new case value|18681
||brn|6,cnc09|||; merge|18682
;
;      -include
;
|cnc41|mnz|3,scncc|||; set flag for scane|18705
||jsr|6,scane|||; scan quoted file name|18706
||zer|3,scncc|||; clear scane flag|18707
||bne|7,xl|18,=t_con|6,cnc06|; if not constant|18708
||bne|9,(xr)|22,=b_scl|6,cnc06|; if not string constant|18709
||mov|3,r_ifn|7,xr||; save file name|18710
||mov|7,xl|3,r_inc||; examine include file name table|18711
||zer|8,wb|||; lookup by value|18712
||jsr|6,tfind|||; do lookup|18713
||ppm||||; never fails|18714
||beq|7,xr|21,=inton|6,cnc09|; ignore if already in table|18715
||mnz|8,wb|||; set for trim|18716
||mov|7,xr|3,r_ifn||; file name|18717
||jsr|6,trimr|||; remove trailing blanks|18718
||mov|7,xl|3,r_inc||; include file name table|18719
||mnz|8,wb|||; lookup by name this time|18720
||jsr|6,tfind|||; do lookup|18721
||ppm||||; never fails|18722
||mov|13,teval(xl)|21,=inton||; make table value integer 1|18723
||icv|3,cnind|||; increase nesting level|18724
||mov|8,wa|3,cnind||; load new nest level|18725
||bgt|8,wa|18,=ccinm|6,cnc42|; fail if excessive nesting|18726
;
;      record the name and line number of the current input file
;
||mov|7,xl|3,r_ifa||; array of nested file names|18731
||add|8,wa|18,=vcvlb||; compute offset in words|18732
||wtb|8,wa|||; convert to bytes|18733
||add|7,xl|8,wa||; point to element|18734
||mov|9,(xl)|3,r_sfc||; record current file name|18735
||mov|7,xl|8,wa||; preserve nesting byte offset|18736
||mti|3,rdnln|||; fetch source line number as integer|18737
||jsr|6,icbld|||; convert to icblk|18738
||add|7,xl|3,r_ifl||; entry in nested line number array|18739
||mov|9,(xl)|7,xr||; record in array|18740
;
;      here to switch to include file named in r_ifn
;
||mov|8,wa|3,cswin||; max read length|18745
||mov|7,xl|3,r_ifn||; include file name|18746
||jsr|6,alocs|||; get buffer for complete file name|18747
||jsr|6,sysif|||; open include file|18748
||ppm|6,cnc43|||; could not open|18749
;
;      make note of the complete file name for error messages
;
||zer|8,wb|||; do not trim trailing blanks|18754
||jsr|6,trimr|||; adjust scblk for actual length|18755
||mov|3,r_sfc|7,xr||; save ptr to file name|18756
||mti|3,cmpsn|||; current statement as integer|18757
||jsr|6,icbld|||; build icblk for stmt number|18758
||mov|7,xl|3,r_sfn||; file name table|18759
||mnz|8,wb|||; lookup statement number by name|18760
||jsr|6,tfind|||; allocate new teblk|18761
||ppm||||; always possible to allocate block|18762
||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|18763
||zer|3,rdnln|||; restart line counter for new file|18767
||beq|3,stage|18,=stgic|6,cnc09|; if initial compile|18768
||bne|3,cnind|18,=num01|6,cnc09|; if not first execute-time nesting|18769
;
;      here for -include during execute-time compile
;
||mov|3,r_ici|3,r_cim||; remember code argument string|18773
||mov|3,cnspt|3,scnpt||; save position in string|18774
||mov|3,cnsil|3,scnil||; and length of string|18775
||brn|6,cnc09|||; all done, merge|18776
;
;      here for excessive include file nesting
;
|cnc42|erb|1,284|26,excessively nested include files|||18780
;
;      here if include file could not be opened
;
|cnc43|mov|3,dnamp|7,xr||; release allocated scblk|18784
||erb|1,285|26,include file cannot be opened|||18785
;
;
;      -line n filename
;
|cnc44|jsr|6,scane|||; scan integer after -line|18792
||bne|7,xl|18,=t_con|6,cnc06|; jump if no line number|18793
||bne|9,(xr)|22,=b_icl|6,cnc06|; jump if not integer|18794
||ldi|13,icval(xr)|||; fetch integer line number|18795
||ile|6,cnc06|||; error if negative or zero|18796
||beq|3,stage|18,=stgic|6,cnc45|; skip if initial compile|18797
||mfi|3,cmpln|||; set directly for other compiles|18798
||brn|6,cnc46|||; no need to set rdnln|18799
|cnc45|sbi|4,intv1|||; adjust number by one|18800
||mfi|3,rdnln|||; save line number|18801
|cnc46|mnz|3,scncc|||; set flag for scane|18803
||jsr|6,scane|||; scan quoted file name|18804
||zer|3,scncc|||; clear scane flag|18805
||beq|7,xl|18,=t_smc|6,cnc47|; done if no file name|18806
||bne|7,xl|18,=t_con|6,cnc06|; error if not constant|18807
||bne|9,(xr)|22,=b_scl|6,cnc06|; if not string constant|18808
||jsr|6,newfn|||; record new file name|18809
||brn|6,cnc09|||; merge|18810
;
;      here if file name not present
;
|cnc47|dcv|3,scnpt|||; set to rescan the terminator|18814
||brn|6,cnc09|||; merge|18815
||enp||||; end procedure cncrd|18820
||ejc|||||18821
;
;      dffnc -- define function
;
;      dffnc is called whenever a new function is assigned to
;      a variable. it deals with external function use counts.
;
;      (xr)		     pointer to vrblk
;      (xl)		     pointer to new function block
;      jsr  dffnc	     call to define function
;      (wa,wb)		     destroyed
;
|dffnc|prc|25,e|1,0||; entry point|18903
||bne|9,(xl)|22,=b_efc|6,dffn1|; skip if new function not external|18906
||icv|13,efuse(xl)|||; else increment its use count|18907
;
;      here after dealing with new function use count
;
|dffn1|mov|8,wa|7,xr||; save vrblk pointer|18911
||mov|7,xr|13,vrfnc(xr)||; load old function pointer|18912
||bne|9,(xr)|22,=b_efc|6,dffn2|; jump if old function not external|18913
||mov|8,wb|13,efuse(xr)||; else get use count|18914
||dcv|8,wb|||; decrement|18915
||mov|13,efuse(xr)|8,wb||; store decremented value|18916
||bnz|8,wb|6,dffn2||; jump if use count still non-zero|18917
||jsr|6,sysul|||; else call system unload function|18918
;
;      here after dealing with old function use count
;
|dffn2|mov|7,xr|8,wa||; restore vrblk pointer|18922
||mov|8,wa|7,xl||; copy function block ptr|18924
||blt|7,xr|20,=r_yyy|6,dffn3|; skip checks if opsyn op definition|18925
||bnz|13,vrlen(xr)|6,dffn3||; jump if not system variable|18926
;
;      for system variable, check for illegal redefinition
;
||mov|7,xl|13,vrsvp(xr)||; point to svblk|18930
||mov|8,wb|13,svbit(xl)||; load bit indicators|18931
||anb|8,wb|4,btfnc||; is it a system function|18932
||zrb|8,wb|6,dffn3||; redef ok if not|18933
||erb|1,248|26,attempted redefinition of system function|||18934
;
;      here if redefinition is permitted
;
|dffn3|mov|13,vrfnc(xr)|8,wa||; store new function pointer|18938
||mov|7,xl|8,wa||; restore function block pointer|18939
||exi||||; return to dffnc caller|18940
||enp||||; end procedure dffnc|18941
||ejc|||||18942
;
;      dtach -- detach i/o associated names
;
;      detaches trblks from i/o associated variables, removes
;      entry from iochn chain attached to filearg1 vrblk and may
;      remove vrblk access and store traps.
;      input, output, terminal are handled specially.
;
;      (xl)		     i/o assoc. vbl name base ptr
;      (wa)		     offset to name
;      jsr  dtach	     call for detach operation
;      (xl,xr,wa,wb,wc)	     destroyed
;
|dtach|prc|25,e|1,0||; entry point|18956
||mov|3,dtcnb|7,xl||; store name base (gbcol not called)|18957
||add|7,xl|8,wa||; point to name location|18958
||mov|3,dtcnm|7,xl||; store it|18959
;
;      loop to search for i/o trblk
;
|dtch1|mov|7,xr|7,xl||; copy name pointer|18963
;
;      continue after block deletion
;
|dtch2|mov|7,xl|9,(xl)||; point to next value|18967
||bne|9,(xl)|22,=b_trt|6,dtch6|; jump at chain end|18968
||mov|8,wa|13,trtyp(xl)||; get trap block type|18969
||beq|8,wa|18,=trtin|6,dtch3|; jump if input|18970
||beq|8,wa|18,=trtou|6,dtch3|; jump if output|18971
||add|7,xl|19,*trnxt||; point to next link|18972
||brn|6,dtch1|||; loop|18973
;
;      delete an old association
;
|dtch3|mov|9,(xr)|13,trval(xl)||; delete trblk|18977
||mov|8,wa|7,xl||; dump xl ...|18978
||mov|8,wb|7,xr||; ... and xr|18979
||mov|7,xl|13,trtrf(xl)||; point to trtrf trap block|18980
||bze|7,xl|6,dtch5||; jump if no iochn|18981
||bne|9,(xl)|22,=b_trt|6,dtch5|; jump if input, output, terminal|18982
;
;      loop to search iochn chain for name ptr
;
|dtch4|mov|7,xr|7,xl||; remember link ptr|18986
||mov|7,xl|13,trtrf(xl)||; point to next link|18987
||bze|7,xl|6,dtch5||; jump if end of chain|18988
||mov|8,wc|13,ionmb(xl)||; get name base|18989
||add|8,wc|13,ionmo(xl)||; add offset|18990
||bne|8,wc|3,dtcnm|6,dtch4|; loop if no match|18991
||mov|13,trtrf(xr)|13,trtrf(xl)||; remove name from chain|18992
||ejc|||||18993
;
;      dtach (continued)
;
;      prepare to resume i/o trblk scan
;
|dtch5|mov|7,xl|8,wa||; recover xl ...|18999
||mov|7,xr|8,wb||; ... and xr|19000
||add|7,xl|19,*trval||; point to value field|19001
||brn|6,dtch2|||; continue|19002
;
;      exit point
;
|dtch6|mov|7,xr|3,dtcnb||; possible vrblk ptr|19006
||jsr|6,setvr|||; reset vrblk if necessary|19007
||exi||||; return|19008
||enp||||; end procedure dtach|19009
||ejc|||||19010
;
;      dtype -- get datatype name
;
;      (xr)		     object whose datatype is required
;      jsr  dtype	     call to get datatype
;      (xr)		     result datatype
;
|dtype|prc|25,e|1,0||; entry point|19018
||beq|9,(xr)|22,=b_pdt|6,dtyp1|; jump if prog.defined|19019
||mov|7,xr|9,(xr)||; load type word|19020
||lei|7,xr|||; get entry point id (block code)|19021
||wtb|7,xr|||; convert to byte offset|19022
||mov|7,xr|14,scnmt(xr)||; load table entry|19023
||exi||||; exit to dtype caller|19024
;
;      here if program defined
;
|dtyp1|mov|7,xr|13,pddfp(xr)||; point to dfblk|19028
||mov|7,xr|13,dfnam(xr)||; get datatype name from dfblk|19029
||exi||||; return to dtype caller|19030
||enp||||; end procedure dtype|19031
||ejc|||||19032
;
;      dumpr -- print dump of storage
;
;      (xr)		     dump argument (see below)
;      jsr  dumpr	     call to print dump
;      (xr,xl)		     destroyed
;      (wa,wb,wc,ra)	     destroyed
;
;      the dump argument has the following significance
;
;      dmarg = 0	     no dump printed
;      dmarg = 1	     partial dump (nat vars, keywords)
;      dmarg = 2	     full dump (arrays, tables, etc.)
;      dmarg = 3	     full dump + null variables
;      dmarg ge 4	     core dump
;
;      since dumpr scrambles store, it is not permissible to
;      collect in mid-dump. hence a collect is done initially
;      and then if store runs out an error message is produced.
;
|dumpr|prc|25,e|1,0||; entry point|19053
||bze|7,xr|6,dmp28||; skip dump if argument is zero|19054
||bgt|7,xr|18,=num03|6,dmp29|; jump if core dump required|19055
||zer|7,xl|||; clear xl|19056
||zer|8,wb|||; zero move offset|19057
||mov|3,dmarg|7,xr||; save dump argument|19058
||zer|3,dnams|||; collect sediment too|19060
||jsr|6,gbcol|||; collect garbage|19062
||jsr|6,prtpg|||; eject printer|19063
||mov|7,xr|21,=dmhdv||; point to heading for variables|19064
||jsr|6,prtst|||; print it|19065
||jsr|6,prtnl|||; terminate print line|19066
||jsr|6,prtnl|||; and print a blank line|19067
;
;      first all natural variable blocks (vrblk) whose values
;      are non-null are linked in lexical order using dmvch as
;      the chain head and chaining through the vrget fields.
;      note that this scrambles store if the process is
;      interrupted before completion e.g. by exceeding time  or
;      print limits. since the subsequent core dumps and
;      failures if execution is resumed are very confusing, the
;      execution time error routine checks for this event and
;      attempts an unscramble. similar precautions should be
;      observed if translate time dumping is implemented.
;
||zer|3,dmvch|||; set null chain to start|19080
||mov|8,wa|3,hshtb||; point to hash table|19081
;
;      loop through headers in hash table
;
|dmp00|mov|7,xr|8,wa||; copy hash bucket pointer|19085
||ica|8,wa|||; bump pointer|19086
||sub|7,xr|19,*vrnxt||; set offset to merge|19087
;
;      loop through vrblks on one chain
;
|dmp01|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on chain|19091
||bze|7,xr|6,dmp09||; jump if end of this hash chain|19092
||mov|7,xl|7,xr||; else copy vrblk pointer|19093
||ejc|||||19094
;
;      dumpr (continued)
;
;      loop to find value and skip if null
;
|dmp02|mov|7,xl|13,vrval(xl)||; load value|19100
||beq|3,dmarg|18,=num03|6,dmp2a|; skip null value check if dump(3)|19101
||beq|7,xl|21,=nulls|6,dmp01|; loop for next vrblk if null value|19102
|dmp2a|beq|9,(xl)|22,=b_trt|6,dmp02|; loop back if value is trapped|19103
;
;      non-null value, prepare to search chain
;
||mov|8,wc|7,xr||; save vrblk pointer|19107
||add|7,xr|19,*vrsof||; adjust ptr to be like scblk ptr|19108
||bnz|13,sclen(xr)|6,dmp03||; jump if non-system variable|19109
||mov|7,xr|13,vrsvo(xr)||; else load ptr to name in svblk|19110
;
;      here with name pointer for new block in xr
;
|dmp03|mov|8,wb|7,xr||; save pointer to chars|19114
||mov|3,dmpsv|8,wa||; save hash bucket pointer|19115
||mov|8,wa|20,=dmvch||; point to chain head|19116
;
;      loop to search chain for correct insertion point
;
|dmp04|mov|3,dmpch|8,wa||; save chain pointer|19120
||mov|7,xl|8,wa||; copy it|19121
||mov|7,xr|9,(xl)||; load pointer to next entry|19122
||bze|7,xr|6,dmp08||; jump if end of chain to insert|19123
||add|7,xr|19,*vrsof||; else get name ptr for chained vrblk|19124
||bnz|13,sclen(xr)|6,dmp05||; jump if not system variable|19125
||mov|7,xr|13,vrsvo(xr)||; else point to name in svblk|19126
;
;      here prepare to compare the names
;
;      (wa)		     scratch
;      (wb)		     pointer to string of entering vrblk
;      (wc)		     pointer to entering vrblk
;      (xr)		     pointer to string of current block
;      (xl)		     scratch
;
|dmp05|mov|7,xl|8,wb||; point to entering vrblk string|19136
||mov|8,wa|13,sclen(xl)||; load its length|19137
||plc|7,xl|||; point to chars of entering string|19138
||bhi|8,wa|13,sclen(xr)|6,dmp06|; jump if entering length high|19161
||plc|7,xr|||; else point to chars of old string|19162
||cmc|6,dmp08|6,dmp07||; compare, insert if new is llt old|19163
||brn|6,dmp08|||; or if leq (we had shorter length)|19164
;
;      here when new length is longer than old length
;
|dmp06|mov|8,wa|13,sclen(xr)||; load shorter length|19168
||plc|7,xr|||; point to chars of old string|19169
||cmc|6,dmp08|6,dmp07||; compare, insert if new one low|19170
||ejc|||||19171
;
;      dumpr (continued)
;
;      here we move out on the chain
;
|dmp07|mov|7,xl|3,dmpch||; copy chain pointer|19177
||mov|8,wa|9,(xl)||; move to next entry on chain|19179
||brn|6,dmp04|||; loop back|19180
;
;      here after locating the proper insertion point
;
|dmp08|mov|7,xl|3,dmpch||; copy chain pointer|19184
||mov|8,wa|3,dmpsv||; restore hash bucket pointer|19185
||mov|7,xr|8,wc||; restore vrblk pointer|19186
||mov|13,vrget(xr)|9,(xl)||; link vrblk to rest of chain|19187
||mov|9,(xl)|7,xr||; link vrblk into current chain loc|19188
||brn|6,dmp01|||; loop back for next vrblk|19189
;
;      here after processing all vrblks on one chain
;
|dmp09|bne|8,wa|3,hshte|6,dmp00|; loop back if more buckets to go|19193
;
;      loop to generate dump of natural variable values
;
|dmp10|mov|7,xr|3,dmvch||; load pointer to next entry on chain|19197
||bze|7,xr|6,dmp11||; jump if end of chain|19198
||mov|3,dmvch|9,(xr)||; else update chain ptr to next entry|19199
||jsr|6,setvr|||; restore vrget field|19200
||mov|7,xl|7,xr||; copy vrblk pointer (name base)|19201
||mov|8,wa|19,*vrval||; set offset for vrblk name|19202
||jsr|6,prtnv|||; print name = value|19203
||brn|6,dmp10|||; loop back till all printed|19204
;
;      prepare to print keywords
;
|dmp11|jsr|6,prtnl|||; print blank line|19208
||jsr|6,prtnl|||; and another|19209
||mov|7,xr|21,=dmhdk||; point to keyword heading|19210
||jsr|6,prtst|||; print heading|19211
||jsr|6,prtnl|||; end line|19212
||jsr|6,prtnl|||; print one blank line|19213
||mov|7,xl|21,=vdmkw||; point to list of keyword svblk ptrs|19214
||ejc|||||19215
;
;      dumpr (continued)
;
;      loop to dump keyword values
;
|dmp12|mov|7,xr|10,(xl)+||; load next svblk ptr from table|19221
||bze|7,xr|6,dmp13||; jump if end of list|19222
||beq|7,xr|18,=num01|6,dmp12|; &compare ignored if not implemented|19224
||mov|8,wa|18,=ch_am||; load ampersand|19226
||jsr|6,prtch|||; print ampersand|19227
||jsr|6,prtst|||; print keyword name|19228
||mov|8,wa|13,svlen(xr)||; load name length from svblk|19229
||ctb|8,wa|2,svchs||; get length of name|19230
||add|7,xr|8,wa||; point to svknm field|19231
||mov|3,dmpkn|9,(xr)||; store in dummy kvblk|19232
||mov|7,xr|21,=tmbeb||; point to blank-equal-blank|19233
||jsr|6,prtst|||; print it|19234
||mov|3,dmpsv|7,xl||; save table pointer|19235
||mov|7,xl|20,=dmpkb||; point to dummy kvblk|19236
||mov|9,(xl)|22,=b_kvt||; build type word|19237
||mov|13,kvvar(xl)|21,=trbkv||; build ptr to dummy trace block|19238
||mov|8,wa|19,*kvvar||; set zero offset|19239
||jsr|6,acess|||; get keyword value|19240
||ppm||||; failure is impossible|19241
||jsr|6,prtvl|||; print keyword value|19242
||jsr|6,prtnl|||; terminate print line|19243
||mov|7,xl|3,dmpsv||; restore table pointer|19244
||brn|6,dmp12|||; loop back till all printed|19245
;
;      here after completing partial dump
;
|dmp13|beq|3,dmarg|18,=num01|6,dmp27|; exit if partial dump complete|19249
||mov|7,xr|3,dnamb||; else point to first dynamic block|19250
;
;      loop through blocks in dynamic storage
;
|dmp14|beq|7,xr|3,dnamp|6,dmp27|; jump if end of used region|19254
||mov|8,wa|9,(xr)||; else load first word of block|19255
||beq|8,wa|22,=b_vct|6,dmp16|; jump if vector|19256
||beq|8,wa|22,=b_art|6,dmp17|; jump if array|19257
||beq|8,wa|22,=b_pdt|6,dmp18|; jump if program defined|19258
||beq|8,wa|22,=b_tbt|6,dmp19|; jump if table|19259
;
;      merge here to move to next block
;
|dmp15|jsr|6,blkln|||; get length of block|19267
||add|7,xr|8,wa||; point past this block|19268
||brn|6,dmp14|||; loop back for next block|19269
||ejc|||||19270
;
;      dumpr (continued)
;
;      here for vector
;
|dmp16|mov|8,wb|19,*vcvls||; set offset to first value|19276
||brn|6,dmp19|||; jump to merge|19277
;
;      here for array
;
|dmp17|mov|8,wb|13,arofs(xr)||; set offset to arpro field|19281
||ica|8,wb|||; bump to get offset to values|19282
||brn|6,dmp19|||; jump to merge|19283
;
;      here for program defined
;
|dmp18|mov|8,wb|19,*pdfld||; point to values, merge|19287
;
;      here for table (others merge)
;
|dmp19|bze|13,idval(xr)|6,dmp15||; ignore block if zero id value|19291
||jsr|6,blkln|||; else get block length|19292
||mov|7,xl|7,xr||; copy block pointer|19293
||mov|3,dmpsv|8,wa||; save length|19294
||mov|8,wa|8,wb||; copy offset to first value|19295
||jsr|6,prtnl|||; print blank line|19296
||mov|3,dmpsa|8,wa||; preserve offset|19297
||jsr|6,prtvl|||; print block value (for title)|19298
||mov|8,wa|3,dmpsa||; recover offset|19299
||jsr|6,prtnl|||; end print line|19300
||beq|9,(xr)|22,=b_tbt|6,dmp22|; jump if table|19301
||dca|8,wa|||; point before first word|19302
;
;      loop to print contents of array, vector, or program def
;
|dmp20|mov|7,xr|7,xl||; copy block pointer|19306
||ica|8,wa|||; bump offset|19307
||add|7,xr|8,wa||; point to next value|19308
||beq|8,wa|3,dmpsv|6,dmp14|; exit if end (xr past block)|19309
||sub|7,xr|19,*vrval||; subtract offset to merge into loop|19310
;
;      loop to find value and ignore nulls
;
|dmp21|mov|7,xr|13,vrval(xr)||; load next value|19314
||beq|3,dmarg|18,=num03|6,dmp2b|; skip null value check if dump(3)|19315
||beq|7,xr|21,=nulls|6,dmp20|; loop back if null value|19316
|dmp2b|beq|9,(xr)|22,=b_trt|6,dmp21|; loop back if trapped|19317
||jsr|6,prtnv|||; else print name = value|19318
||brn|6,dmp20|||; loop back for next field|19319
||ejc|||||19320
;
;      dumpr (continued)
;
;      here to dump a table
;
|dmp22|mov|8,wc|19,*tbbuk||; set offset to first bucket|19326
||mov|8,wa|19,*teval||; set name offset for all teblks|19327
;
;      loop through table buckets
;
|dmp23|mov|11,-(xs)|7,xl||; save tbblk pointer|19331
||add|7,xl|8,wc||; point to next bucket header|19332
||ica|8,wc|||; bump bucket offset|19333
||sub|7,xl|19,*tenxt||; subtract offset to merge into loop|19334
;
;      loop to process teblks on one chain
;
|dmp24|mov|7,xl|13,tenxt(xl)||; point to next teblk|19338
||beq|7,xl|9,(xs)|6,dmp26|; jump if end of chain|19339
||mov|7,xr|7,xl||; else copy teblk pointer|19340
;
;      loop to find value and ignore if null
;
|dmp25|mov|7,xr|13,teval(xr)||; load next value|19344
||beq|7,xr|21,=nulls|6,dmp24|; ignore if null value|19345
||beq|9,(xr)|22,=b_trt|6,dmp25|; loop back if trapped|19346
||mov|3,dmpsv|8,wc||; else save offset pointer|19347
||jsr|6,prtnv|||; print name = value|19348
||mov|8,wc|3,dmpsv||; reload offset|19349
||brn|6,dmp24|||; loop back for next teblk|19350
;
;      here to move to next hash chain
;
|dmp26|mov|7,xl|10,(xs)+||; restore tbblk pointer|19354
||bne|8,wc|13,tblen(xl)|6,dmp23|; loop back if more buckets to go|19355
||mov|7,xr|7,xl||; else copy table pointer|19356
||add|7,xr|8,wc||; point to following block|19357
||brn|6,dmp14|||; loop back to process next block|19358
;
;      here after completing dump
;
|dmp27|jsr|6,prtpg|||; eject printer|19362
;
;      merge here if no dump given (dmarg=0)
;
|dmp28|exi||||; return to dump caller|19366
;
;      call system core dump routine
;
|dmp29|jsr|6,sysdm|||; call it|19370
||brn|6,dmp28|||; return|19371
||enp||||; end procedure dumpr|19407
||ejc|||||19408
;
;      ermsg -- print error code and error message
;
;      kvert		     error code
;      jsr  ermsg	     call to print message
;      (xr,xl,wa,wb,wc,ia)   destroyed
;
|ermsg|prc|25,e|1,0||; entry point|19416
||mov|8,wa|3,kvert||; load error code|19417
||mov|7,xr|21,=ermms||; point to error message /error/|19418
||jsr|6,prtst|||; print it|19419
||jsr|6,ertex|||; get error message text|19420
||add|8,wa|18,=thsnd||; bump error code for print|19421
||mti|8,wa|||; fail code in int acc|19422
||mov|8,wb|3,profs||; save current buffer position|19423
||jsr|6,prtin|||; print code (now have error1xxx)|19424
||mov|7,xl|3,prbuf||; point to print buffer|19425
||psc|7,xl|8,wb||; point to the 1|19426
||mov|8,wa|18,=ch_bl||; load a blank|19427
||sch|8,wa|9,(xl)||; store blank over 1 (error xxx)|19428
||csc|7,xl|||; complete store characters|19429
||zer|7,xl|||; clear garbage pointer in xl|19430
||mov|8,wa|7,xr||; keep error text|19431
||mov|7,xr|21,=ermns||; point to / -- /|19432
||jsr|6,prtst|||; print it|19433
||mov|7,xr|8,wa||; get error text again|19434
||jsr|6,prtst|||; print error message text|19435
||jsr|6,prtis|||; print line|19436
||jsr|6,prtis|||; print blank line|19437
||exi||||; return to ermsg caller|19438
||enp||||; end procedure ermsg|19439
||ejc|||||19440
;
;      ertex -- get error message text
;
;      (wa)		     error code
;      jsr  ertex	     call to get error text
;      (xr)		     ptr to error text in dynamic
;      (r_etx)		     copy of ptr to error text
;      (xl,wc,ia)	     destroyed
;
|ertex|prc|25,e|1,0||; entry point|19450
||mov|3,ertwa|8,wa||; save wa|19451
||mov|3,ertwb|8,wb||; save wb|19452
||jsr|6,sysem|||; get failure message text|19453
||mov|7,xl|7,xr||; copy pointer to it|19454
||mov|8,wa|13,sclen(xr)||; get length of string|19455
||bze|8,wa|6,ert02||; jump if null|19456
||zer|8,wb|||; offset of zero|19457
||jsr|6,sbstr|||; copy into dynamic store|19458
||mov|3,r_etx|7,xr||; store for relocation|19459
;
;      return
;
|ert01|mov|8,wb|3,ertwb||; restore wb|19463
||mov|8,wa|3,ertwa||; restore wa|19464
||exi||||; return to caller|19465
;
;      return errtext contents instead of null
;
|ert02|mov|7,xr|3,r_etx||; get errtext|19469
||brn|6,ert01|||; return|19470
||enp|||||19471
||ejc|||||19472
;
;      evali -- evaluate integer argument
;
;      evali is used by pattern primitives len,tab,rtab,pos,rpos
;      when their argument is an expression value.
;
;      (xr)		     node pointer
;      (wb)		     cursor
;      jsr  evali	     call to evaluate integer
;      ppm  loc		     transfer loc for non-integer arg
;      ppm  loc		     transfer loc for out of range arg
;      ppm  loc		     transfer loc for evaluation failure
;      ppm  loc		     transfer loc for successful eval
;      (the normal return is never taken)
;      (xr)		     ptr to node with integer argument
;      (wc,xl,ra)	     destroyed
;
;      on return, the node pointed to has the integer argument
;      in parm1 and the proper successor pointer in pthen.
;      this allows merging with the normal (integer arg) case.
;
|evali|prc|25,r|1,4||; entry point (recursive)|19494
||jsr|6,evalp|||; evaluate expression|19495
||ppm|6,evli1|||; jump on failure|19496
||mov|11,-(xs)|7,xl||; stack result for gtsmi|19497
||mov|7,xl|13,pthen(xr)||; load successor pointer|19498
||mov|3,evlio|7,xr||; save original node pointer|19499
||mov|3,evlif|8,wc||; zero if simple argument|19500
||jsr|6,gtsmi|||; convert arg to small integer|19501
||ppm|6,evli2|||; jump if not integer|19502
||ppm|6,evli3|||; jump if out of range|19503
||mov|3,evliv|7,xr||; store result in special dummy node|19504
||mov|7,xr|20,=evlin||; point to dummy node with result|19505
||mov|9,(xr)|22,=p_len||; dummy pattern block pcode|19506
||mov|13,pthen(xr)|7,xl||; store successor pointer|19507
||exi|1,4|||; take successful exit|19508
;
;      here if evaluation fails
;
|evli1|exi|1,3|||; take failure return|19512
;
;      here if argument is not integer
;
|evli2|exi|1,1|||; take non-integer error exit|19516
;
;      here if argument is out of range
;
|evli3|exi|1,2|||; take out-of-range error exit|19520
||enp||||; end procedure evali|19521
||ejc|||||19522
;
;      evalp -- evaluate expression during pattern match
;
;      evalp is used to evaluate an expression (by value) during
;      a pattern match. the effect is like evalx, but pattern
;      variables are stacked and restored if necessary.
;
;      evalp also differs from evalx in that if the result is
;      an expression it is reevaluated. this occurs repeatedly.
;
;      to support optimization of pos and rpos, evalp uses wc
;      to signal the caller for the case of a simple vrblk
;      that is not an expression and is not trapped.  because
;      this case cannot have any side effects, optimization is
;      possible.
;
;      (xr)		     node pointer
;      (wb)		     pattern match cursor
;      jsr  evalp	     call to evaluate expression
;      ppm  loc		     transfer loc if evaluation fails
;      (xl)		     result
;      (wa)		     first word of result block
;      (wc)		     zero if simple vrblk, else non-zero
;      (xr,wb)		     destroyed (failure case only)
;      (ra)		     destroyed
;
;      the expression pointer is stored in parm1 of the node
;
;      control returns to failp on failure of evaluation
;
|evalp|prc|25,r|1,1||; entry point (recursive)|19553
||mov|7,xl|13,parm1(xr)||; load expression pointer|19554
||beq|9,(xl)|22,=b_exl|6,evlp1|; jump if exblk case|19555
;
;      here for case of seblk
;
;      we can give a fast return if the value of the vrblk is
;      not an expression and is not trapped.
;
||mov|7,xl|13,sevar(xl)||; load vrblk pointer|19562
||mov|7,xl|13,vrval(xl)||; load value of vrblk|19563
||mov|8,wa|9,(xl)||; load first word of value|19564
||bhi|8,wa|22,=b_t__|6,evlp3|; jump if not seblk, trblk or exblk|19565
;
;      here for exblk or seblk with expr value or trapped value
;
|evlp1|chk||||; check for stack space|19569
||mov|11,-(xs)|7,xr||; stack node pointer|19570
||mov|11,-(xs)|8,wb||; stack cursor|19571
||mov|11,-(xs)|3,r_pms||; stack subject string pointer|19572
||mov|11,-(xs)|3,pmssl||; stack subject string length|19573
||mov|11,-(xs)|3,pmdfl||; stack dot flag|19574
||mov|11,-(xs)|3,pmhbs||; stack history stack base pointer|19575
||mov|7,xr|13,parm1(xr)||; load expression pointer|19576
||ejc|||||19577
;
;      evalp (continued)
;
;      loop back here to reevaluate expression result
;
|evlp2|zer|8,wb|||; set flag for by value|19583
||jsr|6,evalx|||; evaluate expression|19584
||ppm|6,evlp4|||; jump on failure|19585
||mov|8,wa|9,(xr)||; else load first word of value|19586
||blo|8,wa|22,=b_e__|6,evlp2|; loop back to reevaluate expression|19587
;
;      here to restore pattern values after successful eval
;
||mov|7,xl|7,xr||; copy result pointer|19591
||mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|19592
||mov|3,pmdfl|10,(xs)+||; restore dot flag|19593
||mov|3,pmssl|10,(xs)+||; restore subject string length|19594
||mov|3,r_pms|10,(xs)+||; restore subject string pointer|19595
||mov|8,wb|10,(xs)+||; restore cursor|19596
||mov|7,xr|10,(xs)+||; restore node pointer|19597
||mov|8,wc|7,xr||; non-zero for simple vrblk|19598
||exi||||; return to evalp caller|19599
;
;      here to return after simple vrblk case
;
|evlp3|zer|8,wc|||; simple vrblk, no side effects|19603
||exi||||; return to evalp caller|19604
;
;      here for failure during evaluation
;
|evlp4|mov|3,pmhbs|10,(xs)+||; restore history stack base pointer|19608
||mov|3,pmdfl|10,(xs)+||; restore dot flag|19609
||mov|3,pmssl|10,(xs)+||; restore subject string length|19610
||mov|3,r_pms|10,(xs)+||; restore subject string pointer|19611
||add|7,xs|19,*num02||; remove node ptr, cursor|19612
||exi|1,1|||; take failure exit|19613
||enp||||; end procedure evalp|19614
||ejc|||||19615
;
;      evals -- evaluate string argument
;
;      evals is used by span, any, notany, break, breakx when
;      they are passed an expression argument.
;
;      (xr)		     node pointer
;      (wb)		     cursor
;      jsr  evals	     call to evaluate string
;      ppm  loc		     transfer loc for non-string arg
;      ppm  loc		     transfer loc for evaluation failure
;      ppm  loc		     transfer loc for successful eval
;      (the normal return is never taken)
;      (xr)		     ptr to node with parms set
;      (xl,wc,ra)	     destroyed
;
;      on return, the node pointed to has a character table
;      pointer in parm1 and a bit mask in parm2. the proper
;      successor is stored in pthen of this node. thus it is
;      ok for merging with the normal (multi-char string) case.
;
|evals|prc|25,r|1,3||; entry point (recursive)|19637
||jsr|6,evalp|||; evaluate expression|19638
||ppm|6,evls1|||; jump if evaluation fails|19639
||mov|11,-(xs)|13,pthen(xr)||; save successor pointer|19640
||mov|11,-(xs)|8,wb||; save cursor|19641
||mov|11,-(xs)|7,xl||; stack result ptr for patst|19642
||zer|8,wb|||; dummy pcode for one char string|19643
||zer|8,wc|||; dummy pcode for expression arg|19644
||mov|7,xl|22,=p_brk||; appropriate pcode for our use|19645
||jsr|6,patst|||; call routine to build node|19646
||ppm|6,evls2|||; jump if not string|19647
||mov|8,wb|10,(xs)+||; restore cursor|19648
||mov|13,pthen(xr)|10,(xs)+||; store successor pointer|19649
||exi|1,3|||; take success return|19650
;
;      here if evaluation fails
;
|evls1|exi|1,2|||; take failure return|19654
;
;      here if argument is not string
;
|evls2|add|7,xs|19,*num02||; pop successor and cursor|19658
||exi|1,1|||; take non-string error exit|19659
||enp||||; end procedure evals|19660
||ejc|||||19661
;
;      evalx -- evaluate expression
;
;      evalx is called to evaluate an expression
;
;      (xr)		     pointer to exblk or seblk
;      (wb)		     0 if by value, 1 if by name
;      jsr  evalx	     call to evaluate expression
;      ppm  loc		     transfer loc if evaluation fails
;      (xr)		     result if called by value
;      (xl,wa)		     result name base,offset if by name
;      (xr)		     destroyed (name case only)
;      (xl,wa)		     destroyed (value case only)
;      (wb,wc,ra)	     destroyed
;
|evalx|prc|25,r|1,1||; entry point, recursive|19677
||beq|9,(xr)|22,=b_exl|6,evlx2|; jump if exblk case|19678
;
;      here for seblk
;
||mov|7,xl|13,sevar(xr)||; load vrblk pointer (name base)|19682
||mov|8,wa|19,*vrval||; set name offset|19683
||bnz|8,wb|6,evlx1||; jump if called by name|19684
||jsr|6,acess|||; call routine to access value|19685
||ppm|6,evlx9|||; jump if failure on access|19686
;
;      merge here to exit for seblk case
;
|evlx1|exi||||; return to evalx caller|19690
||ejc|||||19691
;
;      evalx (continued)
;
;      here for full expression (exblk) case
;
;      if an error occurs in the expression code at execution
;      time, control is passed via error section to exfal
;      without returning to this routine.
;      the following entries are made on the stack before
;      giving control to the expression code
;
;			     evalx return point
;			     saved value of r_cod
;			     code pointer (-r_cod)
;			     saved value of flptr
;			     0 if by value, 1 if by name
;      flptr --------------- *exflc, fail offset in exblk
;
|evlx2|scp|8,wc|||; get code pointer|19710
||mov|8,wa|3,r_cod||; load code block pointer|19711
||sub|8,wc|8,wa||; get code pointer as offset|19712
||mov|11,-(xs)|8,wa||; stack old code block pointer|19713
||mov|11,-(xs)|8,wc||; stack relative code offset|19714
||mov|11,-(xs)|3,flptr||; stack old failure pointer|19715
||mov|11,-(xs)|8,wb||; stack name/value indicator|19716
||mov|11,-(xs)|19,*exflc||; stack new fail offset|19717
||mov|3,gtcef|3,flptr||; keep in case of error|19718
||mov|3,r_gtc|3,r_cod||; keep code block pointer similarly|19719
||mov|3,flptr|7,xs||; set new failure pointer|19720
||mov|3,r_cod|7,xr||; set new code block pointer|19721
||mov|13,exstm(xr)|3,kvstn||; remember stmnt number|19722
||add|7,xr|19,*excod||; point to first code word|19723
||lcp|7,xr|||; set code pointer|19724
||bne|3,stage|18,=stgxt|6,evlx0|; jump if not execution time|19725
||mov|3,stage|18,=stgee||; evaluating expression|19726
;
;      here to execute first code word of expression
;
|evlx0|zer|7,xl|||; clear garbage xl|19730
||lcw|7,xr|||; load first code word|19731
||bri|9,(xr)|||; execute it|19732
||ejc|||||19733
;
;      evalx (continued)
;
;      come here if successful return by value (see o_rvl)
;
|evlx3|mov|7,xr|10,(xs)+||; load value|19739
||bze|13,num01(xs)|6,evlx5||; jump if called by value|19740
||erb|1,249|26,expression evaluated by name returned value|||19741
;
;      here for expression returning by name (see o_rnm)
;
|evlx4|mov|8,wa|10,(xs)+||; load name offset|19745
||mov|7,xl|10,(xs)+||; load name base|19746
||bnz|13,num01(xs)|6,evlx5||; jump if called by name|19747
||jsr|6,acess|||; else access value first|19748
||ppm|6,evlx6|||; jump if failure during access|19749
;
;      here after loading correct result into xr or xl,wa
;
|evlx5|zer|8,wb|||; note successful|19753
||brn|6,evlx7|||; merge|19754
;
;      here for failure in expression evaluation (see o_fex)
;
|evlx6|mnz|8,wb|||; note unsuccessful|19758
;
;      restore environment
;
|evlx7|bne|3,stage|18,=stgee|6,evlx8|; skip if was not previously xt|19762
||mov|3,stage|18,=stgxt||; execute time|19763
;
;      merge with stage set up
;
|evlx8|add|7,xs|19,*num02||; pop name/value indicator, *exfal|19767
||mov|3,flptr|10,(xs)+||; restore old failure pointer|19768
||mov|8,wc|10,(xs)+||; load code offset|19769
||add|8,wc|9,(xs)||; make code pointer absolute|19770
||mov|3,r_cod|10,(xs)+||; restore old code block pointer|19771
||lcp|8,wc|||; restore old code pointer|19772
||bze|8,wb|6,evlx1||; jump for successful return|19773
;
;      merge here for failure in seblk case
;
|evlx9|exi|1,1|||; take failure exit|19777
||enp||||; end of procedure evalx|19778
||ejc|||||19779
;
;      exbld -- build exblk
;
;      exbld is used to build an expression block from the
;      code compiled most recently in the current ccblk.
;
;      (xl)		     offset in ccblk to start of code
;      (wb)		     integer in range 0 le n le mxlen
;      jsr  exbld	     call to build exblk
;      (xr)		     ptr to constructed exblk
;      (wa,wb,xl)	     destroyed
;
|exbld|prc|25,e|1,0||; entry point|19792
||mov|8,wa|7,xl||; copy offset to start of code|19793
||sub|8,wa|19,*excod||; calc reduction in offset in exblk|19794
||mov|11,-(xs)|8,wa||; stack for later|19795
||mov|8,wa|3,cwcof||; load final offset|19796
||sub|8,wa|7,xl||; compute length of code|19797
||add|8,wa|19,*exsi_||; add space for standard fields|19798
||jsr|6,alloc|||; allocate space for exblk|19799
||mov|11,-(xs)|7,xr||; save pointer to exblk|19800
||mov|13,extyp(xr)|22,=b_exl||; store type word|19801
||zer|13,exstm(xr)|||; zeroise stmnt number field|19802
||mov|13,exsln(xr)|3,cmpln||; set line number field|19804
||mov|13,exlen(xr)|8,wa||; store length|19806
||mov|13,exflc(xr)|21,=ofex_||; store failure word|19807
||add|7,xr|19,*exsi_||; set xr for mvw|19808
||mov|3,cwcof|7,xl||; reset offset to start of code|19809
||add|7,xl|3,r_ccb||; point to start of code|19810
||sub|8,wa|19,*exsi_||; length of code to move|19811
||mov|11,-(xs)|8,wa||; stack length of code|19812
||mvw||||; move code to exblk|19813
||mov|8,wa|10,(xs)+||; get length of code|19814
||btw|8,wa|||; convert byte count to word count|19815
||lct|8,wa|8,wa||; prepare counter for loop|19816
||mov|7,xl|9,(xs)||; copy exblk ptr, dont unstack|19817
||add|7,xl|19,*excod||; point to code itself|19818
||mov|8,wb|13,num01(xs)||; get reduction in offset|19819
;
;      this loop searches for negation and selection code so
;      that the offsets computed whilst code was in code block
;      can be transformed to reduced values applicable in an
;      exblk.
;
|exbl1|mov|7,xr|10,(xl)+||; get next code word|19826
||beq|7,xr|21,=osla_|6,exbl3|; jump if selection found|19827
||beq|7,xr|21,=onta_|6,exbl3|; jump if negation found|19828
||bct|8,wa|6,exbl1||; loop to end of code|19829
;
;      no selection found or merge to exit on termination
;
|exbl2|mov|7,xr|10,(xs)+||; pop exblk ptr into xr|19833
||mov|7,xl|10,(xs)+||; pop reduction constant|19834
||exi||||; return to caller|19835
||ejc|||||19836
;
;      exbld (continued)
;
;      selection or negation found
;      reduce the offsets as needed. offsets occur in words
;      following code words -
;	    =onta_, =osla_, =oslb_, =oslc_
;
|exbl3|sub|10,(xl)+|8,wb||; adjust offset|19845
||bct|8,wa|6,exbl4||; decrement count|19846
;
|exbl4|bct|8,wa|6,exbl5||; decrement count|19848
;
;      continue search for more offsets
;
|exbl5|mov|7,xr|10,(xl)+||; get next code word|19852
||beq|7,xr|21,=osla_|6,exbl3|; jump if offset found|19853
||beq|7,xr|21,=oslb_|6,exbl3|; jump if offset found|19854
||beq|7,xr|21,=oslc_|6,exbl3|; jump if offset found|19855
||beq|7,xr|21,=onta_|6,exbl3|; jump if offset found|19856
||bct|8,wa|6,exbl5||; loop|19857
||brn|6,exbl2|||; merge to return|19858
||enp||||; end procedure exbld|19859
||ejc|||||19860
;
;      expan -- analyze expression
;
;      the expression analyzer (expan) procedure is used to scan
;      an expression and convert it into a tree representation.
;      see the description of cmblk in the structures section
;      for detailed format of tree blocks.
;
;      the analyzer uses a simple precedence scheme in which
;      operands and operators are placed on a single stack
;      and condensations are made when low precedence operators
;      are stacked after a higher precedence operator. a global
;      variable (in wb) keeps track of the level as follows.
;
;      0    scanning outer level of statement or expression
;      1    scanning outer level of normal goto
;      2    scanning outer level of direct goto
;      3    scanning inside array brackets
;      4    scanning inside grouping parentheses
;      5    scanning inside function parentheses
;
;      this variable is saved on the stack on encountering a
;      grouping and restored at the end of the grouping.
;
;      another global variable (in wc) counts the number of
;      items at one grouping level and is incremented for each
;      comma encountered. it is stacked with the level indicator
;
;      the scan is controlled by a three state finite machine.
;      a global variable stored in wa is the current state.
;
;      wa=0		     nothing scanned at this level
;      wa=1		     operand expected
;      wa=2		     operator expected
;
;      (wb)		     call type (see below)
;      jsr  expan	     call to analyze expression
;      (xr)		     pointer to resulting tree
;      (xl,wa,wb,wc,ra)	     destroyed
;
;      the entry value of wb indicates the call type as follows.
;
;      0    scanning either the main body of a statement or the
;	    text of an expression (from eval call). valid
;	    terminators are colon, semicolon. the rescan flag is
;	    set to return the terminator on the next scane call.
;
;      1    scanning a normal goto. the only valid
;	    terminator is a right paren.
;
;      2    scanning a direct goto. the only valid
;	    terminator is a right bracket.
||ejc|||||19913
;
;      expan (continued)
;
;      entry point
;
|expan|prc|25,e|1,0||; entry point|19919
||zer|11,-(xs)|||; set top of stack indicator|19920
||zer|8,wa|||; set initial state to zero|19921
||zer|8,wc|||; zero counter value|19922
;
;      loop here for successive entries
;
|exp01|jsr|6,scane|||; scan next element|19926
||add|7,xl|8,wa||; add state to syntax code|19927
||bsw|7,xl|2,t_nes||; switch on element type/state|19928
||iff|2,t_uo0|6,exp27||; unop, s=0|19965
||iff|2,t_uo1|6,exp27||; unop, s=1|19965
||iff|2,t_uo2|6,exp04||; unop, s=2|19965
||iff|2,t_lp0|6,exp06||; left paren, s=0|19965
||iff|2,t_lp1|6,exp06||; left paren, s=1|19965
||iff|2,t_lp2|6,exp04||; left paren, s=2|19965
||iff|2,t_lb0|6,exp08||; left brkt, s=0|19965
||iff|2,t_lb1|6,exp08||; left brkt, s=1|19965
||iff|2,t_lb2|6,exp09||; left brkt, s=2|19965
||iff|2,t_cm0|6,exp02||; comma, s=0|19965
||iff|2,t_cm1|6,exp05||; comma, s=1|19965
||iff|2,t_cm2|6,exp11||; comma, s=2|19965
||iff|2,t_fn0|6,exp10||; function, s=0|19965
||iff|2,t_fn1|6,exp10||; function, s=1|19965
||iff|2,t_fn2|6,exp04||; function, s=2|19965
||iff|2,t_va0|6,exp03||; variable, s=0|19965
||iff|2,t_va1|6,exp03||; variable, state one|19965
||iff|2,t_va2|6,exp04||; variable, s=2|19965
||iff|2,t_co0|6,exp03||; constant, s=0|19965
||iff|2,t_co1|6,exp03||; constant, s=1|19965
||iff|2,t_co2|6,exp04||; constant, s=2|19965
||iff|2,t_bo0|6,exp05||; binop, s=0|19965
||iff|2,t_bo1|6,exp05||; binop, s=1|19965
||iff|2,t_bo2|6,exp26||; binop, s=2|19965
||iff|2,t_rp0|6,exp02||; right paren, s=0|19965
||iff|2,t_rp1|6,exp05||; right paren, s=1|19965
||iff|2,t_rp2|6,exp12||; right paren, s=2|19965
||iff|2,t_rb0|6,exp02||; right brkt, s=0|19965
||iff|2,t_rb1|6,exp05||; right brkt, s=1|19965
||iff|2,t_rb2|6,exp18||; right brkt, s=2|19965
||iff|2,t_cl0|6,exp02||; colon, s=0|19965
||iff|2,t_cl1|6,exp05||; colon, s=1|19965
||iff|2,t_cl2|6,exp19||; colon, s=2|19965
||iff|2,t_sm0|6,exp02||; semicolon, s=0|19965
||iff|2,t_sm1|6,exp05||; semicolon, s=1|19965
||iff|2,t_sm2|6,exp19||; semicolon, s=2|19965
||esw||||; end switch on element type/state|19965
||ejc|||||19966
;
;      expan (continued)
;
;      here for rbr,rpr,col,smc,cma in state 0
;
;      set to rescan the terminator encountered and create
;      a null constant (case of omitted null)
;
|exp02|mnz|3,scnrs|||; set to rescan element|19975
||mov|7,xr|21,=nulls||; point to null, merge|19976
;
;      here for var or con in states 0,1
;
;      stack the variable/constant and set state=2
;
|exp03|mov|11,-(xs)|7,xr||; stack pointer to operand|19982
||mov|8,wa|18,=num02||; set state 2|19983
||brn|6,exp01|||; jump for next element|19984
;
;      here for var,con,lpr,fnc,uop in state 2
;
;      we rescan the element and create a concatenation operator
;      this is the case of the blank concatenation operator.
;
|exp04|mnz|3,scnrs|||; set to rescan element|19991
||mov|7,xr|21,=opdvc||; point to concat operator dv|19992
||bze|8,wb|6,exp4a||; ok if at top level|19993
||mov|7,xr|21,=opdvp||; else point to unmistakable concat.|19994
;
;      merge here when xr set up with proper concatenation dvblk
;
|exp4a|bnz|3,scnbl|6,exp26||; merge bop if blanks, else error|19998
;      dcv  scnse	     adjust start of element location
||erb|1,220|26,syntax error: missing operator|||20000
;
;      here for cma,rpr,rbr,col,smc,bop(s=1) bop(s=0)
;
;      this is an erronous contruction
;
;exp05 dcv  scnse	     adjust start of element location
|exp05|erb|1,221|26,syntax error: missing operand|||20008
;
;      here for lpr (s=0,1)
;
|exp06|mov|7,xl|18,=num04||; set new level indicator|20012
||zer|7,xr|||; set zero value for cmopn|20013
||ejc|||||20014
;
;      expan (continued)
;
;      merge here to store old level on stack and start new one
;
|exp07|mov|11,-(xs)|7,xr||; stack cmopn value|20020
||mov|11,-(xs)|8,wc||; stack old counter|20021
||mov|11,-(xs)|8,wb||; stack old level indicator|20022
||chk||||; check for stack overflow|20023
||zer|8,wa|||; set new state to zero|20024
||mov|8,wb|7,xl||; set new level indicator|20025
||mov|8,wc|18,=num01||; initialize new counter|20026
||brn|6,exp01|||; jump to scan next element|20027
;
;      here for lbr (s=0,1)
;
;      this is an illegal use of left bracket
;
|exp08|erb|1,222|26,syntax error: invalid use of left bracket|||20033
;
;      here for lbr (s=2)
;
;      set new level and start to scan subscripts
;
|exp09|mov|7,xr|10,(xs)+||; load array ptr for cmopn|20039
||mov|7,xl|18,=num03||; set new level indicator|20040
||brn|6,exp07|||; jump to stack old and start new|20041
;
;      here for fnc (s=0,1)
;
;      stack old level and start to scan arguments
;
|exp10|mov|7,xl|18,=num05||; set new lev indic (xr=vrblk=cmopn)|20047
||brn|6,exp07|||; jump to stack old and start new|20048
;
;      here for cma (s=2)
;
;      increment argument count and continue
;
|exp11|icv|8,wc|||; increment counter|20054
||jsr|6,expdm|||; dump operators at this level|20055
||zer|11,-(xs)|||; set new level for parameter|20056
||zer|8,wa|||; set new state|20057
||bgt|8,wb|18,=num02|6,exp01|; loop back unless outer level|20058
||erb|1,223|26,syntax error: invalid use of comma|||20059
||ejc|||||20060
;
;      expan (continued)
;
;      here for rpr (s=2)
;
;      at outer level in a normal goto this is a terminator
;      otherwise it must terminate a function or grouping
;
|exp12|beq|8,wb|18,=num01|6,exp20|; end of normal goto|20069
||beq|8,wb|18,=num05|6,exp13|; end of function arguments|20070
||beq|8,wb|18,=num04|6,exp14|; end of grouping / selection|20071
||erb|1,224|26,syntax error: unbalanced right parenthesis|||20072
;
;      here at end of function arguments
;
|exp13|mov|7,xl|18,=c_fnc||; set cmtyp value for function|20076
||brn|6,exp15|||; jump to build cmblk|20077
;
;      here for end of grouping
;
|exp14|beq|8,wc|18,=num01|6,exp17|; jump if end of grouping|20081
||mov|7,xl|18,=c_sel||; else set cmtyp for selection|20082
;
;      merge here to build cmblk for level just scanned and
;      to pop up to the previous scan level before continuing.
;
|exp15|jsr|6,expdm|||; dump operators at this level|20087
||mov|8,wa|8,wc||; copy count|20088
||add|8,wa|18,=cmvls||; add for standard fields at start|20089
||wtb|8,wa|||; convert length to bytes|20090
||jsr|6,alloc|||; allocate space for cmblk|20091
||mov|9,(xr)|22,=b_cmt||; store type code for cmblk|20092
||mov|13,cmtyp(xr)|7,xl||; store cmblk node type indicator|20093
||mov|13,cmlen(xr)|8,wa||; store length|20094
||add|7,xr|8,wa||; point past end of block|20095
||lct|8,wc|8,wc||; set loop counter|20096
;
;      loop to move remaining words to cmblk
;
|exp16|mov|11,-(xr)|10,(xs)+||; move one operand ptr from stack|20100
||mov|8,wb|10,(xs)+||; pop to old level indicator|20101
||bct|8,wc|6,exp16||; loop till all moved|20102
||ejc|||||20103
;
;      expan (continued)
;
;      complete cmblk and stack pointer to it on stack
;
||sub|7,xr|19,*cmvls||; point back to start of block|20109
||mov|8,wc|10,(xs)+||; restore old counter|20110
||mov|13,cmopn(xr)|9,(xs)||; store operand ptr in cmblk|20111
||mov|9,(xs)|7,xr||; stack cmblk pointer|20112
||mov|8,wa|18,=num02||; set new state|20113
||brn|6,exp01|||; back for next element|20114
;
;      here at end of a parenthesized expression
;
|exp17|jsr|6,expdm|||; dump operators at this level|20118
||mov|7,xr|10,(xs)+||; restore xr|20119
||mov|8,wb|10,(xs)+||; restore outer level|20120
||mov|8,wc|10,(xs)+||; restore outer count|20121
||mov|9,(xs)|7,xr||; store opnd over unused cmopn val|20122
||mov|8,wa|18,=num02||; set new state|20123
||brn|6,exp01|||; back for next ele8ent|20124
;
;      here for rbr (s=2)
;
;      at outer level in a direct goto, this is a terminator.
;      otherwise it must terminate a subscript list.
;
|exp18|mov|7,xl|18,=c_arr||; set cmtyp for array reference|20131
||beq|8,wb|18,=num03|6,exp15|; jump to build cmblk if end arrayref|20132
||beq|8,wb|18,=num02|6,exp20|; jump if end of direct goto|20133
||erb|1,225|26,syntax error: unbalanced right bracket|||20134
||ejc|||||20135
;
;      expan (continued)
;
;      here for col,smc (s=2)
;
;      error unless terminating statement body at outer level
;
|exp19|mnz|3,scnrs|||; rescan terminator|20143
||mov|7,xl|8,wb||; copy level indicator|20144
||bsw|7,xl|1,6||; switch on level indicator|20145
||iff|1,0|6,exp20||; normal outer level|20152
||iff|1,1|6,exp22||; fail if normal goto|20152
||iff|1,2|6,exp23||; fail if direct goto|20152
||iff|1,3|6,exp24||; fail array brackets|20152
||iff|1,4|6,exp21||; fail if in grouping|20152
||iff|1,5|6,exp21||; fail function args|20152
||esw||||; end switch on level|20152
;
;      here at normal end of expression
;
|exp20|jsr|6,expdm|||; dump remaining operators|20156
||mov|7,xr|10,(xs)+||; load tree pointer|20157
||ica|7,xs|||; pop off bottom of stack marker|20158
||exi||||; return to expan caller|20159
;
;      missing right paren
;
|exp21|erb|1,226|26,syntax error: missing right paren|||20163
;
;      missing right paren in goto field
;
|exp22|erb|1,227|26,syntax error: right paren missing from goto|||20167
;
;      missing bracket in goto
;
|exp23|erb|1,228|26,syntax error: right bracket missing from goto|||20171
;
;      missing array bracket
;
|exp24|erb|1,229|26,syntax error: missing right array bracket|||20175
||ejc|||||20176
;
;      expan (continued)
;
;      loop here when an operator causes an operator dump
;
|exp25|mov|3,expsv|7,xr||;|20182
||jsr|6,expop|||; pop one operator|20183
||mov|7,xr|3,expsv||; restore op dv pointer and merge|20184
;
;      here for bop (s=2)
;
;      remove operators (condense) from stack until no more
;      left at this level or top one has lower precedence.
;      loop here till this condition is met.
;
|exp26|mov|7,xl|13,num01(xs)||; load operator dvptr from stack|20192
||ble|7,xl|18,=num05|6,exp27|; jump if bottom of stack level|20193
||blt|13,dvrpr(xr)|13,dvlpr(xl)|6,exp25|; else pop if new prec is lo|20194
;
;      here for uop (s=0,1)
;
;      binary operator merges after precedence check
;
;      the operator dv is stored on the stack and the scan
;      continues after setting the scan state to one.
;
|exp27|mov|11,-(xs)|7,xr||; stack operator dvptr on stack|20203
||chk||||; check for stack overflow|20204
||mov|8,wa|18,=num01||; set new state|20205
||bne|7,xr|21,=opdvs|6,exp01|; back for next element unless =|20206
;
;      here for special case of binary =. the syntax allows a
;      null right argument for this operator to be left
;      out. accordingly we reset to state zero to get proper
;      action on a terminator (supply a null constant).
;
||zer|8,wa|||; set state zero|20213
||brn|6,exp01|||; jump for next element|20214
||enp||||; end procedure expan|20215
||ejc|||||20216
;
;      expap -- test for pattern match tree
;
;      expap is passed an expression tree to determine if it
;      is a pattern match. the following are recogized as
;      matches in the context of this call.
;
;      1)   an explicit use of binary question mark
;      2)   a concatenation
;      3)   an alternation whose left operand is a concatenation
;
;      (xr)		     ptr to expan tree
;      jsr  expap	     call to test for pattern match
;      ppm  loc		     transfer loc if not a pattern match
;      (wa)		     destroyed
;      (xr)		     unchanged (if not match)
;      (xr)		     ptr to binary operator blk if match
;
|expap|prc|25,e|1,1||; entry point|20235
||mov|11,-(xs)|7,xl||; save xl|20236
||bne|9,(xr)|22,=b_cmt|6,expp2|; no match if not complex|20237
||mov|8,wa|13,cmtyp(xr)||; else load type code|20238
||beq|8,wa|18,=c_cnc|6,expp1|; concatenation is a match|20239
||beq|8,wa|18,=c_pmt|6,expp1|; binary question mark is a match|20240
||bne|8,wa|18,=c_alt|6,expp2|; else not match unless alternation|20241
;
;      here for alternation. change (a b) / c to a qm (b / c)
;
||mov|7,xl|13,cmlop(xr)||; load left operand pointer|20245
||bne|9,(xl)|22,=b_cmt|6,expp2|; not match if left opnd not complex|20246
||bne|13,cmtyp(xl)|18,=c_cnc|6,expp2|; not match if left op not conc|20247
||mov|13,cmlop(xr)|13,cmrop(xl)||; xr points to (b / c)|20248
||mov|13,cmrop(xl)|7,xr||; set xl opnds to a, (b / c)|20249
||mov|7,xr|7,xl||; point to this altered node|20250
;
;      exit here for pattern match
;
|expp1|mov|7,xl|10,(xs)+||; restore entry xl|20254
||exi||||; give pattern match return|20255
;
;      exit here if not pattern match
;
|expp2|mov|7,xl|10,(xs)+||; restore entry xl|20259
||exi|1,1|||; give non-match return|20260
||enp||||; end procedure expap|20261
||ejc|||||20262
;
;      expdm -- dump operators at current level (for expan)
;
;      expdm uses expop to condense all operators at this syntax
;      level. the stack bottom is recognized from the level
;      value which is saved on the top of the stack.
;
;      jsr  expdm	     call to dump operators
;      (xs)		     popped as required
;      (xr,wa)		     destroyed
;
|expdm|prc|25,n|1,0||; entry point|20274
||mov|3,r_exs|7,xl||; save xl value|20275
;
;      loop to dump operators
;
|exdm1|ble|13,num01(xs)|18,=num05|6,exdm2|; jump if stack bottom (saved level|20279
||jsr|6,expop|||; else pop one operator|20280
||brn|6,exdm1|||; and loop back|20281
;
;      here after popping all operators
;
|exdm2|mov|7,xl|3,r_exs||; restore xl|20285
||zer|3,r_exs|||; release save location|20286
||exi||||; return to expdm caller|20287
||enp||||; end procedure expdm|20288
||ejc|||||20289
;
;      expop-- pop operator (for expan)
;
;      expop is used by the expan routine to condense one
;      operator from the top of the syntax stack. an appropriate
;      cmblk is built for the operator (unary or binary) and a
;      pointer to this cmblk is stacked.
;
;      expop is also used by scngf (goto field scan) procedure
;
;      jsr  expop	     call to pop operator
;      (xs)		     popped appropriately
;      (xr,xl,wa)	     destroyed
;
|expop|prc|25,n|1,0||; entry point|20304
||mov|7,xr|13,num01(xs)||; load operator dv pointer|20305
||beq|13,dvlpr(xr)|18,=lluno|6,expo2|; jump if unary|20306
;
;      here for binary operator
;
||mov|8,wa|19,*cmbs_||; set size of binary operator cmblk|20310
||jsr|6,alloc|||; allocate space for cmblk|20311
||mov|13,cmrop(xr)|10,(xs)+||; pop and store right operand ptr|20312
||mov|7,xl|10,(xs)+||; pop and load operator dv ptr|20313
||mov|13,cmlop(xr)|9,(xs)||; store left operand pointer|20314
;
;      common exit point
;
|expo1|mov|9,(xr)|22,=b_cmt||; store type code for cmblk|20318
||mov|13,cmtyp(xr)|13,dvtyp(xl)||; store cmblk node type code|20319
||mov|13,cmopn(xr)|7,xl||; store dvptr (=ptr to dac o_xxx)|20320
||mov|13,cmlen(xr)|8,wa||; store cmblk length|20321
||mov|9,(xs)|7,xr||; store resulting node ptr on stack|20322
||exi||||; return to expop caller|20323
;
;      here for unary operator
;
|expo2|mov|8,wa|19,*cmus_||; set size of unary operator cmblk|20327
||jsr|6,alloc|||; allocate space for cmblk|20328
||mov|13,cmrop(xr)|10,(xs)+||; pop and store operand pointer|20329
||mov|7,xl|9,(xs)||; load operator dv pointer|20330
||brn|6,expo1|||; merge back to exit|20331
||enp||||; end procedure expop|20332
||ejc|||||20333
;
;      filnm -- obtain file name from statement number
;
;      filnm takes a statement number and examines the file name
;      table pointed to by r_sfn to find the name of the file
;      containing the given statement.	table entries are
;      arranged in order of ascending statement number (there
;      is only one hash bucket in this table).	elements are
;      added to the table each time there is a change in
;      file name, recording the then current statement number.
;
;      to find the file name, the linked list of teblks is
;      scanned for an element containing a subscript (statement
;      number) greater than the argument statement number, or
;      the end of chain.  when this condition is met, the
;      previous teblk contains the desired file name as its
;      value entry.
;
;      (wc)		     statement number
;      jsr  filnm	     call to obtain file name
;      (xl)		     file name (scblk)
;      (ia)		     destroyed
;
|filnm|prc|25,e|1,0||; entry point|20358
||mov|11,-(xs)|8,wb||; preserve wb|20359
||bze|8,wc|6,filn3||; return nulls if stno is zero|20360
||mov|7,xl|3,r_sfn||; file name table|20361
||bze|7,xl|6,filn3||; if no table|20362
||mov|8,wb|13,tbbuk(xl)||; get bucket entry|20363
||beq|8,wb|3,r_sfn|6,filn3|; jump if no teblks on chain|20364
||mov|11,-(xs)|7,xr||; preserve xr|20365
||mov|7,xr|8,wb||; previous block pointer|20366
||mov|11,-(xs)|8,wc||; preserve stmt number|20367
;
;      loop through teblks on hash chain
;
|filn1|mov|7,xl|7,xr||; next element to examine|20371
||mov|7,xr|13,tesub(xl)||; load subscript value (an icblk)|20372
||ldi|13,icval(xr)|||; load the statement number|20373
||mfi|8,wc|||; convert to address constant|20374
||blt|9,(xs)|8,wc|6,filn2|; compare arg with teblk stmt number|20375
;
;      here if desired stmt number is ge teblk stmt number
;
||mov|8,wb|7,xl||; save previous entry pointer|20379
||mov|7,xr|13,tenxt(xl)||; point to next teblk on chain|20380
||bne|7,xr|3,r_sfn|6,filn1|; jump if there is one|20381
;
;      here if chain exhausted or desired block found.
;
|filn2|mov|7,xl|8,wb||; previous teblk|20385
||mov|7,xl|13,teval(xl)||; get ptr to file name scblk|20386
||mov|8,wc|10,(xs)+||; restore stmt number|20387
||mov|7,xr|10,(xs)+||; restore xr|20388
||mov|8,wb|10,(xs)+||; restore wb|20389
||exi|||||20390
;
;      no table or no table entries
;
|filn3|mov|8,wb|10,(xs)+||; restore wb|20394
||mov|7,xl|21,=nulls||; return null string|20395
||exi|||||20396
||enp|||||20397
||ejc|||||20398
;
;
;      flstg -- fold string to lower case
;
;      flstg folds a character string containing upper case
;      characcters to one containing lower case characters.
;      folding is only done if &case (kvcas) is not zero.
;
;      (xr)		     string argument
;      (wa)		     length of string
;      jsr  flstg	     call to fold string
;      (xr)		     result string (possibly original)
;      (wc)		     destroyed
;
|flstg|prc|25,e|1,0||; entry point|20415
||bze|3,kvcas|6,fst99||; skip if &case is 0|20416
||mov|11,-(xs)|7,xl||; save xl across call|20417
||mov|11,-(xs)|7,xr||; save original scblk ptr|20418
||jsr|6,alocs|||; allocate new string block|20419
||mov|7,xl|9,(xs)||; point to original scblk|20420
||mov|11,-(xs)|7,xr||; save pointer to new scblk|20421
||plc|7,xl|||; point to original chars|20422
||psc|7,xr|||; point to new chars|20423
||zer|11,-(xs)|||; init did fold flag|20424
||lct|8,wc|8,wc||; load loop counter|20425
|fst01|lch|8,wa|10,(xl)+||; load character|20426
||blt|8,wa|18,=ch_ua|6,fst02|; skip if less than uc a|20427
||bgt|8,wa|18,=ch_uz|6,fst02|; skip if greater than uc z|20428
||flc|8,wa|||; fold character to lower case|20429
||mnz|9,(xs)|||; set did fold character flag|20430
|fst02|sch|8,wa|10,(xr)+||; store (possibly folded) character|20431
||bct|8,wc|6,fst01||; loop thru entire string|20432
||csc|7,xr|||; complete store characters|20433
||mov|7,xr|10,(xs)+||; see if any change|20434
||bnz|7,xr|6,fst10||; skip if folding done (no change)|20435
||mov|3,dnamp|10,(xs)+||; do not need new scblk|20436
||mov|7,xr|10,(xs)+||; return original scblk|20437
||brn|6,fst20|||; merge below|20438
|fst10|mov|7,xr|10,(xs)+||; return new scblk|20439
||ica|7,xs|||; throw away original scblk pointer|20440
|fst20|mov|8,wa|13,sclen(xr)||; reload string length|20441
||mov|7,xl|10,(xs)+||; restore xl|20442
|fst99|exi||||; return|20443
||enp|||||20444
||ejc|||||20445
;
;      gbcol -- perform garbage collection
;
;      gbcol performs a garbage collection on the dynamic region
;      all blocks which are no longer in use are eliminated
;      by moving blocks which are in use down and resetting
;      dnamp, the pointer to the next available location.
;
;      (wb)		     move offset (see below)
;      jsr  gbcol	     call to collect garbage
;      (xr)		     sediment size after collection
;
;      the following conditions must be met at the time when
;      gbcol is called.
;
;      1)   all pointers to blocks in the dynamic area must be
;	    accessible to the garbage collector. this means
;	    that they must occur in one of the following.
;
;	    a)		     main stack, with current top
;			     element being indicated by xs
;
;	    b)		     in relocatable fields of vrblks.
;
;	    c)		     in register xl at the time of call
;
;	    e)		     in the special region of working
;			     storage where names begin with r_.
;
;      2)   all pointers must point to the start of blocks with
;	    the sole exception of the contents of the code
;	    pointer register which points into the r_cod block.
;
;      3)   no location which appears to contain a pointer
;	    into the dynamic region may occur unless it is in
;	    fact a pointer to the start of the block. however
;	    pointers outside this area may occur and will
;	    not be changed by the garbage collector.
;	    it is especially important to make sure that xl
;	    does not contain a garbage value from some process
;	    carried out before the call to the collector.
;
;      gbcol has the capability of moving the final compacted
;      result up in memory (with addresses adjusted accordingly)
;      this is used to add space to the static region. the
;      entry value of wb is the number of bytes to move up.
;      the caller must guarantee that there is enough room.
;      furthermore the value in wb if it is non-zero, must be at
;      least 256 so that the mwb instruction conditions are met.
||ejc|||||20500
;
;      gbcol (continued)
;
;      the algorithm, which is a modification of the lisp-2
;      garbage collector devised by r.dewar and k.belcher
;      takes three passes as follows.
;
;      1)   all pointers in memory are scanned and blocks in use
;	    determined from this scan. note that this procedure
;	    is recursive and uses the main stack for linkage.
;	    the marking process is thus similar to that used in
;	    a standard lisp collector. however the method of
;	    actually marking the blocks is different.
;
;	    the first field of a block normally contains a
;	    code entry point pointer. such an entry pointer
;	    can be distinguished from the address of any pointer
;	    to be processed by the collector. during garbage
;	    collection, this word is used to build a back chain
;	    of pointers through fields which point to the block.
;	    the end of the chain is marked by the occurence
;	    of the word which used to be in the first word of
;	    the block. this backchain serves both as a mark
;	    indicating that the block is in use and as a list of
;	    references for the relocation phase.
;
;      2)   storage is scanned sequentially to discover which
;	    blocks are currently in use as indicated by the
;	    presence of a backchain. two pointers are maintained
;	    one scans through looking at each block. the other
;	    is incremented only for blocks found to be in use.
;	    in this way, the eventual location of each block can
;	    be determined without actually moving any blocks.
;	    as each block which is in use is processed, the back
;	    chain is used to reset all pointers which point to
;	    this block to contain its new address, i.e. the
;	    address it will occupy after the blocks are moved.
;	    the first word of the block, taken from the end of
;	    the chain is restored at this point.
;
;	    during pass 2, the collector builds blocks which
;	    describe the regions of storage which are to be
;	    moved in the third pass. there is one descriptor for
;	    each contiguous set of good blocks. the descriptor
;	    is built just behind the block to be moved and
;	    contains a pointer to the next block and the number
;	    of words to be moved.
;
;      3)   in the third and final pass, the move descriptor
;	    blocks built in pass two are used to actually move
;	    the blocks down to the bottom of the dynamic region.
;	    the collection is then complete and the next
;	    available location pointer is reset.
||ejc|||||20554
;
;      gbcol (continued)
;
;      the garbage collector also recognizes the concept of
;      sediment.  sediment is defined as long-lived objects
;      which percipitate to the bottom of dynamic storage.
;      moving these objects during repeated collections is
;      inefficient.  it also contributes to thrashing on
;      systems with virtual memory.  in a typical worst-case
;      situation, there may be several megabytes of live objects
;      in the sediment, and only a few dead objects in need of
;      collection.  without recognising sediment, the standard
;      collector would move those megabytes of objects downward
;      to squeeze out the dead objects.	 this type of move
;      would result in excessive thrasing for very little memory
;      gain.
;
;      scanning of blocks in the sediment cannot be avoided
;      entirely, because these blocks may contain pointers to
;      live objects above the sediment.	 however, sediment
;      blocks need not be linked to a back chain as described
;      in pass one above.  since these blocks will not be moved,
;      pointers to them do not need to be adjusted.  eliminating
;      unnecessary back chain links increases locality of
;      reference, improving virtual memory performance.
;
;      because back chains are used to mark blocks whose con-
;      tents have been processed, a different marking system
;      is needed for blocks in the sediment.  since block type
;      words point to odd-parity entry addresses, merely incre-
;      menting the type word serves to mark the block as pro-
;      cessed.	during pass three, the type words are decre-
;      mented to restore them to their original value.
||ejc|||||20598
;
;      gbcol (continued)
;
;
;      the variable dnams contains the number of bytes of memory
;      currently in the sediment.  setting dnams to zero will
;      eliminate the sediment and force it to be included in a
;      full garbage collection.	 gbcol returns a suggested new
;      value for dnams (usually dnamp-dnamb) in xr which the
;      caller can store in dnams if it wishes to maintain the
;      sediment.  that is, data remaining after a garbage
;      collection is considered to be sediment.	 if one accepts
;      the common lore that most objects are either very short-
;      or very long-lived, then this naive setting of dnams
;      probably includes some short-lived objects toward the end
;      of the sediment.
;
;      knowing when to reset dnams to zero to collect the sedi-
;      ment is not precisely known.  we force it to zero prior
;      to producing a dump, when gbcol is invoked by collect()
;      (so that the sediment is invisible to the user), when
;      sysmm is unable to obtain additional memory, and when
;      gbcol is called to relocate the dynamic area up in memory
;      (to make room for enlarging the static area).  if there
;      are no other reset situations, this leads to the inexo-
;      rable growth of the sediment, possible forcing a modest
;      program to begin to use virtual memory that it otherwise
;      would not.
;
;      as we scan sediment blocks in pass three, we maintain
;      aggregate counts of the amount of dead and live storage,
;      which is used to decide when to reset dnams.  when the
;      ratio of free storage found in the sediment to total
;      sediment size exceeds a threshold, the sediment is marked
;      for collection on the next gbcol call.
;
||ejc|||||20636
;
;      gbcol (continued)
;
|gbcol|prc|25,e|1,0||; entry point|20640
;z-
||bnz|3,dmvch|6,gbc14||; fail if in mid-dump|20642
||mnz|3,gbcfl|||; note gbcol entered|20643
||mov|3,gbsva|8,wa||; save entry wa|20644
||mov|3,gbsvb|8,wb||; save entry wb|20645
||mov|3,gbsvc|8,wc||; save entry wc|20646
||mov|11,-(xs)|7,xl||; save entry xl|20647
||scp|8,wa|||; get code pointer value|20648
||sub|8,wa|3,r_cod||; make relative|20649
||lcp|8,wa|||; and restore|20650
||bze|8,wb|6,gbc0a||; check there is no move offset|20652
||zer|3,dnams|||; collect sediment if must move it|20653
|gbc0a|mov|8,wa|3,dnamb||; start of dynamic area|20654
||add|8,wa|3,dnams||; size of sediment|20655
||mov|3,gbcsd|8,wa||; first location past sediment|20656
;
;      inform sysgc that collection to commence
;
||mnz|7,xr|||; non-zero flags start of collection|20669
||mov|8,wa|3,dnamb||; start of dynamic area|20670
||mov|8,wb|3,dnamp||; next available location|20671
||mov|8,wc|3,dname||; last available location + 1|20672
||jsr|6,sysgc|||; inform of collection|20673
;
;      process stack entries
;
||mov|7,xr|7,xs||; point to stack front|20678
||mov|7,xl|3,stbas||; point past end of stack|20679
||bge|7,xl|7,xr|6,gbc00|; ok if d-stack|20680
||mov|7,xr|7,xl||; reverse if ...|20681
||mov|7,xl|7,xs||; ... u-stack|20682
;
;      process the stack
;
|gbc00|jsr|6,gbcpf|||; process pointers on stack|20686
;
;      process special work locations
;
||mov|7,xr|20,=r_aaa||; point to start of relocatable locs|20690
||mov|7,xl|20,=r_yyy||; point past end of relocatable locs|20691
||jsr|6,gbcpf|||; process work fields|20692
;
;      prepare to process variable blocks
;
||mov|8,wa|3,hshtb||; point to first hash slot pointer|20696
;
;      loop through hash slots
;
|gbc01|mov|7,xl|8,wa||; point to next slot|20700
||ica|8,wa|||; bump bucket pointer|20701
||mov|3,gbcnm|8,wa||; save bucket pointer|20702
||ejc|||||20703
;
;      gbcol (continued)
;
;      loop through variables on one hash chain
;
|gbc02|mov|7,xr|9,(xl)||; load ptr to next vrblk|20709
||bze|7,xr|6,gbc03||; jump if end of chain|20710
||mov|7,xl|7,xr||; else copy vrblk pointer|20711
||add|7,xr|19,*vrval||; point to first reloc fld|20712
||add|7,xl|19,*vrnxt||; point past last (and to link ptr)|20713
||jsr|6,gbcpf|||; process reloc fields in vrblk|20714
||brn|6,gbc02|||; loop back for next block|20715
;
;      here at end of one hash chain
;
|gbc03|mov|8,wa|3,gbcnm||; restore bucket pointer|20719
||bne|8,wa|3,hshte|6,gbc01|; loop back if more buckets to go|20720
||ejc|||||20721
;
;      gbcol (continued)
;
;      now we are ready to start pass two. registers are used
;      as follows in pass two.
;
;      (xr)		     scans through all blocks
;      (wc)		     pointer to eventual location
;
;      the move description blocks built in this pass have
;      the following format.
;
;      word 1		     pointer to next move block,
;			     zero if end of chain of blocks
;
;      word 2		     length of blocks to be moved in
;			     bytes. set to the address of the
;			     first byte while actually scanning
;			     the blocks.
;
;      the first entry on this chain is a special entry
;      consisting of the two words gbcnm and gbcns. after
;      building the chain of move descriptors, gbcnm points to
;      the first real move block, and gbcns is the length of
;      blocks in use at the start of storage which need not
;      be moved since they are in the correct position.
;
||mov|7,xr|3,dnamb||; point to first block|20750
||zer|8,wb|||; accumulate size of dead blocks|20751
|gbc04|beq|7,xr|3,gbcsd|6,gbc4c|; jump if end of sediment|20752
||mov|8,wa|9,(xr)||; else get first word|20753
||bod|8,wa|6,gbc4b||; jump if entry pointer (unused)|20755
||dcv|8,wa|||; restore entry pointer|20756
||mov|9,(xr)|8,wa||; restore first word|20762
||jsr|6,blkln|||; get length of this block|20763
||add|7,xr|8,wa||; bump actual pointer|20764
||brn|6,gbc04|||; continue scan through sediment|20765
;
;      here for unused sediment block
;
|gbc4b|jsr|6,blkln|||; get length of this block|20769
||add|7,xr|8,wa||; bump actual pointer|20770
||add|8,wb|8,wa||; count size of unused blocks|20771
||brn|6,gbc04|||; continue scan through sediment|20772
;
;      here at end of sediment.	 remember size of free blocks
;      within the sediment.  this will be used later to decide
;      how to set the sediment size returned to caller.
;
;      then scan rest of dynamic area above sediment.
;
;      (wb) = aggregate size of free blocks in sediment
;      (xr) = first location past sediment
;
|gbc4c|mov|3,gbcsf|8,wb||; size of sediment free space|20783
||mov|8,wc|7,xr||; set as first eventual location|20787
||add|8,wc|3,gbsvb||; add offset for eventual move up|20788
||zer|3,gbcnm|||; clear initial forward pointer|20789
||mov|3,gbclm|20,=gbcnm||; initialize ptr to last move block|20790
||mov|3,gbcns|7,xr||; initialize first address|20791
;
;      loop through a series of blocks in use
;
|gbc05|beq|7,xr|3,dnamp|6,gbc07|; jump if end of used region|20795
||mov|8,wa|9,(xr)||; else get first word|20796
||bod|8,wa|6,gbc07||; jump if entry pointer (unused)|20798
;
;      here for block in use, loop to relocate references
;
|gbc06|mov|7,xl|8,wa||; copy pointer|20806
||mov|8,wa|9,(xl)||; load forward pointer|20807
||mov|9,(xl)|8,wc||; relocate reference|20808
||bev|8,wa|6,gbc06||; loop back if not end of chain|20810
||ejc|||||20815
;
;      gbcol (continued)
;
;      at end of chain, restore first word and bump past
;
||mov|9,(xr)|8,wa||; restore first word|20821
||jsr|6,blkln|||; get length of this block|20822
||add|7,xr|8,wa||; bump actual pointer|20823
||add|8,wc|8,wa||; bump eventual pointer|20824
||brn|6,gbc05|||; loop back for next block|20825
;
;      here at end of a series of blocks in use
;
|gbc07|mov|8,wa|7,xr||; copy pointer past last block|20829
||mov|7,xl|3,gbclm||; point to previous move block|20830
||sub|8,wa|13,num01(xl)||; subtract starting address|20831
||mov|13,num01(xl)|8,wa||; store length of block to be moved|20832
;
;      loop through a series of blocks not in use
;
|gbc08|beq|7,xr|3,dnamp|6,gbc10|; jump if end of used region|20836
||mov|8,wa|9,(xr)||; else load first word of next block|20837
||bev|8,wa|6,gbc09||; jump if in use|20839
||jsr|6,blkln|||; else get length of next block|20844
||add|7,xr|8,wa||; push pointer|20845
||brn|6,gbc08|||; and loop back|20846
;
;      here for a block in use after processing a series of
;      blocks which were not in use, build new move block.
;
|gbc09|sub|7,xr|19,*num02||; point 2 words behind for move block|20851
||mov|7,xl|3,gbclm||; point to previous move block|20852
||mov|9,(xl)|7,xr||; set forward ptr in previous block|20853
||zer|9,(xr)|||; zero forward ptr of new block|20854
||mov|3,gbclm|7,xr||; remember address of this block|20855
||mov|7,xl|7,xr||; copy ptr to move block|20856
||add|7,xr|19,*num02||; point back to block in use|20857
||mov|13,num01(xl)|7,xr||; store starting address|20858
||brn|6,gbc06|||; jump to process block in use|20859
||ejc|||||20860
;
;      gbcol (continued)
;
;      here for pass three -- actually move the blocks down
;
;      (xl)		     pointer to old location
;      (xr)		     pointer to new location
;
|gbc10|mov|7,xr|3,gbcsd||; point to storage above sediment|20870
||add|7,xr|3,gbcns||; bump past unmoved blocks at start|20874
;
;      loop through move descriptors
;
|gbc11|mov|7,xl|3,gbcnm||; point to next move block|20878
||bze|7,xl|6,gbc12||; jump if end of chain|20879
||mov|3,gbcnm|10,(xl)+||; move pointer down chain|20880
||mov|8,wa|10,(xl)+||; get length to move|20881
||mvw||||; perform move|20882
||brn|6,gbc11|||; loop back|20883
;
;      now test for move up
;
|gbc12|mov|3,dnamp|7,xr||; set next available loc ptr|20887
||mov|8,wb|3,gbsvb||; reload move offset|20888
||bze|8,wb|6,gbc13||; jump if no move required|20889
||mov|7,xl|7,xr||; else copy old top of core|20890
||add|7,xr|8,wb||; point to new top of core|20891
||mov|3,dnamp|7,xr||; save new top of core pointer|20892
||mov|8,wa|7,xl||; copy old top|20893
||sub|8,wa|3,dnamb||; minus old bottom = length|20894
||add|3,dnamb|8,wb||; bump bottom to get new value|20895
||mwb||||; perform move (backwards)|20896
;
;      merge here to exit
;
|gbc13|zer|7,xr|||; clear garbage value in xr|20900
||mov|3,gbcfl|7,xr||; note exit from gbcol|20901
||mov|8,wa|3,dnamb||; start of dynamic area|20903
||mov|8,wb|3,dnamp||; next available location|20904
||mov|8,wc|3,dname||; last available location + 1|20905
||jsr|6,sysgc|||; inform sysgc of completion|20906
;
;      decide whether to mark sediment for collection next time.
;      this is done by examining the ratio of previous sediment
;      free space to the new sediment size.
;
||sti|3,gbcia|||; save ia|20914
||zer|7,xr|||; presume no sediment will remain|20915
||mov|8,wb|3,gbcsf||; free space in sediment|20916
||btw|8,wb|||; convert bytes to words|20917
||mti|8,wb|||; put sediment free store in ia|20918
||mli|3,gbsed|||; multiply by sediment factor|20919
||iov|6,gb13a|||; jump if overflowed|20920
||mov|8,wb|3,dnamp||; end of dynamic area in use|20921
||sub|8,wb|3,dnamb||; minus start is sediment remaining|20922
||btw|8,wb|||; convert to words|20923
||mov|3,gbcsf|8,wb||; store it|20924
||sbi|3,gbcsf|||; subtract from scaled up free store|20925
||igt|6,gb13a|||; jump if large free store in sedimnt|20926
||mov|7,xr|3,dnamp||; below threshold, return sediment|20927
||sub|7,xr|3,dnamb||; for use by caller|20928
|gb13a|ldi|3,gbcia|||; restore ia|20929
||mov|8,wa|3,gbsva||; restore wa|20931
||mov|8,wb|3,gbsvb||; restore wb|20932
||scp|8,wc|||; get code pointer|20933
||add|8,wc|3,r_cod||; make absolute again|20934
||lcp|8,wc|||; and replace absolute value|20935
||mov|8,wc|3,gbsvc||; restore wc|20936
||mov|7,xl|10,(xs)+||; restore entry xl|20937
||icv|3,gbcnt|||; increment count of collections|20938
||exi||||; exit to gbcol caller|20939
;
;      garbage collection not allowed whilst dumping
;
|gbc14|icv|3,errft|||; fatal error|20943
||erb|1,250|26,insufficient memory to complete dump|||20944
||enp||||; end procedure gbcol|20945
||ejc|||||20946
;
;      gbcpf -- process fields for garbage collector
;
;      this procedure is used by the garbage collector to
;      process fields in pass one. see gbcol for full details.
;
;      (xr)		     ptr to first location to process
;      (xl)		     ptr past last location to process
;      jsr  gbcpf	     call to process fields
;      (xr,wa,wb,wc,ia)	     destroyed
;
;      note that although this procedure uses a recursive
;      approach, it controls its own stack and is not recursive.
;
|gbcpf|prc|25,e|1,0||; entry point|20961
||zer|11,-(xs)|||; set zero to mark bottom of stack|20962
||mov|11,-(xs)|7,xl||; save end pointer|20963
;
;      merge here to go down a level and start a new loop
;
;      1(xs)		     next lvl field ptr (0 at outer lvl)
;      0(xs)		     ptr past last field to process
;      (xr)		     ptr to first field to process
;
;      loop to process successive fields
;
|gpf01|mov|7,xl|9,(xr)||; load field contents|20973
||mov|8,wc|7,xr||; save field pointer|20974
||blt|7,xl|3,dnamb|6,gpf2a|; jump if not ptr into dynamic area|20978
||bge|7,xl|3,dnamp|6,gpf2a|; jump if not ptr into dynamic area|20979
;
;      here we have a ptr to a block in the dynamic area.
;      link this field onto the reference backchain.
;
||mov|8,wa|9,(xl)||; load ptr to chain (or entry ptr)|20984
||blt|7,xl|3,gbcsd|6,gpf1a|; do not chain if within sediment|20986
||mov|9,(xl)|7,xr||; set this field as new head of chain|20988
||mov|9,(xr)|8,wa||; set forward pointer|20989
;
;      now see if this block has been processed before
;
|gpf1a|bod|8,wa|6,gpf03||; jump if not already processed|20994
;
;      here to restore pointer in xr to field just processed
;
|gpf02|mov|7,xr|8,wc||; restore field pointer|21002
;
;      here to move to next field
;
|gpf2a|ica|7,xr|||; bump to next field|21006
||bne|7,xr|9,(xs)|6,gpf01|; loop back if more to go|21007
||ejc|||||21008
;
;      gbcpf (continued)
;
;      here we pop up a level after finishing a block
;
||mov|7,xl|10,(xs)+||; restore pointer past end|21014
||mov|7,xr|10,(xs)+||; restore block pointer|21015
||bnz|7,xr|6,gpf2a||; continue loop unless outer levl|21016
||exi||||; return to caller if outer level|21017
;
;      here to process an active block which has not been done
;
;
;      since sediment blocks are not marked by putting them on
;      the back chain, they must be explicitly marked in another
;      manner.	if odd parity entry points are present, mark by
;      temporarily converting to even parity.  if odd parity not
;      available, the entry point is adjusted by the value in
;      gbcmk.
;
|gpf03|bge|7,xl|3,gbcsd|6,gpf3a|; if not within sediment|21030
||icv|9,(xl)|||; mark by making entry point even|21032
|gpf3a|mov|7,xr|7,xl||; copy block pointer|21036
||mov|7,xl|8,wa||; copy first word of block|21040
||lei|7,xl|||; load entry point id (bl_xx)|21041
;
;      block type switch. note that blocks with no relocatable
;      fields just return to gpf02 here to continue to next fld.
;
||bsw|7,xl|2,bl___||; switch on block type|21046
||iff|2,bl_ar|6,gpf06||; arblk|21084
||iff|2,bl_cd|6,gpf19||; cdblk|21084
||iff|2,bl_ex|6,gpf17||; exblk|21084
||iff|2,bl_ic|6,gpf02||; icblk|21084
||iff|2,bl_nm|6,gpf10||; nmblk|21084
||iff|2,bl_p0|6,gpf10||; p0blk|21084
||iff|2,bl_p1|6,gpf12||; p1blk|21084
||iff|2,bl_p2|6,gpf12||; p2blk|21084
||iff|2,bl_rc|6,gpf02||; rcblk|21084
||iff|2,bl_sc|6,gpf02||; scblk|21084
||iff|2,bl_se|6,gpf02||; seblk|21084
||iff|2,bl_tb|6,gpf08||; tbblk|21084
||iff|2,bl_vc|6,gpf08||; vcblk|21084
||iff|2,bl_xn|6,gpf02||; xnblk|21084
||iff|2,bl_xr|6,gpf09||; xrblk|21084
||iff|2,bl_bc|6,gpf02||; bcblk - dummy to fill out iffs|21084
||iff|2,bl_pd|6,gpf13||; pdblk|21084
||iff|2,bl_tr|6,gpf16||; trblk|21084
||iff|2,bl_bf|6,gpf02||; bfblk|21084
||iff|2,bl_cc|6,gpf07||; ccblk|21084
||iff|2,bl_cm|6,gpf04||; cmblk|21084
||iff|2,bl_ct|6,gpf02||; ctblk|21084
||iff|2,bl_df|6,gpf02||; dfblk|21084
||iff|2,bl_ef|6,gpf02||; efblk|21084
||iff|2,bl_ev|6,gpf10||; evblk|21084
||iff|2,bl_ff|6,gpf11||; ffblk|21084
||iff|2,bl_kv|6,gpf02||; kvblk|21084
||iff|2,bl_pf|6,gpf14||; pfblk|21084
||iff|2,bl_te|6,gpf15||; teblk|21084
||esw||||; end of jump table|21084
||ejc|||||21085
;
;      gbcpf (continued)
;
;      cmblk
;
|gpf04|mov|8,wa|13,cmlen(xr)||; load length|21091
||mov|8,wb|19,*cmtyp||; set offset|21092
;
;      here to push down to new level
;
;      (wc)		     field ptr at previous level
;      (xr)		     ptr to new block
;      (wa)		     length (reloc flds + flds at start)
;      (wb)		     offset to first reloc field
;
|gpf05|add|8,wa|7,xr||; point past last reloc field|21101
||add|7,xr|8,wb||; point to first reloc field|21102
||mov|11,-(xs)|8,wc||; stack old field pointer|21103
||mov|11,-(xs)|8,wa||; stack new limit pointer|21104
||chk||||; check for stack overflow|21105
||brn|6,gpf01|||; if ok, back to process|21106
;
;      arblk
;
|gpf06|mov|8,wa|13,arlen(xr)||; load length|21110
||mov|8,wb|13,arofs(xr)||; set offset to 1st reloc fld (arpro)|21111
||brn|6,gpf05|||; all set|21112
;
;      ccblk
;
|gpf07|mov|8,wa|13,ccuse(xr)||; set length in use|21116
||mov|8,wb|19,*ccuse||; 1st word (make sure at least one)|21117
||brn|6,gpf05|||; all set|21118
||ejc|||||21119
;
;      gbcpf (continued)
;
;      cdblk
;
|gpf19|mov|8,wa|13,cdlen(xr)||; load length|21126
||mov|8,wb|19,*cdfal||; set offset|21127
||brn|6,gpf05|||; jump back|21128
;
;      tbblk, vcblk
;
|gpf08|mov|8,wa|13,offs2(xr)||; load length|21135
||mov|8,wb|19,*offs3||; set offset|21136
||brn|6,gpf05|||; jump back|21137
;
;      xrblk
;
|gpf09|mov|8,wa|13,xrlen(xr)||; load length|21141
||mov|8,wb|19,*xrptr||; set offset|21142
||brn|6,gpf05|||; jump back|21143
;
;      evblk, nmblk, p0blk
;
|gpf10|mov|8,wa|19,*offs2||; point past second field|21147
||mov|8,wb|19,*offs1||; offset is one (only reloc fld is 2)|21148
||brn|6,gpf05|||; all set|21149
;
;      ffblk
;
|gpf11|mov|8,wa|19,*ffofs||; set length|21153
||mov|8,wb|19,*ffnxt||; set offset|21154
||brn|6,gpf05|||; all set|21155
;
;      p1blk, p2blk
;
|gpf12|mov|8,wa|19,*parm2||; length (parm2 is non-relocatable)|21159
||mov|8,wb|19,*pthen||; set offset|21160
||brn|6,gpf05|||; all set|21161
||ejc|||||21162
;
;      gbcpf (continued)
;
;      pdblk
;
|gpf13|mov|7,xl|13,pddfp(xr)||; load ptr to dfblk|21168
||mov|8,wa|13,dfpdl(xl)||; get pdblk length|21169
||mov|8,wb|19,*pdfld||; set offset|21170
||brn|6,gpf05|||; all set|21171
;
;      pfblk
;
|gpf14|mov|8,wa|19,*pfarg||; length past last reloc|21175
||mov|8,wb|19,*pfcod||; offset to first reloc|21176
||brn|6,gpf05|||; all set|21177
;
;      teblk
;
|gpf15|mov|8,wa|19,*tesi_||; set length|21181
||mov|8,wb|19,*tesub||; and offset|21182
||brn|6,gpf05|||; all set|21183
;
;      trblk
;
|gpf16|mov|8,wa|19,*trsi_||; set length|21187
||mov|8,wb|19,*trval||; and offset|21188
||brn|6,gpf05|||; all set|21189
;
;      exblk
;
|gpf17|mov|8,wa|13,exlen(xr)||; load length|21193
||mov|8,wb|19,*exflc||; set offset|21194
||brn|6,gpf05|||; jump back|21195
||enp||||; end procedure gbcpf|21205
||ejc|||||21206
;z+
;
;      gtarr -- get array
;
;      gtarr is passed an object and returns an array if possibl
;
;      (xr)		     value to be converted
;      (wa)		     0 to place table addresses in array
;			     non-zero for keys/values in array
;      jsr  gtarr	     call to get array
;      ppm  loc		     transfer loc for all null table
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     resulting array
;      (xl,wa,wb,wc)	     destroyed
;
|gtarr|prc|25,e|1,2||; entry point|21222
||mov|3,gtawa|8,wa||; save wa indicator|21223
||mov|8,wa|9,(xr)||; load type word|21224
||beq|8,wa|22,=b_art|6,gtar8|; exit if already an array|21225
||beq|8,wa|22,=b_vct|6,gtar8|; exit if already an array|21226
||bne|8,wa|22,=b_tbt|6,gta9a|; else fail if not a table (sgd02)|21227
;
;      here we convert a table to an array
;
||mov|11,-(xs)|7,xr||; replace tbblk pointer on stack|21231
||zer|7,xr|||; signal first pass|21232
||zer|8,wb|||; zero non-null element count|21233
;
;      the following code is executed twice. on the first pass,
;      signalled by xr=0, the number of non-null elements in
;      the table is counted in wb. in the second pass, where
;      xr is a pointer into the arblk, the name and value are
;      entered into the current arblk location provided gtawa
;      is non-zero.  if gtawa is zero, the address of the teblk
;      is entered into the arblk twice (c3.762).
;
|gtar1|mov|7,xl|9,(xs)||; point to table|21243
||add|7,xl|13,tblen(xl)||; point past last bucket|21244
||sub|7,xl|19,*tbbuk||; set first bucket offset|21245
||mov|8,wa|7,xl||; copy adjusted pointer|21246
;
;      loop through buckets in table block
;      next three lines of code rely on tenxt having a value
;      1 less than tbbuk.
;
|gtar2|mov|7,xl|8,wa||; copy bucket pointer|21252
||dca|8,wa|||; decrement bucket pointer|21253
;
;      loop through teblks on one bucket chain
;
|gtar3|mov|7,xl|13,tenxt(xl)||; point to next teblk|21257
||beq|7,xl|9,(xs)|6,gtar6|; jump if chain end (tbblk ptr)|21258
||mov|3,cnvtp|7,xl||; else save teblk pointer|21259
;
;      loop to find value down trblk chain
;
|gtar4|mov|7,xl|13,teval(xl)||; load value|21263
||beq|9,(xl)|22,=b_trt|6,gtar4|; loop till value found|21264
||mov|8,wc|7,xl||; copy value|21265
||mov|7,xl|3,cnvtp||; restore teblk pointer|21266
||ejc|||||21267
;
;      gtarr (continued)
;
;      now check for null and test cases
;
||beq|8,wc|21,=nulls|6,gtar3|; loop back to ignore null value|21273
||bnz|7,xr|6,gtar5||; jump if second pass|21274
||icv|8,wb|||; for the first pass, bump count|21275
||brn|6,gtar3|||; and loop back for next teblk|21276
;
;      here in second pass
;
|gtar5|bze|3,gtawa|6,gta5a||; jump if address wanted|21280
||mov|10,(xr)+|13,tesub(xl)||; store subscript name|21281
||mov|10,(xr)+|8,wc||; store value in arblk|21282
||brn|6,gtar3|||; loop back for next teblk|21283
;
;      here to record teblk address in arblk.  this allows
;      a sort routine to sort by ascending address.
;
|gta5a|mov|10,(xr)+|7,xl||; store teblk address in name|21288
||mov|10,(xr)+|7,xl||; and value slots|21289
||brn|6,gtar3|||; loop back for next teblk|21290
;
;      here after scanning teblks on one chain
;
|gtar6|bne|8,wa|9,(xs)|6,gtar2|; loop back if more buckets to go|21294
||bnz|7,xr|6,gtar7||; else jump if second pass|21295
;
;      here after counting non-null elements
;
||bze|8,wb|6,gtar9||; fail if no non-null elements|21299
||mov|8,wa|8,wb||; else copy count|21300
||add|8,wa|8,wb||; double (two words/element)|21301
||add|8,wa|18,=arvl2||; add space for standard fields|21302
||wtb|8,wa|||; convert length to bytes|21303
||bgt|8,wa|3,mxlen|6,gta9b|; error if too long for array|21304
||jsr|6,alloc|||; else allocate space for arblk|21305
||mov|9,(xr)|22,=b_art||; store type word|21306
||zer|13,idval(xr)|||; zero id for the moment|21307
||mov|13,arlen(xr)|8,wa||; store length|21308
||mov|13,arndm(xr)|18,=num02||; set dimensions = 2|21309
||ldi|4,intv1|||; get integer one|21310
||sti|13,arlbd(xr)|||; store as lbd 1|21311
||sti|13,arlb2(xr)|||; store as lbd 2|21312
||ldi|4,intv2|||; load integer two|21313
||sti|13,ardm2(xr)|||; store as dim 2|21314
||mti|8,wb|||; get element count as integer|21315
||sti|13,ardim(xr)|||; store as dim 1|21316
||zer|13,arpr2(xr)|||; zero prototype field for now|21317
||mov|13,arofs(xr)|19,*arpr2||; set offset field (signal pass 2)|21318
||mov|8,wb|7,xr||; save arblk pointer|21319
||add|7,xr|19,*arvl2||; point to first element location|21320
||brn|6,gtar1|||; jump back to fill in elements|21321
||ejc|||||21322
;
;      gtarr (continued)
;
;      here after filling in element values
;
|gtar7|mov|7,xr|8,wb||; restore arblk pointer|21328
||mov|9,(xs)|8,wb||; store as result|21329
;
;      now we need the array prototype which is of the form nn,2
;      this is obtained by building the string for nn02 and
;      changing the zero to a comma before storing it.
;
||ldi|13,ardim(xr)|||; get number of elements (nn)|21335
||mli|4,intvh|||; multiply by 100|21336
||adi|4,intv2|||; add 2 (nn02)|21337
||jsr|6,icbld|||; build integer|21338
||mov|11,-(xs)|7,xr||; store ptr for gtstg|21339
||jsr|6,gtstg|||; convert to string|21340
||ppm||||; convert fail is impossible|21341
||mov|7,xl|7,xr||; copy string pointer|21342
||mov|7,xr|10,(xs)+||; reload arblk pointer|21343
||mov|13,arpr2(xr)|7,xl||; store prototype ptr (nn02)|21344
||sub|8,wa|18,=num02||; adjust length to point to zero|21345
||psc|7,xl|8,wa||; point to zero|21346
||mov|8,wb|18,=ch_cm||; load a comma|21347
||sch|8,wb|9,(xl)||; store a comma over the zero|21348
||csc|7,xl|||; complete store characters|21349
;
;      normal return
;
|gtar8|exi||||; return to caller|21353
;
;      null table non-conversion return
;
|gtar9|mov|7,xr|10,(xs)+||; restore stack for conv err (sgd02)|21357
||exi|1,1|||; return|21358
;
;      impossible conversion return
;
|gta9a|exi|1,2|||; return|21362
;
;      array size too large
;
|gta9b|erb|1,260|26,conversion array size exceeds maximum permitted|||21366
||enp||||; procedure gtarr|21367
||ejc|||||21368
;
;      gtcod -- convert to code
;
;      (xr)		     object to be converted
;      jsr  gtcod	     call to convert to code
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to resulting cdblk
;      (xl,wa,wb,wc,ra)	     destroyed
;
;      if a spitbol error occurs during compilation or pre-
;      evaluation, control is passed via error section to exfal
;      without returning to this routine.
;
|gtcod|prc|25,e|1,1||; entry point|21382
||beq|9,(xr)|22,=b_cds|6,gtcd1|; jump if already code|21383
||beq|9,(xr)|22,=b_cdc|6,gtcd1|; jump if already code|21384
;
;      here we must generate a cdblk by compilation
;
||mov|11,-(xs)|7,xr||; stack argument for gtstg|21388
||jsr|6,gtstg|||; convert argument to string|21389
||ppm|6,gtcd2|||; jump if non-convertible|21390
||mov|3,gtcef|3,flptr||; save fail ptr in case of error|21391
||mov|3,r_gtc|3,r_cod||; also save code ptr|21392
||mov|3,r_cim|7,xr||; else set image pointer|21393
||mov|3,scnil|8,wa||; set image length|21394
||zer|3,scnpt|||; set scan pointer|21395
||mov|3,stage|18,=stgxc||; set stage for execute compile|21396
||mov|3,lstsn|3,cmpsn||; in case listr called|21397
||icv|3,cmpln|||; bump line number|21399
||jsr|6,cmpil|||; compile string|21401
||mov|3,stage|18,=stgxt||; reset stage for execute time|21402
||zer|3,r_cim|||; clear image|21403
;
;      merge here if no convert required
;
|gtcd1|exi||||; give normal gtcod return|21407
;
;      here if unconvertible
;
|gtcd2|exi|1,1|||; give error return|21411
||enp||||; end procedure gtcod|21412
||ejc|||||21413
;
;      gtexp -- convert to expression
;
;      (wb)		     0 if by value, 1 if by name
;      (xr)		     input value to be converted
;      jsr  gtexp	     call to convert to expression
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to result exblk or seblk
;      (xl,wa,wb,wc,ra)	     destroyed
;
;      if a spitbol error occurs during compilation or pre-
;      evaluation, control is passed via error section to exfal
;      without returning to this routine.
;
|gtexp|prc|25,e|1,1||; entry point|21430
||blo|9,(xr)|22,=b_e__|6,gtex1|; jump if already an expression|21431
||mov|11,-(xs)|7,xr||; store argument for gtstg|21432
||jsr|6,gtstg|||; convert argument to string|21433
||ppm|6,gtex2|||; jump if unconvertible|21434
;
;      check the last character of the string for colon or
;      semicolon.  these characters can legitimately end an
;      expression in open code, so expan will not detect them
;      as errors, but they are invalid as terminators for a
;      string that is being converted to expression form.
;
||mov|7,xl|7,xr||; copy input string pointer|21442
||plc|7,xl|8,wa||; point one past the string end|21443
||lch|7,xl|11,-(xl)||; fetch the last character|21444
||beq|7,xl|18,=ch_cl|6,gtex2|; error if it is a semicolon|21445
||beq|7,xl|18,=ch_sm|6,gtex2|; or if it is a colon|21446
;
;      here we convert a string by compilation
;
||mov|3,r_cim|7,xr||; set input image pointer|21450
||zer|3,scnpt|||; set scan pointer|21451
||mov|3,scnil|8,wa||; set input image length|21452
||mov|11,-(xs)|8,wb||; save value/name flag|21454
||zer|8,wb|||; set code for normal scan|21456
||mov|3,gtcef|3,flptr||; save fail ptr in case of error|21457
||mov|3,r_gtc|3,r_cod||; also save code ptr|21458
||mov|3,stage|18,=stgev||; adjust stage for compile|21459
||mov|3,scntp|18,=t_uok||; indicate unary operator acceptable|21460
||jsr|6,expan|||; build tree for expression|21461
||zer|3,scnrs|||; reset rescan flag|21462
||mov|8,wa|10,(xs)+||; restore value/name flag|21464
||bne|3,scnpt|3,scnil|6,gtex2|; error if not end of image|21466
||zer|8,wb|||; set ok value for cdgex call|21467
||mov|7,xl|7,xr||; copy tree pointer|21468
||jsr|6,cdgex|||; build expression block|21469
||zer|3,r_cim|||; clear pointer|21470
||mov|3,stage|18,=stgxt||; restore stage for execute time|21471
;
;      merge here if no conversion required
;
|gtex1|exi||||; return to gtexp caller|21475
;
;      here if unconvertible
;
|gtex2|exi|1,1|||; take error exit|21479
||enp||||; end procedure gtexp|21480
||ejc|||||21481
;
;      gtint -- get integer value
;
;      gtint is passed an object and returns an integer after
;      performing any necessary conversions.
;
;      (xr)		     value to be converted
;      jsr  gtint	     call to convert to integer
;      ppm  loc		     transfer loc for convert impossible
;      (xr)		     resulting integer
;      (wc,ra)		     destroyed
;      (wa,wb)		     destroyed (only on conversion err)
;      (xr)		     unchanged (on convert error)
;
|gtint|prc|25,e|1,1||; entry point|21496
||beq|9,(xr)|22,=b_icl|6,gtin2|; jump if already an integer|21497
||mov|3,gtina|8,wa||; else save wa|21498
||mov|3,gtinb|8,wb||; save wb|21499
||jsr|6,gtnum|||; convert to numeric|21500
||ppm|6,gtin3|||; jump if unconvertible|21501
||beq|8,wa|22,=b_icl|6,gtin1|; jump if integer|21504
;
;      here we convert a real to integer
;
||ldr|13,rcval(xr)|||; load real value|21508
||rti|6,gtin3|||; convert to integer (err if ovflow)|21509
||jsr|6,icbld|||; if ok build icblk|21510
;
;      here after successful conversion to integer
;
|gtin1|mov|8,wa|3,gtina||; restore wa|21515
||mov|8,wb|3,gtinb||; restore wb|21516
;
;      common exit point
;
|gtin2|exi||||; return to gtint caller|21520
;
;      here on conversion error
;
|gtin3|exi|1,1|||; take convert error exit|21524
||enp||||; end procedure gtint|21525
||ejc|||||21526
;
;      gtnum -- get numeric value
;
;      gtnum is given an object and returns either an integer
;      or a real, performing any necessary conversions.
;
;      (xr)		     object to be converted
;      jsr  gtnum	     call to convert to numeric
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to result (int or real)
;      (wa)		     first word of result block
;      (wb,wc,ra)	     destroyed
;      (xr)		     unchanged (on convert error)
;
|gtnum|prc|25,e|1,1||; entry point|21541
||mov|8,wa|9,(xr)||; load first word of block|21542
||beq|8,wa|22,=b_icl|6,gtn34|; jump if integer (no conversion)|21543
||beq|8,wa|22,=b_rcl|6,gtn34|; jump if real (no conversion)|21546
;
;      at this point the only possibility is to convert a string
;      to an integer or real as appropriate.
;
||mov|11,-(xs)|7,xr||; stack argument in case convert err|21552
||mov|11,-(xs)|7,xr||; stack argument for gtstg|21553
||jsr|6,gtstg|||; convert argument to string|21555
||ppm|6,gtn36|||; jump if unconvertible|21559
;
;      initialize numeric conversion
;
||ldi|4,intv0|||; initialize integer result to zero|21563
||bze|8,wa|6,gtn32||; jump to exit with zero if null|21564
||lct|8,wa|8,wa||; set bct counter for following loops|21565
||zer|3,gtnnf|||; tentatively indicate result +|21566
||sti|3,gtnex|||; initialise exponent to zero|21569
||zer|3,gtnsc|||; zero scale in case real|21570
||zer|3,gtndf|||; reset flag for dec point found|21571
||zer|3,gtnrd|||; reset flag for digits found|21572
||ldr|4,reav0|||; zero real accum in case real|21573
||plc|7,xr|||; point to argument characters|21575
;
;      merge back here after ignoring leading blank
;
|gtn01|lch|8,wb|10,(xr)+||; load first character|21579
||blt|8,wb|18,=ch_d0|6,gtn02|; jump if not digit|21580
||ble|8,wb|18,=ch_d9|6,gtn06|; jump if first char is a digit|21581
||ejc|||||21582
;
;      gtnum (continued)
;
;      here if first digit is non-digit
;
|gtn02|bne|8,wb|18,=ch_bl|6,gtn03|; jump if non-blank|21588
|gtna2|bct|8,wa|6,gtn01||; else decr count and loop back|21589
||brn|6,gtn07|||; jump to return zero if all blanks|21590
;
;      here for first character non-blank, non-digit
;
|gtn03|beq|8,wb|18,=ch_pl|6,gtn04|; jump if plus sign|21594
||beq|8,wb|18,=ch_ht|6,gtna2|; horizontal tab equiv to blank|21596
||bne|8,wb|18,=ch_mn|6,gtn12|; jump if not minus (may be real)|21604
||mnz|3,gtnnf|||; if minus sign, set negative flag|21606
;
;      merge here after processing sign
;
|gtn04|bct|8,wa|6,gtn05||; jump if chars left|21610
||brn|6,gtn36|||; else error|21611
;
;      loop to fetch characters of an integer
;
|gtn05|lch|8,wb|10,(xr)+||; load next character|21615
||blt|8,wb|18,=ch_d0|6,gtn08|; jump if not a digit|21616
||bgt|8,wb|18,=ch_d9|6,gtn08|; jump if not a digit|21617
;
;      merge here for first digit
;
|gtn06|sti|3,gtnsi|||; save current value|21621
||cvm|6,gtn35|||; current*10-(new dig) jump if ovflow|21625
||mnz|3,gtnrd|||; set digit read flag|21626
||bct|8,wa|6,gtn05||; else loop back if more chars|21628
;
;      here to exit with converted integer value
;
|gtn07|bnz|3,gtnnf|6,gtn32||; jump if negative (all set)|21632
||ngi||||; else negate|21633
||ino|6,gtn32|||; jump if no overflow|21634
||brn|6,gtn36|||; else signal error|21635
||ejc|||||21636
;
;      gtnum (continued)
;
;      here for a non-digit character while attempting to
;      convert an integer, check for trailing blanks or real.
;
|gtn08|beq|8,wb|18,=ch_bl|6,gtna9|; jump if a blank|21643
||beq|8,wb|18,=ch_ht|6,gtna9|; jump if horizontal tab|21645
||itr||||; else convert integer to real|21653
||ngr||||; negate to get positive value|21654
||brn|6,gtn12|||; jump to try for real|21655
;
;      here we scan out blanks to end of string
;
|gtn09|lch|8,wb|10,(xr)+||; get next char|21660
||beq|8,wb|18,=ch_ht|6,gtna9|; jump if horizontal tab|21662
||bne|8,wb|18,=ch_bl|6,gtn36|; error if non-blank|21667
|gtna9|bct|8,wa|6,gtn09||; loop back if more chars to check|21668
||brn|6,gtn07|||; return integer if all blanks|21669
;
;      loop to collect mantissa of real
;
|gtn10|lch|8,wb|10,(xr)+||; load next character|21675
||blt|8,wb|18,=ch_d0|6,gtn12|; jump if non-numeric|21676
||bgt|8,wb|18,=ch_d9|6,gtn12|; jump if non-numeric|21677
;
;      merge here to collect first real digit
;
|gtn11|sub|8,wb|18,=ch_d0||; convert digit to number|21681
||mlr|4,reavt|||; multiply real by 10.0|21682
||rov|6,gtn36|||; convert error if overflow|21683
||str|3,gtnsr|||; save result|21684
||mti|8,wb|||; get new digit as integer|21685
||itr||||; convert new digit to real|21686
||adr|3,gtnsr|||; add to get new total|21687
||add|3,gtnsc|3,gtndf||; increment scale if after dec point|21688
||mnz|3,gtnrd|||; set digit found flag|21689
||bct|8,wa|6,gtn10||; loop back if more chars|21690
||brn|6,gtn22|||; else jump to scale|21691
||ejc|||||21692
;
;      gtnum (continued)
;
;      here if non-digit found while collecting a real
;
|gtn12|bne|8,wb|18,=ch_dt|6,gtn13|; jump if not dec point|21698
||bnz|3,gtndf|6,gtn36||; if dec point, error if one already|21699
||mov|3,gtndf|18,=num01||; else set flag for dec point|21700
||bct|8,wa|6,gtn10||; loop back if more chars|21701
||brn|6,gtn22|||; else jump to scale|21702
;
;      here if not decimal point
;
|gtn13|beq|8,wb|18,=ch_le|6,gtn15|; jump if e for exponent|21706
||beq|8,wb|18,=ch_ld|6,gtn15|; jump if d for exponent|21707
||beq|8,wb|18,=ch_ue|6,gtn15|; jump if e for exponent|21709
||beq|8,wb|18,=ch_ud|6,gtn15|; jump if d for exponent|21710
;
;      here check for trailing blanks
;
|gtn14|beq|8,wb|18,=ch_bl|6,gtnb4|; jump if blank|21715
||beq|8,wb|18,=ch_ht|6,gtnb4|; jump if horizontal tab|21717
||brn|6,gtn36|||; error if non-blank|21722
;
|gtnb4|lch|8,wb|10,(xr)+||; get next character|21724
||bct|8,wa|6,gtn14||; loop back to check if more|21725
||brn|6,gtn22|||; else jump to scale|21726
;
;      here to read and process an exponent
;
|gtn15|zer|3,gtnes|||; set exponent sign positive|21730
||ldi|4,intv0|||; initialize exponent to zero|21731
||mnz|3,gtndf|||; reset no dec point indication|21732
||bct|8,wa|6,gtn16||; jump skipping past e or d|21733
||brn|6,gtn36|||; error if null exponent|21734
;
;      check for exponent sign
;
|gtn16|lch|8,wb|10,(xr)+||; load first exponent character|21738
||beq|8,wb|18,=ch_pl|6,gtn17|; jump if plus sign|21739
||bne|8,wb|18,=ch_mn|6,gtn19|; else jump if not minus sign|21740
||mnz|3,gtnes|||; set sign negative if minus sign|21741
;
;      merge here after processing exponent sign
;
|gtn17|bct|8,wa|6,gtn18||; jump if chars left|21745
||brn|6,gtn36|||; else error|21746
;
;      loop to convert exponent digits
;
|gtn18|lch|8,wb|10,(xr)+||; load next character|21750
||ejc|||||21751
;
;      gtnum (continued)
;
;      merge here for first exponent digit
;
|gtn19|blt|8,wb|18,=ch_d0|6,gtn20|; jump if not digit|21757
||bgt|8,wb|18,=ch_d9|6,gtn20|; jump if not digit|21758
||cvm|6,gtn36|||; else current*10, subtract new digit|21759
||bct|8,wa|6,gtn18||; loop back if more chars|21760
||brn|6,gtn21|||; jump if exponent field is exhausted|21761
;
;      here to check for trailing blanks after exponent
;
|gtn20|beq|8,wb|18,=ch_bl|6,gtnc0|; jump if blank|21765
||beq|8,wb|18,=ch_ht|6,gtnc0|; jump if horizontal tab|21767
||brn|6,gtn36|||; error if non-blank|21772
;
|gtnc0|lch|8,wb|10,(xr)+||; get next character|21774
||bct|8,wa|6,gtn20||; loop back till all blanks scanned|21775
;
;      merge here after collecting exponent
;
|gtn21|sti|3,gtnex|||; save collected exponent|21779
||bnz|3,gtnes|6,gtn22||; jump if it was negative|21780
||ngi||||; else complement|21781
||iov|6,gtn36|||; error if overflow|21782
||sti|3,gtnex|||; and store positive exponent|21783
;
;      merge here with exponent (0 if none given)
;
|gtn22|bze|3,gtnrd|6,gtn36||; error if not digits collected|21787
||bze|3,gtndf|6,gtn36||; error if no exponent or dec point|21788
||mti|3,gtnsc|||; else load scale as integer|21789
||sbi|3,gtnex|||; subtract exponent|21790
||iov|6,gtn36|||; error if overflow|21791
||ilt|6,gtn26|||; jump if we must scale up|21792
;
;      here we have a negative exponent, so scale down
;
||mfi|8,wa|6,gtn36||; load scale factor, err if ovflow|21796
;
;      loop to scale down in steps of 10**10
;
|gtn23|ble|8,wa|18,=num10|6,gtn24|; jump if 10 or less to go|21800
||dvr|4,reatt|||; else divide by 10**10|21801
||sub|8,wa|18,=num10||; decrement scale|21802
||brn|6,gtn23|||; and loop back|21803
||ejc|||||21804
;
;      gtnum (continued)
;
;      here scale rest of way from powers of ten table
;
|gtn24|bze|8,wa|6,gtn30||; jump if scaled|21810
||lct|8,wb|18,=cfp_r||; else get indexing factor|21811
||mov|7,xr|21,=reav1||; point to powers of ten table|21812
||wtb|8,wa|||; convert remaining scale to byte ofs|21813
;
;      loop to point to powers of ten table entry
;
|gtn25|add|7,xr|8,wa||; bump pointer|21817
||bct|8,wb|6,gtn25||; once for each value word|21818
||dvr|9,(xr)|||; scale down as required|21819
||brn|6,gtn30|||; and jump|21820
;
;      come here to scale result up (positive exponent)
;
|gtn26|ngi||||; get absolute value of exponent|21824
||iov|6,gtn36|||; error if overflow|21825
||mfi|8,wa|6,gtn36||; acquire scale, error if ovflow|21826
;
;      loop to scale up in steps of 10**10
;
|gtn27|ble|8,wa|18,=num10|6,gtn28|; jump if 10 or less to go|21830
||mlr|4,reatt|||; else multiply by 10**10|21831
||rov|6,gtn36|||; error if overflow|21832
||sub|8,wa|18,=num10||; else decrement scale|21833
||brn|6,gtn27|||; and loop back|21834
;
;      here to scale up rest of way with table
;
|gtn28|bze|8,wa|6,gtn30||; jump if scaled|21838
||lct|8,wb|18,=cfp_r||; else get indexing factor|21839
||mov|7,xr|21,=reav1||; point to powers of ten table|21840
||wtb|8,wa|||; convert remaining scale to byte ofs|21841
;
;      loop to point to proper entry in powers of ten table
;
|gtn29|add|7,xr|8,wa||; bump pointer|21845
||bct|8,wb|6,gtn29||; once for each word in value|21846
||mlr|9,(xr)|||; scale up|21847
||rov|6,gtn36|||; error if overflow|21848
||ejc|||||21849
;
;      gtnum (continued)
;
;      here with real value scaled and ready except for sign
;
|gtn30|bze|3,gtnnf|6,gtn31||; jump if positive|21855
||ngr||||; else negate|21856
;
;      here with properly signed real value in (ra)
;
|gtn31|jsr|6,rcbld|||; build real block|21860
||brn|6,gtn33|||; merge to exit|21861
;
;      here with properly signed integer value in (ia)
;
|gtn32|jsr|6,icbld|||; build icblk|21866
;
;      real merges here
;
|gtn33|mov|8,wa|9,(xr)||; load first word of result block|21870
||ica|7,xs|||; pop argument off stack|21871
;
;      common exit point
;
|gtn34|exi||||; return to gtnum caller|21875
;
;      come here if overflow occurs during collection of integer
;      have to restore wb which cvm may have destroyed.
;
|gtn35|lch|8,wb|11,-(xr)||; reload current character|21882
||lch|8,wb|10,(xr)+||; bump character pointer|21883
||ldi|3,gtnsi|||; reload integer so far|21884
||itr||||; convert to real|21885
||ngr||||; make value positive|21886
||brn|6,gtn11|||; merge with real circuit|21887
;
;      here for unconvertible to string or conversion error
;
|gtn36|mov|7,xr|10,(xs)+||; reload original argument|21892
||exi|1,1|||; take convert-error exit|21893
||enp||||; end procedure gtnum|21894
||ejc|||||21895
;
;      gtnvr -- convert to natural variable
;
;      gtnvr locates a variable block (vrblk) given either an
;      appropriate name (nmblk) or a non-null string (scblk).
;
;      (xr)		     argument
;      jsr  gtnvr	     call to convert to natural variable
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to vrblk
;      (wa,wb)		     destroyed (conversion error only)
;      (wc)		     destroyed
;
|gtnvr|prc|25,e|1,1||; entry point|21909
;z-
||bne|9,(xr)|22,=b_nml|6,gnv02|; jump if not name|21911
||mov|7,xr|13,nmbas(xr)||; else load name base if name|21912
||blo|7,xr|3,state|6,gnv07|; skip if vrblk (in static region)|21913
;
;      common error exit
;
|gnv01|exi|1,1|||; take convert-error exit|21917
;
;      here if not name
;
|gnv02|mov|3,gnvsa|8,wa||; save wa|21921
||mov|3,gnvsb|8,wb||; save wb|21922
||mov|11,-(xs)|7,xr||; stack argument for gtstg|21923
||jsr|6,gtstg|||; convert argument to string|21924
||ppm|6,gnv01|||; jump if conversion error|21925
||bze|8,wa|6,gnv01||; null string is an error|21926
||jsr|6,flstg|||; fold upper case to lower case|21928
||mov|11,-(xs)|7,xl||; save xl|21930
||mov|11,-(xs)|7,xr||; stack string ptr for later|21931
||mov|8,wb|7,xr||; copy string pointer|21932
||add|8,wb|19,*schar||; point to characters of string|21933
||mov|3,gnvst|8,wb||; save pointer to characters|21934
||mov|8,wb|8,wa||; copy length|21935
||ctw|8,wb|1,0||; get number of words in name|21936
||mov|3,gnvnw|8,wb||; save for later|21937
||jsr|6,hashs|||; compute hash index for string|21938
||rmi|3,hshnb|||; compute hash offset by taking mod|21939
||mfi|8,wc|||; get as offset|21940
||wtb|8,wc|||; convert offset to bytes|21941
||add|8,wc|3,hshtb||; point to proper hash chain|21942
||sub|8,wc|19,*vrnxt||; subtract offset to merge into loop|21943
||ejc|||||21944
;
;      gtnvr (continued)
;
;      loop to search hash chain
;
|gnv03|mov|7,xl|8,wc||; copy hash chain pointer|21950
||mov|7,xl|13,vrnxt(xl)||; point to next vrblk on chain|21951
||bze|7,xl|6,gnv08||; jump if end of chain|21952
||mov|8,wc|7,xl||; save pointer to this vrblk|21953
||bnz|13,vrlen(xl)|6,gnv04||; jump if not system variable|21954
||mov|7,xl|13,vrsvp(xl)||; else point to svblk|21955
||sub|7,xl|19,*vrsof||; adjust offset for merge|21956
;
;      merge here with string ptr (like vrblk) in xl
;
|gnv04|bne|8,wa|13,vrlen(xl)|6,gnv03|; back for next vrblk if lengths ne|21960
||add|7,xl|19,*vrchs||; else point to chars of chain entry|21961
||lct|8,wb|3,gnvnw||; get word counter to control loop|21962
||mov|7,xr|3,gnvst||; point to chars of new name|21963
;
;      loop to compare characters of the two names
;
|gnv05|cne|9,(xr)|9,(xl)|6,gnv03|; jump if no match for next vrblk|21967
||ica|7,xr|||; bump new name pointer|21968
||ica|7,xl|||; bump vrblk in chain name pointer|21969
||bct|8,wb|6,gnv05||; else loop till all compared|21970
||mov|7,xr|8,wc||; we have found a match, get vrblk|21971
;
;      exit point after finding vrblk or building new one
;
|gnv06|mov|8,wa|3,gnvsa||; restore wa|21975
||mov|8,wb|3,gnvsb||; restore wb|21976
||ica|7,xs|||; pop string pointer|21977
||mov|7,xl|10,(xs)+||; restore xl|21978
;
;      common exit point
;
|gnv07|exi||||; return to gtnvr caller|21982
;
;      not found, prepare to search system variable table
;
|gnv08|zer|7,xr|||; clear garbage xr pointer|21986
||mov|3,gnvhe|8,wc||; save ptr to end of hash chain|21987
||bgt|8,wa|18,=num09|6,gnv14|; cannot be system var if length gt 9|21988
||mov|7,xl|8,wa||; else copy length|21989
||wtb|7,xl|||; convert to byte offset|21990
||mov|7,xl|14,vsrch(xl)||; point to first svblk of this length|21991
||ejc|||||21992
;
;      gtnvr (continued)
;
;      loop to search entries in standard variable table
;
|gnv09|mov|3,gnvsp|7,xl||; save table pointer|21998
||mov|8,wc|10,(xl)+||; load svbit bit string|21999
||mov|8,wb|10,(xl)+||; load length from table entry|22000
||bne|8,wa|8,wb|6,gnv14|; jump if end of right length entries|22001
||lct|8,wb|3,gnvnw||; get word counter to control loop|22002
||mov|7,xr|3,gnvst||; point to chars of new name|22003
;
;      loop to check for matching names
;
|gnv10|cne|9,(xr)|9,(xl)|6,gnv11|; jump if name mismatch|22007
||ica|7,xr|||; else bump new name pointer|22008
||ica|7,xl|||; bump svblk pointer|22009
||bct|8,wb|6,gnv10||; else loop until all checked|22010
;
;      here we have a match in the standard variable table
;
||zer|8,wc|||; set vrlen value zero|22014
||mov|8,wa|19,*vrsi_||; set standard size|22015
||brn|6,gnv15|||; jump to build vrblk|22016
;
;      here if no match with table entry in svblks table
;
|gnv11|ica|7,xl|||; bump past word of chars|22020
||bct|8,wb|6,gnv11||; loop back if more to go|22021
||rsh|8,wc|2,svnbt||; remove uninteresting bits|22022
;
;      loop to bump table ptr for each flagged word
;
|gnv12|mov|8,wb|4,bits1||; load bit to test|22026
||anb|8,wb|8,wc||; test for word present|22027
||zrb|8,wb|6,gnv13||; jump if not present|22028
||ica|7,xl|||; else bump table pointer|22029
;
;      here after dealing with one word (one bit)
;
|gnv13|rsh|8,wc|1,1||; remove bit already processed|22033
||nzb|8,wc|6,gnv12||; loop back if more bits to test|22034
||brn|6,gnv09|||; else loop back for next svblk|22035
;
;      here if not system variable
;
|gnv14|mov|8,wc|8,wa||; copy vrlen value|22039
||mov|8,wa|18,=vrchs||; load standard size -chars|22040
||add|8,wa|3,gnvnw||; adjust for chars of name|22041
||wtb|8,wa|||; convert length to bytes|22042
||ejc|||||22043
;
;      gtnvr (continued)
;
;      merge here to build vrblk
;
|gnv15|jsr|6,alost|||; allocate space for vrblk (static)|22049
||mov|8,wb|7,xr||; save vrblk pointer|22050
||mov|7,xl|21,=stnvr||; point to model variable block|22051
||mov|8,wa|19,*vrlen||; set length of standard fields|22052
||mvw||||; set initial fields of new block|22053
||mov|7,xl|3,gnvhe||; load pointer to end of hash chain|22054
||mov|13,vrnxt(xl)|8,wb||; add new block to end of chain|22055
||mov|10,(xr)+|8,wc||; set vrlen field, bump ptr|22056
||mov|8,wa|3,gnvnw||; get length in words|22057
||wtb|8,wa|||; convert to length in bytes|22058
||bze|8,wc|6,gnv16||; jump if system variable|22059
;
;      here for non-system variable -- set chars of name
;
||mov|7,xl|9,(xs)||; point back to string name|22063
||add|7,xl|19,*schar||; point to chars of name|22064
||mvw||||; move characters into place|22065
||mov|7,xr|8,wb||; restore vrblk pointer|22066
||brn|6,gnv06|||; jump back to exit|22067
;
;      here for system variable case to fill in fields where
;      necessary from the fields present in the svblk.
;
|gnv16|mov|7,xl|3,gnvsp||; load pointer to svblk|22072
||mov|9,(xr)|7,xl||; set svblk ptr in vrblk|22073
||mov|7,xr|8,wb||; restore vrblk pointer|22074
||mov|8,wb|13,svbit(xl)||; load bit indicators|22075
||add|7,xl|19,*svchs||; point to characters of name|22076
||add|7,xl|8,wa||; point past characters|22077
;
;      skip past keyword number (svknm) if present
;
||mov|8,wc|4,btknm||; load test bit|22081
||anb|8,wc|8,wb||; and to test|22082
||zrb|8,wc|6,gnv17||; jump if no keyword number|22083
||ica|7,xl|||; else bump pointer|22084
||ejc|||||22085
;
;      gtnvr (continued)
;
;      here test for function (svfnc and svnar)
;
|gnv17|mov|8,wc|4,btfnc||; get test bit|22091
||anb|8,wc|8,wb||; and to test|22092
||zrb|8,wc|6,gnv18||; skip if no system function|22093
||mov|13,vrfnc(xr)|7,xl||; else point vrfnc to svfnc field|22094
||add|7,xl|19,*num02||; and bump past svfnc, svnar fields|22095
;
;      now test for label (svlbl)
;
|gnv18|mov|8,wc|4,btlbl||; get test bit|22099
||anb|8,wc|8,wb||; and to test|22100
||zrb|8,wc|6,gnv19||; jump if bit is off (no system labl)|22101
||mov|13,vrlbl(xr)|7,xl||; else point vrlbl to svlbl field|22102
||ica|7,xl|||; bump past svlbl field|22103
;
;      now test for value (svval)
;
|gnv19|mov|8,wc|4,btval||; load test bit|22107
||anb|8,wc|8,wb||; and to test|22108
||zrb|8,wc|6,gnv06||; all done if no value|22109
||mov|13,vrval(xr)|9,(xl)||; else set initial value|22110
||mov|13,vrsto(xr)|22,=b_vre||; set error store access|22111
||brn|6,gnv06|||; merge back to exit to caller|22112
||enp||||; end procedure gtnvr|22113
||ejc|||||22114
;
;      gtpat -- get pattern
;
;      gtpat is passed an object in (xr) and returns a
;      pattern after performing any necessary conversions
;
;      (xr)		     input argument
;      jsr  gtpat	     call to convert to pattern
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     resulting pattern
;      (wa)		     destroyed
;      (wb)		     destroyed (only on convert error)
;      (xr)		     unchanged (only on convert error)
;
|gtpat|prc|25,e|1,1||; entry point|22129
;z+
||bhi|9,(xr)|22,=p_aaa|6,gtpt5|; jump if pattern already|22131
;
;      here if not pattern, try for string
;
||mov|3,gtpsb|8,wb||; save wb|22135
||mov|11,-(xs)|7,xr||; stack argument for gtstg|22136
||jsr|6,gtstg|||; convert argument to string|22137
||ppm|6,gtpt2|||; jump if impossible|22138
;
;      here we have a string
;
||bnz|8,wa|6,gtpt1||; jump if non-null|22142
;
;      here for null string. generate pointer to null pattern.
;
||mov|7,xr|21,=ndnth||; point to nothen node|22146
||brn|6,gtpt4|||; jump to exit|22147
||ejc|||||22148
;
;      gtpat (continued)
;
;      here for non-null string
;
|gtpt1|mov|8,wb|22,=p_str||; load pcode for multi-char string|22154
||bne|8,wa|18,=num01|6,gtpt3|; jump if multi-char string|22155
;
;      here for one character string, share one character any
;
||plc|7,xr|||; point to character|22159
||lch|8,wa|9,(xr)||; load character|22160
||mov|7,xr|8,wa||; set as parm1|22161
||mov|8,wb|22,=p_ans||; point to pcode for 1-char any|22162
||brn|6,gtpt3|||; jump to build node|22163
;
;      here if argument is not convertible to string
;
|gtpt2|mov|8,wb|22,=p_exa||; set pcode for expression in case|22167
||blo|9,(xr)|22,=b_e__|6,gtpt3|; jump to build node if expression|22168
;
;      here we have an error (conversion impossible)
;
||exi|1,1|||; take convert error exit|22172
;
;      merge here to build node for string or expression
;
|gtpt3|jsr|6,pbild|||; call routine to build pattern node|22176
;
;      common exit after successful conversion
;
|gtpt4|mov|8,wb|3,gtpsb||; restore wb|22180
;
;      merge here to exit if no conversion required
;
|gtpt5|exi||||; return to gtpat caller|22184
||enp||||; end procedure gtpat|22185
||ejc|||||22188
;
;      gtrea -- get real value
;
;      gtrea is passed an object and returns a real value
;      performing any necessary conversions.
;
;      (xr)		     object to be converted
;      jsr  gtrea	     call to convert object to real
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to resulting real
;      (wa,wb,wc,ra)	     destroyed
;      (xr)		     unchanged (convert error only)
;
|gtrea|prc|25,e|1,1||; entry point|22202
||mov|8,wa|9,(xr)||; get first word of block|22203
||beq|8,wa|22,=b_rcl|6,gtre2|; jump if real|22204
||jsr|6,gtnum|||; else convert argument to numeric|22205
||ppm|6,gtre3|||; jump if unconvertible|22206
||beq|8,wa|22,=b_rcl|6,gtre2|; jump if real was returned|22207
;
;      here for case of an integer to convert to real
;
|gtre1|ldi|13,icval(xr)|||; load integer|22211
||itr||||; convert to real|22212
||jsr|6,rcbld|||; build rcblk|22213
;
;      exit with real
;
|gtre2|exi||||; return to gtrea caller|22217
;
;      here on conversion error
;
|gtre3|exi|1,1|||; take convert error exit|22221
||enp||||; end procedure gtrea|22222
||ejc|||||22224
;
;      gtsmi -- get small integer
;
;      gtsmi is passed a snobol object and returns an address
;      integer in the range (0 le n le dnamb). such a value can
;      only be derived from an integer in the appropriate range.
;      small integers never appear as snobol values. however,
;      they are used internally for a variety of purposes.
;
;      -(xs)		     argument to convert (on stack)
;      jsr  gtsmi	     call to convert to small integer
;      ppm  loc		     transfer loc for not integer
;      ppm  loc		     transfer loc for lt 0, gt dnamb
;      (xr,wc)		     resulting small int (two copies)
;      (xs)		     popped
;      (ra)		     destroyed
;      (wa,wb)		     destroyed (on convert error only)
;      (xr)		     input arg (convert error only)
;
|gtsmi|prc|25,n|1,2||; entry point|22244
||mov|7,xr|10,(xs)+||; load argument|22245
||beq|9,(xr)|22,=b_icl|6,gtsm1|; skip if already an integer|22246
;
;      here if not an integer
;
||jsr|6,gtint|||; convert argument to integer|22250
||ppm|6,gtsm2|||; jump if convert is impossible|22251
;
;      merge here with integer
;
|gtsm1|ldi|13,icval(xr)|||; load integer value|22255
||mfi|8,wc|6,gtsm3||; move as one word, jump if ovflow|22256
||bgt|8,wc|3,mxlen|6,gtsm3|; or if too large|22257
||mov|7,xr|8,wc||; copy result to xr|22258
||exi||||; return to gtsmi caller|22259
;
;      here if unconvertible to integer
;
|gtsm2|exi|1,1|||; take non-integer error exit|22263
;
;      here if out of range
;
|gtsm3|exi|1,2|||; take out-of-range error exit|22267
||enp||||; end procedure gtsmi|22268
||ejc|||||22269
;
;      gtstg -- get string
;
;      gtstg is passed an object and returns a string with
;      any necessary conversions performed.
;
;      -(xs)		     input argument (on stack)
;      jsr  gtstg	     call to convert to string
;      ppm  loc		     transfer loc if convert impossible
;      (xr)		     pointer to resulting string
;      (wa)		     length of string in characters
;      (xs)		     popped
;      (ra)		     destroyed
;      (xr)		     input arg (convert error only)
;
|gtstg|prc|25,n|1,1||; entry point|22335
||mov|7,xr|10,(xs)+||; load argument, pop stack|22336
||beq|9,(xr)|22,=b_scl|6,gts30|; jump if already a string|22337
;
;      here if not a string already
;
|gts01|mov|11,-(xs)|7,xr||; restack argument in case error|22341
||mov|11,-(xs)|7,xl||; save xl|22342
||mov|3,gtsvb|8,wb||; save wb|22343
||mov|3,gtsvc|8,wc||; save wc|22344
||mov|8,wa|9,(xr)||; load first word of block|22345
||beq|8,wa|22,=b_icl|6,gts05|; jump to convert integer|22346
||beq|8,wa|22,=b_rcl|6,gts10|; jump to convert real|22349
||beq|8,wa|22,=b_nml|6,gts03|; jump to convert name|22351
;
;      here on conversion error
;
|gts02|mov|7,xl|10,(xs)+||; restore xl|22359
||mov|7,xr|10,(xs)+||; reload input argument|22360
||exi|1,1|||; take convert error exit|22361
||ejc|||||22362
;
;      gtstg (continued)
;
;      here to convert a name (only possible if natural var)
;
|gts03|mov|7,xl|13,nmbas(xr)||; load name base|22368
||bhi|7,xl|3,state|6,gts02|; error if not natural var (static)|22369
||add|7,xl|19,*vrsof||; else point to possible string name|22370
||mov|8,wa|13,sclen(xl)||; load length|22371
||bnz|8,wa|6,gts04||; jump if not system variable|22372
||mov|7,xl|13,vrsvo(xl)||; else point to svblk|22373
||mov|8,wa|13,svlen(xl)||; and load name length|22374
;
;      merge here with string in xr, length in wa
;
|gts04|zer|8,wb|||; set offset to zero|22378
||jsr|6,sbstr|||; use sbstr to copy string|22379
||brn|6,gts29|||; jump to exit|22380
;
;      come here to convert an integer
;
|gts05|ldi|13,icval(xr)|||; load integer value|22384
||mov|3,gtssf|18,=num01||; set sign flag negative|22392
||ilt|6,gts06|||; skip if integer is negative|22393
||ngi||||; else negate integer|22394
||zer|3,gtssf|||; and reset negative flag|22395
||ejc|||||22396
;
;      gtstg (continued)
;
;      here with sign flag set and sign forced negative as
;      required by the cvd instruction.
;
|gts06|mov|7,xr|3,gtswk||; point to result work area|22403
||mov|8,wb|18,=nstmx||; initialize counter to max length|22404
||psc|7,xr|8,wb||; prepare to store (right-left)|22405
;
;      loop to convert digits into work area
;
|gts07|cvd||||; convert one digit into wa|22409
||sch|8,wa|11,-(xr)||; store in work area|22410
||dcv|8,wb|||; decrement counter|22411
||ine|6,gts07|||; loop if more digits to go|22412
||csc|7,xr|||; complete store characters|22413
;
;      merge here after converting integer or real into work
;      area. wb is set to nstmx - (number of chars in result).
;
|gts08|mov|8,wa|18,=nstmx||; get max number of characters|22419
||sub|8,wa|8,wb||; compute length of result|22420
||mov|7,xl|8,wa||; remember length for move later on|22421
||add|8,wa|3,gtssf||; add one for negative sign if needed|22422
||jsr|6,alocs|||; allocate string for result|22423
||mov|8,wc|7,xr||; save result pointer for the moment|22424
||psc|7,xr|||; point to chars of result block|22425
||bze|3,gtssf|6,gts09||; skip if positive|22426
||mov|8,wa|18,=ch_mn||; else load negative sign|22427
||sch|8,wa|10,(xr)+||; and store it|22428
||csc|7,xr|||; complete store characters|22429
;
;      here after dealing with sign
;
|gts09|mov|8,wa|7,xl||; recall length to move|22433
||mov|7,xl|3,gtswk||; point to result work area|22434
||plc|7,xl|8,wb||; point to first result character|22435
||mvc||||; move chars to result string|22436
||mov|7,xr|8,wc||; restore result pointer|22437
||brn|6,gts29|||; jump to exit|22440
||ejc|||||22441
;
;      gtstg (continued)
;
;      here to convert a real
;
|gts10|ldr|13,rcval(xr)|||; load real|22447
||zer|3,gtssf|||; reset negative flag|22459
||req|6,gts31|||; skip if zero|22460
||rge|6,gts11|||; jump if real is positive|22461
||mov|3,gtssf|18,=num01||; else set negative flag|22462
||ngr||||; and get absolute value of real|22463
;
;      now scale the real to the range (0.1 le x lt 1.0)
;
|gts11|ldi|4,intv0|||; initialize exponent to zero|22467
;
;      loop to scale up in steps of 10**10
;
|gts12|str|3,gtsrs|||; save real value|22471
||sbr|4,reap1|||; subtract 0.1 to compare|22472
||rge|6,gts13|||; jump if scale up not required|22473
||ldr|3,gtsrs|||; else reload value|22474
||mlr|4,reatt|||; multiply by 10**10|22475
||sbi|4,intvt|||; decrement exponent by 10|22476
||brn|6,gts12|||; loop back to test again|22477
;
;      test for scale down required
;
|gts13|ldr|3,gtsrs|||; reload value|22481
||sbr|4,reav1|||; subtract 1.0|22482
||rlt|6,gts17|||; jump if no scale down required|22483
||ldr|3,gtsrs|||; else reload value|22484
;
;      loop to scale down in steps of 10**10
;
|gts14|sbr|4,reatt|||; subtract 10**10 to compare|22488
||rlt|6,gts15|||; jump if large step not required|22489
||ldr|3,gtsrs|||; else restore value|22490
||dvr|4,reatt|||; divide by 10**10|22491
||str|3,gtsrs|||; store new value|22492
||adi|4,intvt|||; increment exponent by 10|22493
||brn|6,gts14|||; loop back|22494
||ejc|||||22495
;
;      gtstg (continued)
;
;      at this point we have (1.0 le x lt 10**10)
;      complete scaling with powers of ten table
;
|gts15|mov|7,xr|21,=reav1||; point to powers of ten table|22502
;
;      loop to locate correct entry in table
;
|gts16|ldr|3,gtsrs|||; reload value|22506
||adi|4,intv1|||; increment exponent|22507
||add|7,xr|19,*cfp_r||; point to next entry in table|22508
||sbr|9,(xr)|||; subtract it to compare|22509
||rge|6,gts16|||; loop till we find a larger entry|22510
||ldr|3,gtsrs|||; then reload the value|22511
||dvr|9,(xr)|||; and complete scaling|22512
||str|3,gtsrs|||; store value|22513
;
;      we are now scaled, so round by adding 0.5 * 10**(-cfp_s)
;
|gts17|ldr|3,gtsrs|||; get value again|22517
||adr|3,gtsrn|||; add rounding factor|22518
||str|3,gtsrs|||; store result|22519
;
;      the rounding operation may have pushed us up past
;      1.0 again, so check one more time.
;
||sbr|4,reav1|||; subtract 1.0 to compare|22524
||rlt|6,gts18|||; skip if ok|22525
||adi|4,intv1|||; else increment exponent|22526
||ldr|3,gtsrs|||; reload value|22527
||dvr|4,reavt|||; divide by 10.0 to rescale|22528
||brn|6,gts19|||; jump to merge|22529
;
;      here if rounding did not muck up scaling
;
|gts18|ldr|3,gtsrs|||; reload rounded value|22533
||ejc|||||22534
;
;      gtstg (continued)
;
;      now we have completed the scaling as follows
;
;      (ia)		     signed exponent
;      (ra)		     scaled real (absolute value)
;
;      if the exponent is negative or greater than cfp_s, then
;      we convert the number in the form.
;
;      (neg sign) 0 . (cpf_s digits) e (exp sign) (exp digits)
;
;      if the exponent is positive and less than or equal to
;      cfp_s, the number is converted in the form.
;
;      (neg sign) (exponent digits) . (cfp_s-exponent digits)
;
;      in both cases, the formats obtained from the above
;      rules are modified by deleting trailing zeros after the
;      decimal point. there are no leading zeros in the exponent
;      and the exponent sign is always present.
;
|gts19|mov|7,xl|18,=cfp_s||; set num dec digits = cfp_s|22558
||mov|3,gtses|18,=ch_mn||; set exponent sign negative|22559
||ilt|6,gts21|||; all set if exponent is negative|22560
||mfi|8,wa|||; else fetch exponent|22561
||ble|8,wa|18,=cfp_s|6,gts20|; skip if we can use special format|22562
||mti|8,wa|||; else restore exponent|22563
||ngi||||; set negative for cvd|22564
||mov|3,gtses|18,=ch_pl||; set plus sign for exponent sign|22565
||brn|6,gts21|||; jump to generate exponent|22566
;
;      here if we can use the format without an exponent
;
|gts20|sub|7,xl|8,wa||; compute digits after decimal point|22570
||ldi|4,intv0|||; reset exponent to zero|22571
||ejc|||||22572
;
;      gtstg (continued)
;
;      merge here as follows
;
;      (ia)		     exponent absolute value
;      gtses		     character for exponent sign
;      (ra)		     positive fraction
;      (xl)		     number of digits after dec point
;
|gts21|mov|7,xr|3,gtswk||; point to work area|22583
||mov|8,wb|18,=nstmx||; set character ctr to max length|22584
||psc|7,xr|8,wb||; prepare to store (right to left)|22585
||ieq|6,gts23|||; skip exponent if it is zero|22586
;
;      loop to generate digits of exponent
;
|gts22|cvd||||; convert a digit into wa|22590
||sch|8,wa|11,-(xr)||; store in work area|22591
||dcv|8,wb|||; decrement counter|22592
||ine|6,gts22|||; loop back if more digits to go|22593
;
;      here generate exponent sign and e
;
||mov|8,wa|3,gtses||; load exponent sign|22597
||sch|8,wa|11,-(xr)||; store in work area|22598
||mov|8,wa|18,=ch_le||; get character letter e|22599
||sch|8,wa|11,-(xr)||; store in work area|22600
||sub|8,wb|18,=num02||; decrement counter for sign and e|22601
;
;      here to generate the fraction
;
|gts23|mlr|3,gtssc|||; convert real to integer (10**cfp_s)|22605
||rti||||; get integer (overflow impossible)|22606
||ngi||||; negate as required by cvd|22607
;
;      loop to suppress trailing zeros
;
|gts24|bze|7,xl|6,gts27||; jump if no digits left to do|22611
||cvd||||; else convert one digit|22612
||bne|8,wa|18,=ch_d0|6,gts26|; jump if not a zero|22613
||dcv|7,xl|||; decrement counter|22614
||brn|6,gts24|||; loop back for next digit|22615
||ejc|||||22616
;
;      gtstg (continued)
;
;      loop to generate digits after decimal point
;
|gts25|cvd||||; convert a digit into wa|22622
;
;      merge here first time
;
|gts26|sch|8,wa|11,-(xr)||; store digit|22626
||dcv|8,wb|||; decrement counter|22627
||dcv|7,xl|||; decrement counter|22628
||bnz|7,xl|6,gts25||; loop back if more to go|22629
;
;      here generate the decimal point
;
|gts27|mov|8,wa|18,=ch_dt||; load decimal point|22633
||sch|8,wa|11,-(xr)||; store in work area|22634
||dcv|8,wb|||; decrement counter|22635
;
;      here generate the digits before the decimal point
;
|gts28|cvd||||; convert a digit into wa|22639
||sch|8,wa|11,-(xr)||; store in work area|22640
||dcv|8,wb|||; decrement counter|22641
||ine|6,gts28|||; loop back if more to go|22642
||csc|7,xr|||; complete store characters|22643
||brn|6,gts08|||; else jump back to exit|22644
;
;      exit point after successful conversion
;
|gts29|mov|7,xl|10,(xs)+||; restore xl|22650
||ica|7,xs|||; pop argument|22651
||mov|8,wb|3,gtsvb||; restore wb|22652
||mov|8,wc|3,gtsvc||; restore wc|22653
;
;      merge here if no conversion required
;
|gts30|mov|8,wa|13,sclen(xr)||; load string length|22657
||exi||||; return to caller|22658
;
;      here to return string for real zero
;
|gts31|mov|7,xl|21,=scre0||; point to string|22664
||mov|8,wa|18,=num02||; 2 chars|22665
||zer|8,wb|||; zero offset|22666
||jsr|6,sbstr|||; copy string|22667
||brn|6,gts29|||; return|22668
||enp||||; end procedure gtstg|22695
||ejc|||||22696
;
;      gtvar -- get variable for i/o/trace association
;
;      gtvar is used to point to an actual variable location
;      for the detach,input,output,trace,stoptr system functions
;
;      (xr)		     argument to function
;      jsr  gtvar	     call to locate variable pointer
;      ppm  loc		     transfer loc if not ok variable
;      (xl,wa)		     name base,offset of variable
;      (xr,ra)		     destroyed
;      (wb,wc)		     destroyed (convert error only)
;      (xr)		     input arg (convert error only)
;
|gtvar|prc|25,e|1,1||; entry point|22711
||bne|9,(xr)|22,=b_nml|6,gtvr2|; jump if not a name|22712
||mov|8,wa|13,nmofs(xr)||; else load name offset|22713
||mov|7,xl|13,nmbas(xr)||; load name base|22714
||beq|9,(xl)|22,=b_evt|6,gtvr1|; error if expression variable|22715
||bne|9,(xl)|22,=b_kvt|6,gtvr3|; all ok if not keyword variable|22716
;
;      here on conversion error
;
|gtvr1|exi|1,1|||; take convert error exit|22720
;
;      here if not a name, try convert to natural variable
;
|gtvr2|mov|3,gtvrc|8,wc||; save wc|22724
||jsr|6,gtnvr|||; locate vrblk if possible|22725
||ppm|6,gtvr1|||; jump if convert error|22726
||mov|7,xl|7,xr||; else copy vrblk name base|22727
||mov|8,wa|19,*vrval||; and set offset|22728
||mov|8,wc|3,gtvrc||; restore wc|22729
;
;      here for name obtained
;
|gtvr3|bhi|7,xl|3,state|6,gtvr4|; all ok if not natural variable|22733
||beq|13,vrsto(xl)|22,=b_vre|6,gtvr1|; error if protected variable|22734
;
;      common exit point
;
|gtvr4|exi||||; return to caller|22738
||enp||||; end procedure gtvar|22739
||ejc|||||22740
||ejc|||||22741
;
;      hashs -- compute hash index for string
;
;      hashs is used to convert a string to a unique integer
;      value. the resulting hash value is a positive integer
;      in the range 0 to cfp_m
;
;      (xr)		     string to be hashed
;      jsr  hashs	     call to hash string
;      (ia)		     hash value
;      (xr,wb,wc)	     destroyed
;
;      the hash function used is as follows.
;
;      start with the length of the string.
;
;      if there is more than one character in a word,
;      take the first e_hnw words of the characters from
;      the string or all the words if fewer than e_hnw.
;
;      compute the exclusive or of all these words treating
;      them as one word bit string values.
;
;      if there is just one character in a word,
;      then mimic the word by word hash by shifting
;      successive characters to get a similar effect.
;
;      e_hnw is set to zero in case only one character per word.
;
;      move the result as an integer with the mti instruction.
;
;      the test on e_hnw is done dynamically. this should be done
;      eventually using conditional assembly, but that would require
;      changes to the build process (ds 8 may 2013).
;
|hashs|prc|25,e|1,0||; entry point|22777
;z-
||mov|8,wc|18,=e_hnw||; get number of words to use|22779
||bze|8,wc|6,hshsa||; branch if one character per word|22780
||mov|8,wc|13,sclen(xr)||; load string length in characters|22781
||mov|8,wb|8,wc||; initialize with length|22782
||bze|8,wc|6,hshs3||; jump if null string|22783
||zgb|8,wb|||; correct byte ordering if necessary|22784
||ctw|8,wc|1,0||; get number of words of chars|22785
||add|7,xr|19,*schar||; point to characters of string|22786
||blo|8,wc|18,=e_hnw|6,hshs1|; use whole string if short|22787
||mov|8,wc|18,=e_hnw||; else set to involve first e_hnw wds|22788
;
;      here with count of words to check in wc
;
|hshs1|lct|8,wc|8,wc||; set counter to control loop|22792
;
;      loop to compute exclusive or
;
|hshs2|xob|8,wb|10,(xr)+||; exclusive or next word of chars|22796
||bct|8,wc|6,hshs2||; loop till all processed|22797
;
;      merge here with exclusive or in wb
;
|hshs3|zgb|8,wb|||; zeroise undefined bits|22801
||anb|8,wb|4,bitsm||; ensure in range 0 to cfp_m|22802
||mti|8,wb|||; move result as integer|22803
||zer|7,xr|||; clear garbage value in xr|22804
||exi||||; return to hashs caller|22805
;
;      here if just one character per word
;
|hshsa|mov|8,wc|13,sclen(xr)||; load string length in characters|22809
||mov|8,wb|8,wc||; initialize with length|22810
||bze|8,wc|6,hshs3||; jump if null string|22811
||zgb|8,wb|||; correct byte ordering if necessary|22812
||ctw|8,wc|1,0||; get number of words of chars|22813
||plc|7,xr|||;|22814
||mov|11,-(xs)|7,xl||; save xl|22815
||mov|7,xl|8,wc||; load length for branch|22816
||bge|7,xl|18,=num25|6,hsh24|; use first characters if longer|22817
||bsw|7,xl|1,25||; merge to compute hash|22818
||iff|1,0|6,hsh00||;|22844
||iff|1,1|6,hsh01||;|22844
||iff|1,2|6,hsh02||;|22844
||iff|1,3|6,hsh03||;|22844
||iff|1,4|6,hsh04||;|22844
||iff|1,5|6,hsh05||;|22844
||iff|1,6|6,hsh06||;|22844
||iff|1,7|6,hsh07||;|22844
||iff|1,8|6,hsh08||;|22844
||iff|1,9|6,hsh09||;|22844
||iff|1,10|6,hsh10||;|22844
||iff|1,11|6,hsh11||;|22844
||iff|1,12|6,hsh12||;|22844
||iff|1,13|6,hsh13||;|22844
||iff|1,14|6,hsh14||;|22844
||iff|1,15|6,hsh15||;|22844
||iff|1,16|6,hsh16||;|22844
||iff|1,17|6,hsh17||;|22844
||iff|1,18|6,hsh18||;|22844
||iff|1,19|6,hsh19||;|22844
||iff|1,20|6,hsh20||;|22844
||iff|1,21|6,hsh21||;|22844
||iff|1,22|6,hsh22||;|22844
||iff|1,23|6,hsh23||;|22844
||iff|1,24|6,hsh24||;|22844
||esw|||||22844
|hsh24|lch|8,wc|10,(xr)+||; load next character|22845
||lsh|8,wc|1,24||; shift for hash|22846
||xob|8,wb|8,wc||; hash character|22847
|hsh23|lch|8,wc|10,(xr)+||; load next character|22848
||lsh|8,wc|1,16||; shift for hash|22849
||xob|8,wb|8,wc||; hash character|22850
|hsh22|lch|8,wc|10,(xr)+||; load next character|22851
||lsh|8,wc|1,8||; shift for hash|22852
||xob|8,wb|8,wc||; hash character|22853
|hsh21|lch|8,wc|10,(xr)+||; load next character|22854
||xob|8,wb|8,wc||; hash character|22855
|hsh20|lch|8,wc|10,(xr)+||; load next character|22856
||lsh|8,wc|1,24||; shift for hash|22857
||xob|8,wb|8,wc||; hash character|22858
|hsh19|lch|8,wc|10,(xr)+||; load next character|22859
||lsh|8,wc|1,16||; shift for hash|22860
||xob|8,wb|8,wc||; hash character|22861
|hsh18|lch|8,wc|10,(xr)+||; load next character|22862
||lsh|8,wc|1,8||; shift for hash|22863
||xob|8,wb|8,wc||; hash character|22864
|hsh17|lch|8,wc|10,(xr)+||; load next character|22865
||xob|8,wb|8,wc||; hash character|22866
|hsh16|lch|8,wc|10,(xr)+||; load next character|22867
||lsh|8,wc|1,24||; shift for hash|22868
||xob|8,wb|8,wc||; hash character|22869
|hsh15|lch|8,wc|10,(xr)+||; load next character|22870
||lsh|8,wc|1,16||; shift for hash|22871
||xob|8,wb|8,wc||; hash character|22872
|hsh14|lch|8,wc|10,(xr)+||; load next character|22873
||lsh|8,wc|1,8||; shift for hash|22874
||xob|8,wb|8,wc||; hash character|22875
|hsh13|lch|8,wc|10,(xr)+||; load next character|22876
||xob|8,wb|8,wc||; hash character|22877
|hsh12|lch|8,wc|10,(xr)+||; load next character|22878
||lsh|8,wc|1,24||; shift for hash|22879
||xob|8,wb|8,wc||; hash character|22880
|hsh11|lch|8,wc|10,(xr)+||; load next character|22881
||lsh|8,wc|1,16||; shift for hash|22882
||xob|8,wb|8,wc||; hash character|22883
|hsh10|lch|8,wc|10,(xr)+||; load next character|22884
||lsh|8,wc|1,8||; shift for hash|22885
||xob|8,wb|8,wc||; hash character|22886
|hsh09|lch|8,wc|10,(xr)+||; load next character|22887
||xob|8,wb|8,wc||; hash character|22888
|hsh08|lch|8,wc|10,(xr)+||; load next character|22889
||lsh|8,wc|1,24||; shift for hash|22890
||xob|8,wb|8,wc||; hash character|22891
|hsh07|lch|8,wc|10,(xr)+||; load next character|22892
||lsh|8,wc|1,16||; shift for hash|22893
||xob|8,wb|8,wc||; hash character|22894
|hsh06|lch|8,wc|10,(xr)+||; load next character|22895
||lsh|8,wc|1,8||; shift for hash|22896
||xob|8,wb|8,wc||; hash character|22897
|hsh05|lch|8,wc|10,(xr)+||; load next character|22898
||xob|8,wb|8,wc||; hash character|22899
|hsh04|lch|8,wc|10,(xr)+||; load next character|22900
||lsh|8,wc|1,24||; shift for hash|22901
||xob|8,wb|8,wc||; hash character|22902
|hsh03|lch|8,wc|10,(xr)+||; load next character|22903
||lsh|8,wc|1,16||; shift for hash|22904
||xob|8,wb|8,wc||; hash character|22905
|hsh02|lch|8,wc|10,(xr)+||; load next character|22906
||lsh|8,wc|1,8||; shift for hash|22907
||xob|8,wb|8,wc||; hash character|22908
|hsh01|lch|8,wc|10,(xr)+||; load next character|22909
||xob|8,wb|8,wc||; hash character|22910
|hsh00|mov|7,xl|10,(xs)+||; restore xl|22911
||brn|6,hshs3|||; merge to complete hash|22912
||enp||||; end procedure hashs|22913
;
;      icbld -- build integer block
;
;      (ia)		     integer value for icblk
;      jsr  icbld	     call to build integer block
;      (xr)		     pointer to result icblk
;      (wa)		     destroyed
;
|icbld|prc|25,e|1,0||; entry point|22922
;z+
||mfi|7,xr|6,icbl1||; copy small integers|22924
||ble|7,xr|18,=num02|6,icbl3|; jump if 0,1 or 2|22925
;
;      construct icblk
;
|icbl1|mov|7,xr|3,dnamp||; load pointer to next available loc|22929
||add|7,xr|19,*icsi_||; point past new icblk|22930
||blo|7,xr|3,dname|6,icbl2|; jump if there is room|22931
||mov|8,wa|19,*icsi_||; else load length of icblk|22932
||jsr|6,alloc|||; use standard allocator to get block|22933
||add|7,xr|8,wa||; point past block to merge|22934
;
;      merge here with xr pointing past the block obtained
;
|icbl2|mov|3,dnamp|7,xr||; set new pointer|22938
||sub|7,xr|19,*icsi_||; point back to start of block|22939
||mov|9,(xr)|22,=b_icl||; store type word|22940
||sti|13,icval(xr)|||; store integer value in icblk|22941
||exi||||; return to icbld caller|22942
;
;      optimise by not building icblks for small integers
;
|icbl3|wtb|7,xr|||; convert integer to offset|22946
||mov|7,xr|14,intab(xr)||; point to pre-built icblk|22947
||exi||||; return|22948
||enp||||; end procedure icbld|22949
||ejc|||||22950
;
;      ident -- compare two values
;
;      ident compares two values in the sense of the ident
;      differ functions available at the snobol level.
;
;      (xr)		     first argument
;      (xl)		     second argument
;      jsr  ident	     call to compare arguments
;      ppm  loc		     transfer loc if ident
;      (normal return if differ)
;      (xr,xl,wc,ra)	     destroyed
;
|ident|prc|25,e|1,1||; entry point|22964
||beq|7,xr|7,xl|6,iden7|; jump if same pointer (ident)|22965
||mov|8,wc|9,(xr)||; else load arg 1 type word|22966
||bne|8,wc|9,(xl)|6,iden1|; differ if arg 2 type word differ|22968
||beq|8,wc|22,=b_scl|6,iden2|; jump if strings|22972
||beq|8,wc|22,=b_icl|6,iden4|; jump if integers|22973
||beq|8,wc|22,=b_rcl|6,iden5|; jump if reals|22976
||beq|8,wc|22,=b_nml|6,iden6|; jump if names|22978
;
;      for all other datatypes, must be differ if xr ne xl
;
;      merge here for differ
;
|iden1|exi||||; take differ exit|23021
;
;      here for strings, ident only if lengths and chars same
;
|iden2|mov|8,wc|13,sclen(xr)||; load arg 1 length|23025
||bne|8,wc|13,sclen(xl)|6,iden1|; differ if lengths differ|23026
;
;      buffer and string comparisons merge here
;
|idn2a|add|7,xr|19,*schar||; point to chars of arg 1|23030
||add|7,xl|19,*schar||; point to chars of arg 2|23031
||ctw|8,wc|1,0||; get number of words in strings|23032
||lct|8,wc|8,wc||; set loop counter|23033
;
;      loop to compare characters. note that wc cannot be zero
;      since all null strings point to nulls and give xl=xr.
;
|iden3|cne|9,(xr)|9,(xl)|6,iden8|; differ if chars do not match|23038
||ica|7,xr|||; else bump arg one pointer|23039
||ica|7,xl|||; bump arg two pointer|23040
||bct|8,wc|6,iden3||; loop back till all checked|23041
||ejc|||||23042
;
;      ident (continued)
;
;      here to exit for case of two ident strings
;
||zer|7,xl|||; clear garbage value in xl|23048
||zer|7,xr|||; clear garbage value in xr|23049
||exi|1,1|||; take ident exit|23050
;
;      here for integers, ident if same values
;
|iden4|ldi|13,icval(xr)|||; load arg 1|23054
||sbi|13,icval(xl)|||; subtract arg 2 to compare|23055
||iov|6,iden1|||; differ if overflow|23056
||ine|6,iden1|||; differ if result is not zero|23057
||exi|1,1|||; take ident exit|23058
;
;      here for reals, ident if same values
;
|iden5|ldr|13,rcval(xr)|||; load arg 1|23064
||sbr|13,rcval(xl)|||; subtract arg 2 to compare|23065
||rov|6,iden1|||; differ if overflow|23066
||rne|6,iden1|||; differ if result is not zero|23067
||exi|1,1|||; take ident exit|23068
;
;      here for names, ident if bases and offsets same
;
|iden6|bne|13,nmofs(xr)|13,nmofs(xl)|6,iden1|; differ if different offset|23073
||bne|13,nmbas(xr)|13,nmbas(xl)|6,iden1|; differ if different base|23074
;
;      merge here to signal ident for identical pointers
;
|iden7|exi|1,1|||; take ident exit|23078
;
;      here for differ strings
;
|iden8|zer|7,xr|||; clear garbage ptr in xr|23082
||zer|7,xl|||; clear garbage ptr in xl|23083
||exi||||; return to caller (differ)|23084
||enp||||; end procedure ident|23085
||ejc|||||23086
;
;      inout - used to initialise input and output variables
;
;      (xl)		     pointer to vbl name string
;      (wb)		     trblk type
;      jsr  inout	     call to perform initialisation
;      (xl)		     vrblk ptr
;      (xr)		     trblk ptr
;      (wa,wc)		     destroyed
;
;      note that trter (= trtrf) field of standard i/o variables
;      points to corresponding svblk not to a trblk as is the
;      case for ordinary variables.
;
|inout|prc|25,e|1,0||; entry point|23101
||mov|11,-(xs)|8,wb||; stack trblk type|23102
||mov|8,wa|13,sclen(xl)||; get name length|23103
||zer|8,wb|||; point to start of name|23104
||jsr|6,sbstr|||; build a proper scblk|23105
||jsr|6,gtnvr|||; build vrblk|23106
||ppm||||; no error return|23107
||mov|8,wc|7,xr||; save vrblk pointer|23108
||mov|8,wb|10,(xs)+||; get trter field|23109
||zer|7,xl|||; zero trfpt|23110
||jsr|6,trbld|||; build trblk|23111
||mov|7,xl|8,wc||; recall vrblk pointer|23112
||mov|13,trter(xr)|13,vrsvp(xl)||; store svblk pointer|23113
||mov|13,vrval(xl)|7,xr||; store trblk ptr in vrblk|23114
||mov|13,vrget(xl)|22,=b_vra||; set trapped access|23115
||mov|13,vrsto(xl)|22,=b_vrv||; set trapped store|23116
||exi||||; return to caller|23117
||enp||||; end procedure inout|23118
||ejc|||||23119
;
;      insta - used to initialize structures in static region
;
;      (xr)		     pointer to starting static location
;      jsr  insta	     call to initialize static structure
;      (xr)		     ptr to next free static location
;      (wa,wb,wc)	     destroyed
;
;      note that this procedure establishes the pointers
;      prbuf, gtswk, and kvalp.
;
|insta|prc|25,e|1,0||; entry point|23298
;
;      initialize print buffer with blank words
;
;z-
||mov|8,wc|3,prlen||; no. of chars in print bfr|23303
||mov|3,prbuf|7,xr||; print bfr is put at static start|23304
||mov|10,(xr)+|22,=b_scl||; store string type code|23305
||mov|10,(xr)+|8,wc||; and string length|23306
||ctw|8,wc|1,0||; get number of words in buffer|23307
||mov|3,prlnw|8,wc||; store for buffer clear|23308
||lct|8,wc|8,wc||; words to clear|23309
;
;      loop to clear buffer
;
|inst1|mov|10,(xr)+|4,nullw||; store blank|23313
||bct|8,wc|6,inst1||; loop|23314
;
;      allocate work area for gtstg conversion procedure
;
||mov|8,wa|18,=nstmx||; get max num chars in output number|23318
||ctb|8,wa|2,scsi_||; no of bytes needed|23319
||mov|3,gtswk|7,xr||; store bfr adrs|23320
||add|7,xr|8,wa||; bump for work bfr|23321
;
;      build alphabet string for alphabet keyword and replace
;
||mov|3,kvalp|7,xr||; save alphabet pointer|23325
||mov|9,(xr)|22,=b_scl||; string blk type|23326
||mov|8,wc|18,=cfp_a||; no of chars in alphabet|23327
||mov|13,sclen(xr)|8,wc||; store as string length|23328
||mov|8,wb|8,wc||; copy char count|23329
||ctb|8,wb|2,scsi_||; no. of bytes needed|23330
||add|8,wb|7,xr||; current end address for static|23331
||mov|8,wa|8,wb||; save adrs past alphabet string|23332
||lct|8,wc|8,wc||; loop counter|23333
||psc|7,xr|||; point to chars of string|23334
||zer|8,wb|||; set initial character value|23335
;
;      loop to enter character codes in order
;
|inst2|sch|8,wb|10,(xr)+||; store next code|23339
||icv|8,wb|||; bump code value|23340
||bct|8,wc|6,inst2||; loop till all stored|23341
||csc|7,xr|||; complete store characters|23342
||mov|7,xr|8,wa||; return current static ptr|23343
||exi||||; return to caller|23344
||enp||||; end procedure insta|23345
||ejc|||||23346
;
;      iofcb -- get input/output fcblk pointer
;
;      used by endfile, eject and rewind to find the fcblk
;      (if any) corresponding to their argument.
;
;      -(xs)		     argument
;      jsr  iofcb	     call to find fcblk
;      ppm  loc		     arg is an unsuitable name
;      ppm  loc		     arg is null string
;      ppm  loc		     arg file not found
;      (xs)		     popped
;      (xl)		     ptr to filearg1 vrblk
;      (xr)		     argument
;      (wa)		     fcblk ptr or 0
;      (wb,wc)		     destroyed
;
|iofcb|prc|25,n|1,3||; entry point|23364
;z+
||jsr|6,gtstg|||; get arg as string|23366
||ppm|6,iofc2|||; fail|23367
||mov|7,xl|7,xr||; copy string ptr|23368
||jsr|6,gtnvr|||; get as natural variable|23369
||ppm|6,iofc3|||; fail if null|23370
||mov|8,wb|7,xl||; copy string pointer again|23371
||mov|7,xl|7,xr||; copy vrblk ptr for return|23372
||zer|8,wa|||; in case no trblk found|23373
;
;      loop to find file arg1 trblk
;
|iofc1|mov|7,xr|13,vrval(xr)||; get possible trblk ptr|23377
||bne|9,(xr)|22,=b_trt|6,iofc4|; fail if end of chain|23378
||bne|13,trtyp(xr)|18,=trtfc|6,iofc1|; loop if not file arg trblk|23379
||mov|8,wa|13,trfpt(xr)||; get fcblk ptr|23380
||mov|7,xr|8,wb||; copy arg|23381
||exi||||; return|23382
;
;      fail return
;
|iofc2|exi|1,1|||; fail|23386
;
;      null arg
;
|iofc3|exi|1,2|||; null arg return|23390
;
;      file not found
;
|iofc4|exi|1,3|||; file not found return|23394
||enp||||; end procedure iofcb|23395
||ejc|||||23396
;
;      ioppf -- process filearg2 for ioput
;
;      (r_xsc)		     filearg2 ptr
;      jsr  ioppf	     call to process filearg2
;      (xl)		     filearg1 ptr
;      (xr)		     file arg2 ptr
;      -(xs)...-(xs)	     fields extracted from filearg2
;      (wc)		     no. of fields extracted
;      (wb)		     input/output flag
;      (wa)		     fcblk ptr or 0
;
|ioppf|prc|25,n|1,0||; entry point|23409
||zer|8,wb|||; to count fields extracted|23410
;
;      loop to extract fields
;
|iopp1|mov|7,xl|18,=iodel||; get delimiter|23414
||mov|8,wc|7,xl||; copy it|23415
||zer|8,wa|||; retain leading blanks in filearg2|23416
||jsr|6,xscan|||; get next field|23417
||mov|11,-(xs)|7,xr||; stack it|23418
||icv|8,wb|||; increment count|23419
||bnz|8,wa|6,iopp1||; loop|23420
||mov|8,wc|8,wb||; count of fields|23421
||mov|8,wb|3,ioptt||; i/o marker|23422
||mov|8,wa|3,r_iof||; fcblk ptr or 0|23423
||mov|7,xr|3,r_io2||; file arg2 ptr|23424
||mov|7,xl|3,r_io1||; filearg1|23425
||exi||||; return|23426
||enp||||; end procedure ioppf|23427
||ejc|||||23428
;
;      ioput -- routine used by input and output
;
;      ioput sets up input/output  associations. it builds
;      such trace and file control blocks as are necessary and
;      calls sysfc,sysio to perform checks on the
;      arguments and to open the files.
;
;	  +-----------+	  +---------------+	  +-----------+
;      +-.i	      i	  i		  i------.i   =b_xrt  i
;      i  +-----------+	  +---------------+	  +-----------+
;      i  /	      /	       (r_fcb)		  i    *4     i
;      i  /	      /				  +-----------+
;      i  +-----------+	  +---------------+	  i	      i-
;      i  i   name    +--.i    =b_trt	  i	  +-----------+
;      i  /	      /	  +---------------+	  i	      i
;      i   (first arg)	  i =trtin/=trtou i	  +-----------+
;      i		  +---------------+		i
;      i		  i	value	  i		i
;      i		  +---------------+		i
;      i		  i(trtrf) 0   or i--+		i
;      i		  +---------------+  i		i
;      i		  i(trfpt) 0   or i----+	i
;      i		  +---------------+  i i	i
;      i		     (i/o trblk)     i i	i
;      i  +-----------+			     i i	i
;      i  i	      i			     i i	i
;      i  +-----------+			     i i	i
;      i  i	      i			     i i	i
;      i  +-----------+	  +---------------+  i i	i
;      i  i	      +--.i    =b_trt	  i.-+ i	i
;      i  +-----------+	  +---------------+    i	i
;      i  /	      /	  i    =trtfc	  i    i	i
;      i  /	      /	  +---------------+    i	i
;      i    (filearg1	  i	value	  i    i	i
;      i	 vrblk)	  +---------------+    i	i
;      i		  i(trtrf) 0   or i--+ i	.
;      i		  +---------------+  i .  +-----------+
;      i		  i(trfpt) 0   or i------./   fcblk   /
;      i		  +---------------+  i	  +-----------+
;      i		       (trtrf)	     i
;      i				     i
;      i				     i
;      i		  +---------------+  i
;      i		  i    =b_xrt	  i.-+
;      i		  +---------------+
;      i		  i	 *5	  i
;      i		  +---------------+
;      +------------------i		  i
;			  +---------------+	  +-----------+
;			  i(trtrf) o   or i------.i  =b_xrt   i
;			  +---------------+	  +-----------+
;			  i  name offset  i	  i    etc    i
;			  +---------------+
;			    (iochn - chain of name pointers)
||ejc|||||23484
;
;      ioput (continued)
;
;      no additional trap blocks are used for standard input/out
;      files. otherwise an i/o trap block is attached to second
;      arg (filearg1) vrblk. see diagram above for details of
;      the structure built.
;
;      -(xs)		     1st arg (vbl to be associated)
;      -(xs)		     2nd arg (file arg1)
;      -(xs)		     3rd arg (file arg2)
;      (wb)		     0 for input, 3 for output assoc.
;      jsr  ioput	     call for input/output association
;      ppm  loc		     3rd arg not a string
;      ppm  loc		     2nd arg not a suitable name
;      ppm  loc		     1st arg not a suitable name
;      ppm  loc		     inappropriate file spec for i/o
;      ppm  loc		     i/o file does not exist
;      ppm  loc		     i/o file cannot be read/written
;      ppm  loc		     i/o fcblk currently in use
;      (xs)		     popped
;      (xl,xr,wa,wb,wc)	     destroyed
;
|ioput|prc|25,n|1,7||; entry point|23508
||zer|3,r_iot|||; in case no trtrf block used|23509
||zer|3,r_iof|||; in case no fcblk alocated|23510
||zer|3,r_iop|||; in case sysio fails|23511
||mov|3,ioptt|8,wb||; store i/o trace type|23512
||jsr|6,xscni|||; prepare to scan filearg2|23513
||ppm|6,iop13|||; fail|23514
||ppm|6,iopa0|||; null file arg2|23515
;
|iopa0|mov|3,r_io2|7,xr||; keep file arg2|23517
||mov|7,xl|8,wa||; copy length|23518
||jsr|6,gtstg|||; convert filearg1 to string|23519
||ppm|6,iop14|||; fail|23520
||mov|3,r_io1|7,xr||; keep filearg1 ptr|23521
||jsr|6,gtnvr|||; convert to natural variable|23522
||ppm|6,iop00|||; jump if null|23523
||brn|6,iop04|||; jump to process non-null args|23524
;
;      null filearg1
;
|iop00|bze|7,xl|6,iop01||; skip if both args null|23528
||jsr|6,ioppf|||; process filearg2|23529
||jsr|6,sysfc|||; call for filearg2 check|23530
||ppm|6,iop16|||; fail|23531
||ppm|6,iop26|||; fail|23532
||brn|6,iop11|||; complete file association|23533
||ejc|||||23534
;
;      ioput (continued)
;
;      here with 0 or fcblk ptr in (xl)
;
|iop01|mov|8,wb|3,ioptt||; get trace type|23540
||mov|7,xr|3,r_iot||; get 0 or trtrf ptr|23541
||jsr|6,trbld|||; build trblk|23542
||mov|8,wc|7,xr||; copy trblk pointer|23543
||mov|7,xr|10,(xs)+||; get variable from stack|23544
||mov|11,-(xs)|8,wc||; make trblk collectable|23545
||jsr|6,gtvar|||; point to variable|23546
||ppm|6,iop15|||; fail|23547
||mov|8,wc|10,(xs)+||; recover trblk pointer|23548
||mov|3,r_ion|7,xl||; save name pointer|23549
||mov|7,xr|7,xl||; copy name pointer|23550
||add|7,xr|8,wa||; point to variable|23551
||sub|7,xr|19,*vrval||; subtract offset,merge into loop|23552
;
;      loop to end of trblk chain if any
;
|iop02|mov|7,xl|7,xr||; copy blk ptr|23556
||mov|7,xr|13,vrval(xr)||; load ptr to next trblk|23557
||bne|9,(xr)|22,=b_trt|6,iop03|; jump if not trapped|23558
||bne|13,trtyp(xr)|3,ioptt|6,iop02|; loop if not same assocn|23559
||mov|7,xr|13,trnxt(xr)||; get value and delete old trblk|23560
;
;      ioput (continued)
;
;      store new association
;
|iop03|mov|13,vrval(xl)|8,wc||; link to this trblk|23566
||mov|7,xl|8,wc||; copy pointer|23567
||mov|13,trnxt(xl)|7,xr||; store value in trblk|23568
||mov|7,xr|3,r_ion||; restore possible vrblk pointer|23569
||mov|8,wb|8,wa||; keep offset to name|23570
||jsr|6,setvr|||; if vrblk, set vrget,vrsto|23571
||mov|7,xr|3,r_iot||; get 0 or trtrf ptr|23572
||bnz|7,xr|6,iop19||; jump if trtrf block exists|23573
||exi||||; return to caller|23574
;
;      non standard file
;      see if an fcblk has already been allocated.
;
|iop04|zer|8,wa|||; in case no fcblk found|23579
||ejc|||||23580
;
;      ioput (continued)
;
;      search possible trblk chain to pick up the fcblk
;
|iop05|mov|8,wb|7,xr||; remember blk ptr|23586
||mov|7,xr|13,vrval(xr)||; chain along|23587
||bne|9,(xr)|22,=b_trt|6,iop06|; jump if end of trblk chain|23588
||bne|13,trtyp(xr)|18,=trtfc|6,iop05|; loop if more to go|23589
||mov|3,r_iot|7,xr||; point to file arg1 trblk|23590
||mov|8,wa|13,trfpt(xr)||; get fcblk ptr from trblk|23591
;
;      wa = 0 or fcblk ptr
;      wb = ptr to preceding blk to which any trtrf block
;	    for file arg1 must be chained.
;
|iop06|mov|3,r_iof|8,wa||; keep possible fcblk ptr|23597
||mov|3,r_iop|8,wb||; keep preceding blk ptr|23598
||jsr|6,ioppf|||; process filearg2|23599
||jsr|6,sysfc|||; see if fcblk required|23600
||ppm|6,iop16|||; fail|23601
||ppm|6,iop26|||; fail|23602
||bze|8,wa|6,iop12||; skip if no new fcblk wanted|23603
||blt|8,wc|18,=num02|6,iop6a|; jump if fcblk in dynamic|23604
||jsr|6,alost|||; get it in static|23605
||brn|6,iop6b|||; skip|23606
;
;      obtain fcblk in dynamic
;
|iop6a|jsr|6,alloc|||; get space for fcblk|23610
;
;      merge
;
|iop6b|mov|7,xl|7,xr||; point to fcblk|23614
||mov|8,wb|8,wa||; copy its length|23615
||btw|8,wb|||; get count as words (sgd apr80)|23616
||lct|8,wb|8,wb||; loop counter|23617
;
;      clear fcblk
;
|iop07|zer|10,(xr)+|||; clear a word|23621
||bct|8,wb|6,iop07||; loop|23622
||beq|8,wc|18,=num02|6,iop09|; skip if in static - dont set fields|23623
||mov|9,(xl)|22,=b_xnt||; store xnblk code in case|23624
||mov|13,num01(xl)|8,wa||; store length|23625
||bnz|8,wc|6,iop09||; jump if xnblk wanted|23626
||mov|9,(xl)|22,=b_xrt||; xrblk code requested|23627
;
||ejc|||||23629
;      ioput (continued)
;
;      complete fcblk initialisation
;
|iop09|mov|7,xr|3,r_iot||; get possible trblk ptr|23634
||mov|3,r_iof|7,xl||; store fcblk ptr|23635
||bnz|7,xr|6,iop10||; jump if trblk already found|23636
;
;      a new trblk is needed
;
||mov|8,wb|18,=trtfc||; trtyp for fcblk trap blk|23640
||jsr|6,trbld|||; make the block|23641
||mov|3,r_iot|7,xr||; copy trtrf ptr|23642
||mov|7,xl|3,r_iop||; point to preceding blk|23643
||mov|13,vrval(xr)|13,vrval(xl)||; copy value field to trblk|23644
||mov|13,vrval(xl)|7,xr||; link new trblk into chain|23645
||mov|7,xr|7,xl||; point to predecessor blk|23646
||jsr|6,setvr|||; set trace intercepts|23647
||mov|7,xr|13,vrval(xr)||; recover trblk ptr|23648
||brn|6,iop1a|||; store fcblk ptr|23649
;
;      here if existing trblk
;
|iop10|zer|3,r_iop|||; do not release if sysio fails|23653
;
;      xr is ptr to trblk, xl is fcblk ptr or 0
;
|iop1a|mov|13,trfpt(xr)|3,r_iof||; store fcblk ptr|23657
;
;      call sysio to complete file accessing
;
|iop11|mov|8,wa|3,r_iof||; copy fcblk ptr or 0|23661
||mov|8,wb|3,ioptt||; get input/output flag|23662
||mov|7,xr|3,r_io2||; get file arg2|23663
||mov|7,xl|3,r_io1||; get file arg1|23664
||jsr|6,sysio|||; associate to the file|23665
||ppm|6,iop17|||; fail|23666
||ppm|6,iop18|||; fail|23667
||bnz|3,r_iot|6,iop01||; not std input if non-null trtrf blk|23668
||bnz|3,ioptt|6,iop01||; jump if output|23669
||bze|8,wc|6,iop01||; no change to standard read length|23670
||mov|3,cswin|8,wc||; store new read length for std file|23671
||brn|6,iop01|||; merge to finish the task|23672
;
;      sysfc may have returned a pointer to a private fcblk
;
|iop12|bnz|7,xl|6,iop09||; jump if private fcblk|23676
||brn|6,iop11|||; finish the association|23677
;
;      failure returns
;
|iop13|exi|1,1|||; 3rd arg not a string|23681
|iop14|exi|1,2|||; 2nd arg unsuitable|23682
|iop15|ica|7,xs|||; discard trblk pointer|23683
||exi|1,3|||; 1st arg unsuitable|23684
|iop16|exi|1,4|||; file spec wrong|23685
|iop26|exi|1,7|||; fcblk in use|23686
;
;      i/o file does not exist
;
|iop17|mov|7,xr|3,r_iop||; is there a trblk to release|23690
||bze|7,xr|6,iopa7||; if not|23691
||mov|7,xl|13,vrval(xr)||; point to trblk|23692
||mov|13,vrval(xr)|13,vrval(xl)||; unsplice it|23693
||jsr|6,setvr|||; adjust trace intercepts|23694
|iopa7|exi|1,5|||; i/o file does not exist|23695
;
;      i/o file cannot be read/written
;
|iop18|mov|7,xr|3,r_iop||; is there a trblk to release|23699
||bze|7,xr|6,iopa7||; if not|23700
||mov|7,xl|13,vrval(xr)||; point to trblk|23701
||mov|13,vrval(xr)|13,vrval(xl)||; unsplice it|23702
||jsr|6,setvr|||; adjust trace intercepts|23703
|iopa8|exi|1,6|||; i/o file cannot be read/written|23704
||ejc|||||23705
;
;      ioput (continued)
;
;      add to iochn chain of associated variables unless
;      already present.
;
|iop19|mov|8,wc|3,r_ion||; wc = name base, wb = name offset|23712
;
;      search loop
;
|iop20|mov|7,xr|13,trtrf(xr)||; next link of chain|23716
||bze|7,xr|6,iop21||; not found|23717
||bne|8,wc|13,ionmb(xr)|6,iop20|; no match|23718
||beq|8,wb|13,ionmo(xr)|6,iop22|; exit if matched|23719
||brn|6,iop20|||; loop|23720
;
;      not found
;
|iop21|mov|8,wa|19,*num05||; space needed|23724
||jsr|6,alloc|||; get it|23725
||mov|9,(xr)|22,=b_xrt||; store xrblk code|23726
||mov|13,num01(xr)|8,wa||; store length|23727
||mov|13,ionmb(xr)|8,wc||; store name base|23728
||mov|13,ionmo(xr)|8,wb||; store name offset|23729
||mov|7,xl|3,r_iot||; point to trtrf blk|23730
||mov|8,wa|13,trtrf(xl)||; get ptr field contents|23731
||mov|13,trtrf(xl)|7,xr||; store ptr to new block|23732
||mov|13,trtrf(xr)|8,wa||; complete the linking|23733
;
;      insert fcblk on fcblk chain for sysej, sysxi
;
|iop22|bze|3,r_iof|6,iop25||; skip if no fcblk|23737
||mov|7,xl|3,r_fcb||; ptr to head of existing chain|23738
;
;      see if fcblk already on chain
;
|iop23|bze|7,xl|6,iop24||; not on if end of chain|23742
||beq|13,num03(xl)|3,r_iof|6,iop25|; dont duplicate if find it|23743
||mov|7,xl|13,num02(xl)||; get next link|23744
||brn|6,iop23|||; loop|23745
;
;      not found so add an entry for this fcblk
;
|iop24|mov|8,wa|19,*num04||; space needed|23749
||jsr|6,alloc|||; get it|23750
||mov|9,(xr)|22,=b_xrt||; store block code|23751
||mov|13,num01(xr)|8,wa||; store length|23752
||mov|13,num02(xr)|3,r_fcb||; store previous link in this node|23753
||mov|13,num03(xr)|3,r_iof||; store fcblk ptr|23754
||mov|3,r_fcb|7,xr||; insert node into fcblk chain|23755
;
;      return
;
|iop25|exi||||; return to caller|23759
||enp||||; end procedure ioput|23760
||ejc|||||23761
;
;      ktrex -- execute keyword trace
;
;      ktrex is used to execute a possible keyword trace. it
;      includes the test on trace and tests for trace active.
;
;      (xl)		     ptr to trblk (or 0 if untraced)
;      jsr  ktrex	     call to execute keyword trace
;      (xl,wa,wb,wc)	     destroyed
;      (ra)		     destroyed
;
|ktrex|prc|25,r|1,0||; entry point (recursive)|23773
||bze|7,xl|6,ktrx3||; immediate exit if keyword untraced|23774
||bze|3,kvtra|6,ktrx3||; immediate exit if trace = 0|23775
||dcv|3,kvtra|||; else decrement trace|23776
||mov|11,-(xs)|7,xr||; save xr|23777
||mov|7,xr|7,xl||; copy trblk pointer|23778
||mov|7,xl|13,trkvr(xr)||; load vrblk pointer (nmbas)|23779
||mov|8,wa|19,*vrval||; set name offset|23780
||bze|13,trfnc(xr)|6,ktrx1||; jump if print trace|23781
||jsr|6,trxeq|||; else execute full trace|23782
||brn|6,ktrx2|||; and jump to exit|23783
;
;      here for print trace
;
|ktrx1|mov|11,-(xs)|7,xl||; stack vrblk ptr for kwnam|23787
||mov|11,-(xs)|8,wa||; stack offset for kwnam|23788
||jsr|6,prtsn|||; print statement number|23789
||mov|8,wa|18,=ch_am||; load ampersand|23790
||jsr|6,prtch|||; print ampersand|23791
||jsr|6,prtnm|||; print keyword name|23792
||mov|7,xr|21,=tmbeb||; point to blank-equal-blank|23793
||jsr|6,prtst|||; print blank-equal-blank|23794
||jsr|6,kwnam|||; get keyword pseudo-variable name|23795
||mov|3,dnamp|7,xr||; reset ptr to delete kvblk|23796
||jsr|6,acess|||; get keyword value|23797
||ppm||||; failure is impossible|23798
||jsr|6,prtvl|||; print keyword value|23799
||jsr|6,prtnl|||; terminate print line|23800
;
;      here to exit after completing trace
;
|ktrx2|mov|7,xr|10,(xs)+||; restore entry xr|23804
;
;      merge here to exit if no trace required
;
|ktrx3|exi||||; return to ktrex caller|23808
||enp||||; end procedure ktrex|23809
||ejc|||||23810
;
;      kwnam -- get pseudo-variable name for keyword
;
;      1(xs)		     name base for vrblk
;      0(xs)		     offset (should be *vrval)
;      jsr  kwnam	     call to get pseudo-variable name
;      (xs)		     popped twice
;      (xl,wa)		     resulting pseudo-variable name
;      (xr,wa,wb)	     destroyed
;
|kwnam|prc|25,n|1,0||; entry point|23821
||ica|7,xs|||; ignore name offset|23822
||mov|7,xr|10,(xs)+||; load name base|23823
||bge|7,xr|3,state|6,kwnm1|; jump if not natural variable name|23824
||bnz|13,vrlen(xr)|6,kwnm1||; error if not system variable|23825
||mov|7,xr|13,vrsvp(xr)||; else point to svblk|23826
||mov|8,wa|13,svbit(xr)||; load bit mask|23827
||anb|8,wa|4,btknm||; and with keyword bit|23828
||zrb|8,wa|6,kwnm1||; error if no keyword association|23829
||mov|8,wa|13,svlen(xr)||; else load name length in characters|23830
||ctb|8,wa|2,svchs||; compute offset to field we want|23831
||add|7,xr|8,wa||; point to svknm field|23832
||mov|8,wb|9,(xr)||; load svknm value|23833
||mov|8,wa|19,*kvsi_||; set size of kvblk|23834
||jsr|6,alloc|||; allocate kvblk|23835
||mov|9,(xr)|22,=b_kvt||; store type word|23836
||mov|13,kvnum(xr)|8,wb||; store keyword number|23837
||mov|13,kvvar(xr)|21,=trbkv||; set dummy trblk pointer|23838
||mov|7,xl|7,xr||; copy kvblk pointer|23839
||mov|8,wa|19,*kvvar||; set proper offset|23840
||exi||||; return to kvnam caller|23841
;
;      here if not keyword name
;
|kwnm1|erb|1,251|26,keyword operand is not name of defined keyword|||23845
||enp||||; end procedure kwnam|23846
||ejc|||||23847
;
;      lcomp-- compare two strings lexically
;
;      1(xs)		     first argument
;      0(xs)		     second argument
;      jsr  lcomp	     call to compare aruments
;      ppm  loc		     transfer loc for arg1 not string
;      ppm  loc		     transfer loc for arg2 not string
;      ppm  loc		     transfer loc if arg1 llt arg2
;      ppm  loc		     transfer loc if arg1 leq arg2
;      ppm  loc		     transfer loc if arg1 lgt arg2
;      (the normal return is never taken)
;      (xs)		     popped twice
;      (xr,xl)		     destroyed
;      (wa,wb,wc,ra)	     destroyed
;
|lcomp|prc|25,n|1,5||; entry point|23864
||jsr|6,gtstg|||; convert second arg to string|23866
||ppm|6,lcmp6|||; jump if second arg not string|23870
||mov|7,xl|7,xr||; else save pointer|23871
||mov|8,wc|8,wa||; and length|23872
||jsr|6,gtstg|||; convert first argument to string|23874
||ppm|6,lcmp5|||; jump if not string|23878
||mov|8,wb|8,wa||; save arg 1 length|23879
||plc|7,xr|||; point to chars of arg 1|23880
||plc|7,xl|||; point to chars of arg 2|23881
||blo|8,wa|8,wc|6,lcmp1|; jump if arg 1 length is smaller|23893
||mov|8,wa|8,wc||; else set arg 2 length as smaller|23894
;
;      here with smaller length in (wa)
;
|lcmp1|bze|8,wa|6,lcmp7||; if null string, compare lengths|23898
||cmc|6,lcmp4|6,lcmp3||; compare strings, jump if unequal|23899
|lcmp7|bne|8,wb|8,wc|6,lcmp2|; if equal, jump if lengths unequal|23900
||exi|1,4|||; else identical strings, leq exit|23901
||ejc|||||23902
;
;      lcomp (continued)
;
;      here if initial strings identical, but lengths unequal
;
|lcmp2|bhi|8,wb|8,wc|6,lcmp4|; jump if arg 1 length gt arg 2 leng|23908
;
;      here if first arg llt second arg
;
|lcmp3|exi|1,3|||; take llt exit|23913
;
;      here if first arg lgt second arg
;
|lcmp4|exi|1,5|||; take lgt exit|23917
;
;      here if first arg is not a string
;
|lcmp5|exi|1,1|||; take bad first arg exit|23921
;
;      here for second arg not a string
;
|lcmp6|exi|1,2|||; take bad second arg error exit|23925
||enp||||; end procedure lcomp|23926
||ejc|||||23927
;
;      listr -- list source line
;
;      listr is used to list a source line during the initial
;      compilation. it is called from scane and scanl.
;
;      jsr  listr	     call to list line
;      (xr,xl,wa,wb,wc)	     destroyed
;
;      global locations used by listr
;
;      cnttl		     flag for -title, -stitl
;
;      erlst		     if listing on account of an error
;
;      lstid		     include depth of current image
;
;      lstlc		     count lines on current page
;
;      lstnp		     max number of lines/page
;
;      lstpf		     set non-zero if the current source
;			     line has been listed, else zero.
;
;      lstpg		     compiler listing page number
;
;      lstsn		     set if stmnt num to be listed
;
;      r_cim		     pointer to current input line.
;
;      r_ttl		     title for source listing
;
;      r_stl		     ptr to sub-title string
;
;      entry point
;
|listr|prc|25,e|1,0||; entry point|23966
||bnz|3,cnttl|6,list5||; jump if -title or -stitl|23967
||bnz|3,lstpf|6,list4||; immediate exit if already listed|23968
||bge|3,lstlc|3,lstnp|6,list6|; jump if no room|23969
;
;      here after printing title (if needed)
;
|list0|mov|7,xr|3,r_cim||; load pointer to current image|23973
||bze|7,xr|6,list4||; jump if no image to print|23974
||plc|7,xr|||; point to characters|23975
||lch|8,wa|9,(xr)||; load first character|23976
||mov|7,xr|3,lstsn||; load statement number|23977
||bze|7,xr|6,list2||; jump if no statement number|23978
||mti|7,xr|||; else get stmnt number as integer|23979
||bne|3,stage|18,=stgic|6,list1|; skip if execute time|23980
||beq|8,wa|18,=ch_as|6,list2|; no stmnt number list if comment|23981
||beq|8,wa|18,=ch_mn|6,list2|; no stmnt no. if control card|23982
;
;      print statement number
;
|list1|jsr|6,prtin|||; else print statement number|23986
||zer|3,lstsn|||; and clear for next time in|23987
;
;      here to test for printing include depth
;
|list2|mov|7,xr|3,lstid||; include depth of image|23992
||bze|7,xr|6,list8||; if not from an include file|23993
||mov|8,wa|18,=stnpd||; position for start of statement|23994
||sub|8,wa|18,=num03||; position to place include depth|23995
||mov|3,profs|8,wa||; set as starting position|23996
||mti|7,xr|||; include depth as integer|23997
||jsr|6,prtin|||; print include depth|23998
||ejc|||||23999
;
;      listr (continued)
;
;      here after printing statement number and include depth
;
|list8|mov|3,profs|18,=stnpd||; point past statement number|24005
||mov|7,xr|3,r_cim||; load pointer to current image|24015
||jsr|6,prtst|||; print it|24016
||icv|3,lstlc|||; bump line counter|24017
||bnz|3,erlst|6,list3||; jump if error copy to int.ch.|24018
||jsr|6,prtnl|||; terminate line|24019
||bze|3,cswdb|6,list3||; jump if -single mode|24020
||jsr|6,prtnl|||; else add a blank line|24021
||icv|3,lstlc|||; and bump line counter|24022
;
;      here after printing source image
;
|list3|mnz|3,lstpf|||; set flag for line printed|24026
;
;      merge here to exit
;
|list4|exi||||; return to listr caller|24030
;
;      print title after -title or -stitl card
;
|list5|zer|3,cnttl|||; clear flag|24034
;
;      eject to new page and list title
;
|list6|jsr|6,prtps|||; eject|24038
||bze|3,prich|6,list7||; skip if listing to regular printer|24039
||beq|3,r_ttl|21,=nulls|6,list0|; terminal listing omits null title|24040
;
;      list title
;
|list7|jsr|6,listt|||; list title|24044
||brn|6,list0|||; merge|24045
||enp||||; end procedure listr|24046
||ejc|||||24047
;
;      listt -- list title and subtitle
;
;      used during compilation to print page heading
;
;      jsr  listt	     call to list title
;      (xr,wa)		     destroyed
;
|listt|prc|25,e|1,0||; entry point|24056
||mov|7,xr|3,r_ttl||; point to source listing title|24057
||jsr|6,prtst|||; print title|24058
||mov|3,profs|3,lstpo||; set offset|24059
||mov|7,xr|21,=lstms||; set page message|24060
||jsr|6,prtst|||; print page message|24061
||icv|3,lstpg|||; bump page number|24062
||mti|3,lstpg|||; load page number as integer|24063
||jsr|6,prtin|||; print page number|24064
||jsr|6,prtnl|||; terminate title line|24065
||add|3,lstlc|18,=num02||; count title line and blank line|24066
;
;      print sub-title (if any)
;
||mov|7,xr|3,r_stl||; load pointer to sub-title|24070
||bze|7,xr|6,lstt1||; jump if no sub-title|24071
||jsr|6,prtst|||; else print sub-title|24072
||jsr|6,prtnl|||; terminate line|24073
||icv|3,lstlc|||; bump line count|24074
;
;      return point
;
|lstt1|jsr|6,prtnl|||; print a blank line|24078
||exi||||; return to caller|24079
||enp||||; end procedure listt|24080
||ejc|||||24081
;
;      newfn -- record new source file name
;
;      newfn is used after switching to a new include file, or
;      after a -line statement which contains a file name.
;
;      (xr)		     file name scblk
;      jsr  newfn
;      (wa,wb,wc,xl,xr,ra)   destroyed
;
;      on return, the table that maps statement numbers to file
;      names has been updated to include this new file name and
;      the current statement number.  the entry is made only if
;      the file name had changed from its previous value.
;
|newfn|prc|25,e|1,0||; entry point|24098
||mov|11,-(xs)|7,xr||; save new name|24099
||mov|7,xl|3,r_sfc||; load previous name|24100
||jsr|6,ident|||; check for equality|24101
||ppm|6,nwfn1|||; jump if identical|24102
||mov|7,xr|10,(xs)+||; different, restore name|24103
||mov|3,r_sfc|7,xr||; record current file name|24104
||mov|8,wb|3,cmpsn||; get current statement|24105
||mti|8,wb|||; convert to integer|24106
||jsr|6,icbld|||; build icblk for stmt number|24107
||mov|7,xl|3,r_sfn||; file name table|24108
||mnz|8,wb|||; lookup statement number by name|24109
||jsr|6,tfind|||; allocate new teblk|24110
||ppm||||; always possible to allocate block|24111
||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|24112
||exi|||||24113
;
;     here if new name and old name identical
;
|nwfn1|ica|7,xs|||; pop stack|24117
||exi|||||24118
||ejc|||||24119
;
;      nexts -- acquire next source image
;
;      nexts is used to acquire the next source image at compile
;      time. it assumes that a prior call to readr has input
;      a line image (see procedure readr). before the current
;      image is finally lost it may be listed here.
;
;      jsr  nexts	     call to acquire next input line
;      (xr,xl,wa,wb,wc)	     destroyed
;
;      global values affected
;
;      lstid		     include depth of next image
;
;      r_cni		     on input, next image. on
;			     exit reset to zero
;
;      r_cim		     on exit, set to point to image
;
;      rdcln		     current ln set from next line num
;
;      scnil		     input image length on exit
;
;      scnse		     reset to zero on exit
;
;      lstpf		     set on exit if line is listed
;
|nexts|prc|25,e|1,0||; entry point|24151
||bze|3,cswls|6,nxts2||; jump if -nolist|24152
||mov|7,xr|3,r_cim||; point to image|24153
||bze|7,xr|6,nxts2||; jump if no image|24154
||plc|7,xr|||; get char ptr|24155
||lch|8,wa|9,(xr)||; get first char|24156
||bne|8,wa|18,=ch_mn|6,nxts1|; jump if not ctrl card|24157
||bze|3,cswpr|6,nxts2||; jump if -noprint|24158
;
;      here to call lister
;
|nxts1|jsr|6,listr|||; list line|24162
;
;      here after possible listing
;
|nxts2|mov|7,xr|3,r_cni||; point to next image|24166
||mov|3,r_cim|7,xr||; set as next image|24167
||mov|3,rdcln|3,rdnln||; set as current line number|24168
||mov|3,lstid|3,cnind||; set as current include depth|24170
||zer|3,r_cni|||; clear next image pointer|24172
||mov|8,wa|13,sclen(xr)||; get input image length|24173
||mov|8,wb|3,cswin||; get max allowable length|24174
||blo|8,wa|8,wb|6,nxts3|; skip if not too long|24175
||mov|8,wa|8,wb||; else truncate|24176
;
;      here with length in (wa)
;
|nxts3|mov|3,scnil|8,wa||; use as record length|24180
||zer|3,scnse|||; reset scnse|24181
||zer|3,lstpf|||; set line not listed yet|24182
||exi||||; return to nexts caller|24183
||enp||||; end procedure nexts|24184
||ejc|||||24185
;
;      patin -- pattern construction for len,pos,rpos,tab,rtab
;
;      these pattern types all generate a similar node type. so
;      the construction code is shared. see functions section
;      for actual entry points for these five functions.
;
;      (wa)		     pcode for expression arg case
;      (wb)		     pcode for integer arg case
;      jsr  patin	     call to build pattern node
;      ppm  loc		     transfer loc for not integer or exp
;      ppm  loc		     transfer loc for int out of range
;      (xr)		     pointer to constructed node
;      (xl,wa,wb,wc,ia)	     destroyed
;
|patin|prc|25,n|1,2||; entry point|24201
||mov|7,xl|8,wa||; preserve expression arg pcode|24202
||jsr|6,gtsmi|||; try to convert arg as small integer|24203
||ppm|6,ptin2|||; jump if not integer|24204
||ppm|6,ptin3|||; jump if out of range|24205
;
;      common successful exit point
;
|ptin1|jsr|6,pbild|||; build pattern node|24209
||exi||||; return to caller|24210
;
;      here if argument is not an integer
;
|ptin2|mov|8,wb|7,xl||; copy expr arg case pcode|24214
||blo|9,(xr)|22,=b_e__|6,ptin1|; all ok if expression arg|24215
||exi|1,1|||; else take error exit for wrong type|24216
;
;      here for error of out of range integer argument
;
|ptin3|exi|1,2|||; take out-of-range error exit|24220
||enp||||; end procedure patin|24221
||ejc|||||24222
;
;      patst -- pattern construction for any,notany,
;		break,span and breakx pattern functions.
;
;      these pattern functions build similar types of nodes and
;      the construction code is shared. see functions section
;      for actual entry points for these five pattern functions.
;
;      0(xs)		     string argument
;      (wb)		     pcode for one char argument
;      (xl)		     pcode for multi-char argument
;      (wc)		     pcode for expression argument
;      jsr  patst	     call to build node
;      ppm  loc		     if not string or expr (or null)
;      (xs)		     popped past string argument
;      (xr)		     pointer to constructed node
;      (xl)		     destroyed
;      (wa,wb,wc,ra)	     destroyed
;
;      note that there is a special call to patst in the evals
;      procedure with a slightly different form. see evals
;      for details of the form of this call.
;
|patst|prc|25,n|1,1||; entry point|24246
||jsr|6,gtstg|||; convert argument as string|24247
||ppm|6,pats7|||; jump if not string|24248
||bze|8,wa|6,pats7||; jump if null string (catspaw)|24249
||bne|8,wa|18,=num01|6,pats2|; jump if not one char string|24250
;
;      here for one char string case
;
||bze|8,wb|6,pats2||; treat as multi-char if evals call|24254
||plc|7,xr|||; point to character|24255
||lch|7,xr|9,(xr)||; load character|24256
;
;      common exit point after successful construction
;
|pats1|jsr|6,pbild|||; call routine to build node|24260
||exi||||; return to patst caller|24261
||ejc|||||24262
;
;      patst (continued)
;
;      here for multi-character string case
;
|pats2|mov|11,-(xs)|7,xl||; save multi-char pcode|24268
||mov|8,wc|3,ctmsk||; load current mask bit|24269
||beq|7,xr|3,r_cts|6,pats6|; jump if same as last string c3.738|24270
||mov|11,-(xs)|7,xr||; save string pointer|24271
||lsh|8,wc|1,1||; shift to next position|24272
||nzb|8,wc|6,pats4||; skip if position left in this tbl|24273
;
;      here we must allocate a new character table
;
||mov|8,wa|19,*ctsi_||; set size of ctblk|24277
||jsr|6,alloc|||; allocate ctblk|24278
||mov|3,r_ctp|7,xr||; store ptr to new ctblk|24279
||mov|10,(xr)+|22,=b_ctt||; store type code, bump ptr|24280
||lct|8,wb|18,=cfp_a||; set number of words to clear|24281
||mov|8,wc|4,bits0||; load all zero bits|24282
;
;      loop to clear all bits in table to zeros
;
|pats3|mov|10,(xr)+|8,wc||; move word of zero bits|24286
||bct|8,wb|6,pats3||; loop till all cleared|24287
||mov|8,wc|4,bits1||; set initial bit position|24288
;
;      merge here with bit position available
;
|pats4|mov|3,ctmsk|8,wc||; save parm2 (new bit position)|24292
||mov|7,xl|10,(xs)+||; restore pointer to argument string|24293
||mov|3,r_cts|7,xl||; save for next time   c3.738|24294
||mov|8,wb|13,sclen(xl)||; load string length|24295
||bze|8,wb|6,pats6||; jump if null string case|24296
||lct|8,wb|8,wb||; else set loop counter|24297
||plc|7,xl|||; point to characters in argument|24298
||ejc|||||24299
;
;      patst (continued)
;
;      loop to set bits in column of table
;
|pats5|lch|8,wa|10,(xl)+||; load next character|24305
||wtb|8,wa|||; convert to byte offset|24306
||mov|7,xr|3,r_ctp||; point to ctblk|24307
||add|7,xr|8,wa||; point to ctblk entry|24308
||mov|8,wa|8,wc||; copy bit mask|24309
||orb|8,wa|13,ctchs(xr)||; or in bits already set|24310
||mov|13,ctchs(xr)|8,wa||; store resulting bit string|24311
||bct|8,wb|6,pats5||; loop till all bits set|24312
;
;      complete processing for multi-char string case
;
|pats6|mov|7,xr|3,r_ctp||; load ctblk ptr as parm1 for pbild|24316
||zer|7,xl|||; clear garbage ptr in xl|24317
||mov|8,wb|10,(xs)+||; load pcode for multi-char str case|24318
||brn|6,pats1|||; back to exit (wc=bitstring=parm2)|24319
;
;      here if argument is not a string
;
;      note that the call from evals cannot pass an expression
;      since evalp always reevaluates expressions.
;
|pats7|mov|8,wb|8,wc||; set pcode for expression argument|24326
||blo|9,(xr)|22,=b_e__|6,pats1|; jump to exit if expression arg|24327
||exi|1,1|||; else take wrong type error exit|24328
||enp||||; end procedure patst|24329
||ejc|||||24330
;
;      pbild -- build pattern node
;
;      (xr)		     parm1 (only if required)
;      (wb)		     pcode for node
;      (wc)		     parm2 (only if required)
;      jsr  pbild	     call to build node
;      (xr)		     pointer to constructed node
;      (wa)		     destroyed
;
|pbild|prc|25,e|1,0||; entry point|24341
||mov|11,-(xs)|7,xr||; stack possible parm1|24342
||mov|7,xr|8,wb||; copy pcode|24343
||lei|7,xr|||; load entry point id (bl_px)|24344
||beq|7,xr|18,=bl_p1|6,pbld1|; jump if one parameter|24345
||beq|7,xr|18,=bl_p0|6,pbld3|; jump if no parameters|24346
;
;      here for two parameter case
;
||mov|8,wa|19,*pcsi_||; set size of p2blk|24350
||jsr|6,alloc|||; allocate block|24351
||mov|13,parm2(xr)|8,wc||; store second parameter|24352
||brn|6,pbld2|||; merge with one parm case|24353
;
;      here for one parameter case
;
|pbld1|mov|8,wa|19,*pbsi_||; set size of p1blk|24357
||jsr|6,alloc|||; allocate node|24358
;
;      merge here from two parm case
;
|pbld2|mov|13,parm1(xr)|9,(xs)||; store first parameter|24362
||brn|6,pbld4|||; merge with no parameter case|24363
;
;      here for case of no parameters
;
|pbld3|mov|8,wa|19,*pasi_||; set size of p0blk|24367
||jsr|6,alloc|||; allocate node|24368
;
;      merge here from other cases
;
|pbld4|mov|9,(xr)|8,wb||; store pcode|24372
||ica|7,xs|||; pop first parameter|24373
||mov|13,pthen(xr)|21,=ndnth||; set nothen successor pointer|24374
||exi||||; return to pbild caller|24375
||enp||||; end procedure pbild|24376
||ejc|||||24377
;
;      pconc -- concatenate two patterns
;
;      (xl)		     ptr to right pattern
;      (xr)		     ptr to left pattern
;      jsr  pconc	     call to concatenate patterns
;      (xr)		     ptr to concatenated pattern
;      (xl,wa,wb,wc)	     destroyed
;
;
;      to concatenate two patterns, all successors in the left
;      pattern which point to the nothen node must be changed to
;      point to the right pattern. however, this modification
;      must be performed on a copy of the left argument rather
;      than the left argument itself, since the left argument
;      may be pointed to by some other variable value.
;
;      accordingly, it is necessary to copy the left argument.
;      this is not a trivial process since we must avoid copying
;      nodes more than once and the pattern is a graph structure
;      the following algorithm is employed.
;
;      the stack is used to store a list of nodes which
;      have already been copied. the format of the entries on
;      this list consists of a two word block. the first word
;      is the old address and the second word is the address
;      of the copy. this list is searched by the pcopy
;      routine to avoid making duplicate copies. a trick is
;      used to accomplish the concatenation at the same time.
;      a special entry is made to start with on the stack. this
;      entry records that the nothen node has been copied
;      already and the address of its copy is the right pattern.
;      this automatically performs the correct replacements.
;
|pconc|prc|25,e|1,0||; entry point|24412
||zer|11,-(xs)|||; make room for one entry at bottom|24413
||mov|8,wc|7,xs||; store pointer to start of list|24414
||mov|11,-(xs)|21,=ndnth||; stack nothen node as old node|24415
||mov|11,-(xs)|7,xl||; store right arg as copy of nothen|24416
||mov|7,xt|7,xs||; initialize pointer to stack entries|24417
||jsr|6,pcopy|||; copy first node of left arg|24418
||mov|13,num02(xt)|8,wa||; store as result under list|24419
||ejc|||||24420
;
;      pconc (continued)
;
;      the following loop scans entries in the list and makes
;      sure that their successors have been copied.
;
|pcnc1|beq|7,xt|7,xs|6,pcnc2|; jump if all entries processed|24427
||mov|7,xr|11,-(xt)||; else load next old address|24428
||mov|7,xr|13,pthen(xr)||; load pointer to successor|24429
||jsr|6,pcopy|||; copy successor node|24430
||mov|7,xr|11,-(xt)||; load pointer to new node (copy)|24431
||mov|13,pthen(xr)|8,wa||; store ptr to new successor|24432
;
;      now check for special case of alternation node where
;      parm1 points to a node and must be copied like pthen.
;
||bne|9,(xr)|22,=p_alt|6,pcnc1|; loop back if not|24437
||mov|7,xr|13,parm1(xr)||; else load pointer to alternative|24438
||jsr|6,pcopy|||; copy it|24439
||mov|7,xr|9,(xt)||; restore ptr to new node|24440
||mov|13,parm1(xr)|8,wa||; store ptr to copied alternative|24441
||brn|6,pcnc1|||; loop back for next entry|24442
;
;      here at end of copy process
;
|pcnc2|mov|7,xs|8,wc||; restore stack pointer|24446
||mov|7,xr|10,(xs)+||; load pointer to copy|24447
||exi||||; return to pconc caller|24448
||enp||||; end procedure pconc|24449
||ejc|||||24450
;
;      pcopy -- copy a pattern node
;
;      pcopy is called from the pconc procedure to copy a single
;      pattern node. the copy is only carried out if the node
;      has not been copied already.
;
;      (xr)		     pointer to node to be copied
;      (xt)		     ptr to current loc in copy list
;      (wc)		     pointer to list of copied nodes
;      jsr  pcopy	     call to copy a node
;      (wa)		     pointer to copy
;      (wb,xr)		     destroyed
;
|pcopy|prc|25,n|1,0||; entry point|24465
||mov|8,wb|7,xt||; save xt|24466
||mov|7,xt|8,wc||; point to start of list|24467
;
;      loop to search list of nodes copied already
;
|pcop1|dca|7,xt|||; point to next entry on list|24471
||beq|7,xr|9,(xt)|6,pcop2|; jump if match|24472
||dca|7,xt|||; else skip over copied address|24473
||bne|7,xt|7,xs|6,pcop1|; loop back if more to test|24474
;
;      here if not in list, perform copy
;
||mov|8,wa|9,(xr)||; load first word of block|24478
||jsr|6,blkln|||; get length of block|24479
||mov|7,xl|7,xr||; save pointer to old node|24480
||jsr|6,alloc|||; allocate space for copy|24481
||mov|11,-(xs)|7,xl||; store old address on list|24482
||mov|11,-(xs)|7,xr||; store new address on list|24483
||chk||||; check for stack overflow|24484
||mvw||||; move words from old block to copy|24485
||mov|8,wa|9,(xs)||; load pointer to copy|24486
||brn|6,pcop3|||; jump to exit|24487
;
;      here if we find entry in list
;
|pcop2|mov|8,wa|11,-(xt)||; load address of copy from list|24491
;
;      common exit point
;
|pcop3|mov|7,xt|8,wb||; restore xt|24495
||exi||||; return to pcopy caller|24496
||enp||||; end procedure pcopy|24497
||ejc|||||24498
;
;      prflr -- print profile
;      prflr is called to print the contents of the profile
;      table in a fairly readable tabular format.
;
;      jsr  prflr	     call to print profile
;      (wa,ia)		     destroyed
;
|prflr|prc|25,e|1,0||;|24509
||bze|3,pfdmp|6,prfl4||; no printing if no profiling done|24510
||mov|11,-(xs)|7,xr||; preserve entry xr|24511
||mov|3,pfsvw|8,wb||; and also wb|24512
||jsr|6,prtpg|||; eject|24513
||mov|7,xr|21,=pfms1||; load msg /program profile/|24514
||jsr|6,prtst|||; and print it|24515
||jsr|6,prtnl|||; followed by newline|24516
||jsr|6,prtnl|||; and another|24517
||mov|7,xr|21,=pfms2||; point to first hdr|24518
||jsr|6,prtst|||; print it|24519
||jsr|6,prtnl|||; new line|24520
||mov|7,xr|21,=pfms3||; second hdr|24521
||jsr|6,prtst|||; print it|24522
||jsr|6,prtnl|||; new line|24523
||jsr|6,prtnl|||; and another blank line|24524
||zer|8,wb|||; initial stmt count|24525
||mov|7,xr|3,pftbl||; point to table origin|24526
||add|7,xr|19,*xndta||; bias past xnblk header (sgd07)|24527
;
;      loop here to print successive entries
;
|prfl1|icv|8,wb|||; bump stmt nr|24531
||ldi|9,(xr)|||; load nr of executions|24532
||ieq|6,prfl3|||; no printing if zero|24533
||mov|3,profs|18,=pfpd1||; point where to print|24534
||jsr|6,prtin|||; and print it|24535
||zer|3,profs|||; back to start of line|24536
||mti|8,wb|||; load stmt nr|24537
||jsr|6,prtin|||; print it there|24538
||mov|3,profs|18,=pfpd2||; and pad past count|24539
||ldi|13,cfp_i(xr)|||; load total exec time|24540
||jsr|6,prtin|||; print that too|24541
||ldi|13,cfp_i(xr)|||; reload time|24542
||mli|4,intth|||; convert to microsec|24543
||iov|6,prfl2|||; omit next bit if overflow|24544
||dvi|9,(xr)|||; divide by executions|24545
||mov|3,profs|18,=pfpd3||; pad last print|24546
||jsr|6,prtin|||; and print mcsec/execn|24547
;
;      merge after printing time
;
|prfl2|jsr|6,prtnl|||; thats another line|24551
;
;      here to go to next entry
;
|prfl3|add|7,xr|19,*pf_i2||; bump index ptr (sgd07)|24555
||blt|8,wb|3,pfnte|6,prfl1|; loop if more stmts|24556
||mov|7,xr|10,(xs)+||; restore callers xr|24557
||mov|8,wb|3,pfsvw||; and wb too|24558
;
;      here to exit
;
|prfl4|exi||||; return|24562
||enp||||; end of prflr|24563
||ejc|||||24564
;
;      prflu -- update an entry in the profile table
;
;      on entry, kvstn contains nr of stmt to profile
;
;      jsr  prflu	     call to update entry
;      (ia)		     destroyed
;
|prflu|prc|25,e|1,0||;|24573
||bnz|3,pffnc|6,pflu4||; skip if just entered function|24574
||mov|11,-(xs)|7,xr||; preserve entry xr|24575
||mov|3,pfsvw|8,wa||; save wa (sgd07)|24576
||bnz|3,pftbl|6,pflu2||; branch if table allocated|24577
;
;      here if space for profile table not yet allocated.
;      calculate size needed, allocate a static xnblk, and
;      initialize it all to zero.
;      the time taken for this will be attributed to the current
;      statement (assignment to keywd profile), but since the
;      timing for this statement is up the pole anyway, this
;      doesnt really matter...
;
||sub|3,pfnte|18,=num01||; adjust for extra count (sgd07)|24587
||mti|4,pfi2a|||; convrt entry size to int|24588
||sti|3,pfste|||; and store safely for later|24589
||mti|3,pfnte|||; load table length as integer|24590
||mli|3,pfste|||; multiply by entry size|24591
||mfi|8,wa|||; get back address-style|24592
||add|8,wa|18,=num02||; add on 2 word overhead|24593
||wtb|8,wa|||; convert the whole lot to bytes|24594
||jsr|6,alost|||; gimme the space|24595
||mov|3,pftbl|7,xr||; save block pointer|24596
||mov|10,(xr)+|22,=b_xnt||; put block type and ...|24597
||mov|10,(xr)+|8,wa||; ... length into header|24598
||mfi|8,wa|||; get back nr of wds in data area|24599
||lct|8,wa|8,wa||; load the counter|24600
;
;      loop here to zero the block data
;
|pflu1|zer|10,(xr)+|||; blank a word|24604
||bct|8,wa|6,pflu1||; and alllllll the rest|24605
;
;      end of allocation. merge back into routine
;
|pflu2|mti|3,kvstn|||; load nr of stmt just ended|24609
||sbi|4,intv1|||; make into index offset|24610
||mli|3,pfste|||; make offset of table entry|24611
||mfi|8,wa|||; convert to address|24612
||wtb|8,wa|||; get as baus|24613
||add|8,wa|19,*num02||; offset includes table header|24614
||mov|7,xr|3,pftbl||; get table start|24615
||bge|8,wa|13,num01(xr)|6,pflu3|; if out of table, skip it|24616
||add|7,xr|8,wa||; else point to entry|24617
||ldi|9,(xr)|||; get nr of executions so far|24618
||adi|4,intv1|||; nudge up one|24619
||sti|9,(xr)|||; and put back|24620
||jsr|6,systm|||; get time now|24621
||sti|3,pfetm|||; stash ending time|24622
||sbi|3,pfstm|||; subtract start time|24623
||adi|13,cfp_i(xr)|||; add cumulative time so far|24624
||sti|13,cfp_i(xr)|||; and put back new total|24625
||ldi|3,pfetm|||; load end time of this stmt ...|24626
||sti|3,pfstm|||; ... which is start time of next|24627
;
;      merge here to exit
;
|pflu3|mov|7,xr|10,(xs)+||; restore callers xr|24631
||mov|8,wa|3,pfsvw||; restore saved reg|24632
||exi||||; and return|24633
;
;      here if profile is suppressed because a program defined
;      function is about to be entered, and so the current stmt
;      has not yet finished
;
|pflu4|zer|3,pffnc|||; reset the condition flag|24639
||exi||||; and immediate return|24640
||enp||||; end of procedure prflu|24641
||ejc|||||24642
;
;      prpar - process print parameters
;
;      (wc)		     if nonzero associate terminal only
;      jsr  prpar	     call to process print parameters
;      (xl,xr,wa,wb,wc)	     destroyed
;
;      since memory allocation is undecided on initial call,
;      terminal cannot be associated. the entry with wc non-zero
;      is provided so a later call can be made to complete this.
;
|prpar|prc|25,e|1,0||; entry point|24655
||bnz|8,wc|6,prpa8||; jump to associate terminal|24656
||jsr|6,syspp|||; get print parameters|24657
||bnz|8,wb|6,prpa1||; jump if lines/page specified|24658
||mov|8,wb|3,mxint||; else use a large value|24659
||rsh|8,wb|1,1||; but not too large|24660
;
;      store line count/page
;
|prpa1|mov|3,lstnp|8,wb||; store number of lines/page|24664
||mov|3,lstlc|8,wb||; pretend page is full initially|24665
||zer|3,lstpg|||; clear page number|24666
||mov|8,wb|3,prlen||; get prior length if any|24667
||bze|8,wb|6,prpa2||; skip if no length|24668
||bgt|8,wa|8,wb|6,prpa3|; skip storing if too big|24669
;
;      store print buffer length
;
|prpa2|mov|3,prlen|8,wa||; store value|24673
;
;      process bits options
;
|prpa3|mov|8,wb|4,bits3||; bit 3 mask|24677
||anb|8,wb|8,wc||; get -nolist bit|24678
||zrb|8,wb|6,prpa4||; skip if clear|24679
||zer|3,cswls|||; set -nolist|24680
;
;      check if fail reports goto interactive channel
;
|prpa4|mov|8,wb|4,bits1||; bit 1 mask|24684
||anb|8,wb|8,wc||; get bit|24685
||mov|3,erich|8,wb||; store int. chan. error flag|24686
||mov|8,wb|4,bits2||; bit 2 mask|24687
||anb|8,wb|8,wc||; get bit|24688
||mov|3,prich|8,wb||; flag for std printer on int. chan.|24689
||mov|8,wb|4,bits4||; bit 4 mask|24690
||anb|8,wb|8,wc||; get bit|24691
||mov|3,cpsts|8,wb||; flag for compile stats suppressn.|24692
||mov|8,wb|4,bits5||; bit 5 mask|24693
||anb|8,wb|8,wc||; get bit|24694
||mov|3,exsts|8,wb||; flag for exec stats suppression|24695
||ejc|||||24696
;
;      prpar (continued)
;
||mov|8,wb|4,bits6||; bit 6 mask|24700
||anb|8,wb|8,wc||; get bit|24701
||mov|3,precl|8,wb||; extended/compact listing flag|24702
||sub|8,wa|18,=num08||; point 8 chars from line end|24703
||zrb|8,wb|6,prpa5||; jump if not extended|24704
||mov|3,lstpo|8,wa||; store for listing page headings|24705
;
;	continue option processing
;
|prpa5|mov|8,wb|4,bits7||; bit 7 mask|24709
||anb|8,wb|8,wc||; get bit 7|24710
||mov|3,cswex|8,wb||; set -noexecute if non-zero|24711
||mov|8,wb|4,bit10||; bit 10 mask|24712
||anb|8,wb|8,wc||; get bit 10|24713
||mov|3,headp|8,wb||; pretend printed to omit headers|24714
||mov|8,wb|4,bits9||; bit 9 mask|24715
||anb|8,wb|8,wc||; get bit 9|24716
||mov|3,prsto|8,wb||; keep it as std listing option|24717
||mov|8,wb|8,wc||; copy flags|24719
||rsh|8,wb|1,12||; right justify bit 13|24720
||anb|8,wb|4,bits1||; get bit|24721
||mov|3,kvcas|8,wb||; set -case|24722
||mov|8,wb|4,bit12||; bit 12 mask|24724
||anb|8,wb|8,wc||; get bit 12|24725
||mov|3,cswer|8,wb||; keep it as errors/noerrors option|24726
||zrb|8,wb|6,prpa6||; skip if clear|24727
||mov|8,wa|3,prlen||; get print buffer length|24728
||sub|8,wa|18,=num08||; point 8 chars from line end|24729
||mov|3,lstpo|8,wa||; store page offset|24730
;
;      check for -print/-noprint
;
|prpa6|mov|8,wb|4,bit11||; bit 11 mask|24734
||anb|8,wb|8,wc||; get bit 11|24735
||mov|3,cswpr|8,wb||; set -print if non-zero|24736
;
;      check for terminal
;
||anb|8,wc|4,bits8||; see if terminal to be activated|24740
||bnz|8,wc|6,prpa8||; jump if terminal required|24741
||bze|3,initr|6,prpa9||; jump if no terminal to detach|24742
||mov|7,xl|21,=v_ter||; ptr to /terminal/|24743
||jsr|6,gtnvr|||; get vrblk pointer|24744
||ppm||||; cant fail|24745
||mov|13,vrval(xr)|21,=nulls||; clear value of terminal|24746
||jsr|6,setvr|||; remove association|24747
||brn|6,prpa9|||; return|24748
;
;      associate terminal
;
|prpa8|mnz|3,initr|||; note terminal associated|24752
||bze|3,dnamb|6,prpa9||; cant if memory not organised|24753
||mov|7,xl|21,=v_ter||; point to terminal string|24754
||mov|8,wb|18,=trtou||; output trace type|24755
||jsr|6,inout|||; attach output trblk to vrblk|24756
||mov|11,-(xs)|7,xr||; stack trblk ptr|24757
||mov|7,xl|21,=v_ter||; point to terminal string|24758
||mov|8,wb|18,=trtin||; input trace type|24759
||jsr|6,inout|||; attach input trace blk|24760
||mov|13,vrval(xr)|10,(xs)+||; add output trblk to chain|24761
;
;      return point
;
|prpa9|exi||||; return|24765
||enp||||; end procedure prpar|24766
||ejc|||||24767
;
;      prtch -- print a character
;
;      prtch is used to print a single character
;
;      (wa)		     character to be printed
;      jsr  prtch	     call to print character
;
|prtch|prc|25,e|1,0||; entry point|24776
||mov|11,-(xs)|7,xr||; save xr|24777
||bne|3,profs|3,prlen|6,prch1|; jump if room in buffer|24778
||jsr|6,prtnl|||; else print this line|24779
;
;      here after making sure we have room
;
|prch1|mov|7,xr|3,prbuf||; point to print buffer|24783
||psc|7,xr|3,profs||; point to next character location|24784
||sch|8,wa|9,(xr)||; store new character|24785
||csc|7,xr|||; complete store characters|24786
||icv|3,profs|||; bump pointer|24787
||mov|7,xr|10,(xs)+||; restore entry xr|24788
||exi||||; return to prtch caller|24789
||enp||||; end procedure prtch|24790
||ejc|||||24791
;
;      prtic -- print to interactive channel
;
;      prtic is called to print the contents of the standard
;      print buffer to the interactive channel. it is only
;      called after prtst has set up the string for printing.
;      it does not clear the buffer.
;
;      jsr  prtic	     call for print
;      (wa,wb)		     destroyed
;
|prtic|prc|25,e|1,0||; entry point|24803
||mov|11,-(xs)|7,xr||; save xr|24804
||mov|7,xr|3,prbuf||; point to buffer|24805
||mov|8,wa|3,profs||; no of chars|24806
||jsr|6,syspi|||; print|24807
||ppm|6,prtc2|||; fail return|24808
;
;      return
;
|prtc1|mov|7,xr|10,(xs)+||; restore xr|24812
||exi||||; return|24813
;
;      error occured
;
|prtc2|zer|3,erich|||; prevent looping|24817
||erb|1,252|26,error on printing to interactive channel|||24818
||brn|6,prtc1|||; return|24819
||enp||||; procedure prtic|24820
||ejc|||||24821
;
;      prtis -- print to interactive and standard printer
;
;      prtis puts a line from the print buffer onto the
;      interactive channel (if any) and the standard printer.
;      it always prints to the standard printer but does
;      not duplicate lines if the standard printer is
;      interactive.  it clears down the print buffer.
;
;      jsr  prtis	     call for printing
;      (wa,wb)		     destroyed
;
|prtis|prc|25,e|1,0||; entry point|24834
||bnz|3,prich|6,prts1||; jump if standard printer is int.ch.|24835
||bze|3,erich|6,prts1||; skip if not doing int. error reps.|24836
||jsr|6,prtic|||; print to interactive channel|24837
;
;      merge and exit
;
|prts1|jsr|6,prtnl|||; print to standard printer|24841
||exi||||; return|24842
||enp||||; end procedure prtis|24843
||ejc|||||24844
;
;      prtin -- print an integer
;
;      prtin prints the integer value which is in the integer
;      accumulator. blocks built in dynamic storage
;      during this process are immediately deleted.
;
;      (ia)		     integer value to be printed
;      jsr  prtin	     call to print integer
;      (ia,ra)		     destroyed
;
|prtin|prc|25,e|1,0||; entry point|24856
||mov|11,-(xs)|7,xr||; save xr|24857
||jsr|6,icbld|||; build integer block|24858
||blo|7,xr|3,dnamb|6,prti1|; jump if icblk below dynamic|24859
||bhi|7,xr|3,dnamp|6,prti1|; jump if above dynamic|24860
||mov|3,dnamp|7,xr||; immediately delete it|24861
;
;      delete icblk from dynamic store
;
|prti1|mov|11,-(xs)|7,xr||; stack ptr for gtstg|24865
||jsr|6,gtstg|||; convert to string|24866
||ppm||||; convert error is impossible|24867
||mov|3,dnamp|7,xr||; reset pointer to delete scblk|24868
||jsr|6,prtst|||; print integer string|24869
||mov|7,xr|10,(xs)+||; restore entry xr|24870
||exi||||; return to prtin caller|24871
||enp||||; end procedure prtin|24872
||ejc|||||24873
;
;      prtmi -- print message and integer
;
;      prtmi is used to print messages together with an integer
;      value starting in column 15 (used by the routines at
;      the end of compilation).
;
;      jsr  prtmi	     call to print message and integer
;
|prtmi|prc|25,e|1,0||; entry point|24883
||jsr|6,prtst|||; print string message|24884
||mov|3,profs|18,=prtmf||; set column offset|24885
||jsr|6,prtin|||; print integer|24886
||jsr|6,prtnl|||; print line|24887
||exi||||; return to prtmi caller|24888
||enp||||; end procedure prtmi|24889
||ejc|||||24890
;
;      prtmm -- print memory used and available
;
;      prtmm is used to provide memory usage information in
;      both the end-of-compile and end-of-run statistics.
;
;      jsr  prtmm	     call to print memory stats
;
|prtmm|prc|25,e|1,0||;|24899
||mov|8,wa|3,dnamp||; next available loc|24900
||sub|8,wa|3,statb||; minus start|24901
||mti|8,wa|||; convert to integer|24906
||mov|7,xr|21,=encm1||; point to /memory used (words)/|24907
||jsr|6,prtmi|||; print message|24908
||mov|8,wa|3,dname||; end of memory|24909
||sub|8,wa|3,dnamp||; minus next available loc|24910
||mti|8,wa|||; convert to integer|24915
||mov|7,xr|21,=encm2||; point to /memory available (words)/|24916
||jsr|6,prtmi|||; print line|24917
||exi||||; return to prtmm caller|24918
||enp||||; end of procedure prtmm|24919
||ejc|||||24920
;
;      prtmx  -- as prtmi with extra copy to interactive chan.
;
;      jsr  prtmx	     call for printing
;      (wa,wb)		     destroyed
;
|prtmx|prc|25,e|1,0||; entry point|24927
||jsr|6,prtst|||; print string message|24928
||mov|3,profs|18,=prtmf||; set column offset|24929
||jsr|6,prtin|||; print integer|24930
||jsr|6,prtis|||; print line|24931
||exi||||; return|24932
||enp||||; end procedure prtmx|24933
||ejc|||||24934
;
;      prtnl -- print new line (end print line)
;
;      prtnl prints the contents of the print buffer, resets
;      the buffer to all blanks and resets the print pointer.
;
;      jsr  prtnl	     call to print line
;
|prtnl|prc|25,r|1,0||; entry point|24943
||bnz|3,headp|6,prnl0||; were headers printed|24944
||jsr|6,prtps|||; no - print them|24945
;
;      call syspr
;
|prnl0|mov|11,-(xs)|7,xr||; save entry xr|24949
||mov|3,prtsa|8,wa||; save wa|24950
||mov|3,prtsb|8,wb||; save wb|24951
||mov|7,xr|3,prbuf||; load pointer to buffer|24952
||mov|8,wa|3,profs||; load number of chars in buffer|24953
||jsr|6,syspr|||; call system print routine|24954
||ppm|6,prnl2|||; jump if failed|24955
||lct|8,wa|3,prlnw||; load length of buffer in words|24956
||add|7,xr|19,*schar||; point to chars of buffer|24957
||mov|8,wb|4,nullw||; get word of blanks|24958
;
;      loop to blank buffer
;
|prnl1|mov|10,(xr)+|8,wb||; store word of blanks, bump ptr|24962
||bct|8,wa|6,prnl1||; loop till all blanked|24963
;
;      exit point
;
||mov|8,wb|3,prtsb||; restore wb|24967
||mov|8,wa|3,prtsa||; restore wa|24968
||mov|7,xr|10,(xs)+||; restore entry xr|24969
||zer|3,profs|||; reset print buffer pointer|24970
||exi||||; return to prtnl caller|24971
;
;      file full or no output file for load module
;
|prnl2|bnz|3,prtef|6,prnl3||; jump if not first time|24975
||mnz|3,prtef|||; mark first occurrence|24976
||erb|1,253|26,print limit exceeded on standard output channel|||24977
;
;      stop at once
;
|prnl3|mov|8,wb|18,=nini8||; ending code|24981
||mov|8,wa|3,kvstn||; statement number|24982
||mov|7,xl|3,r_fcb||; get fcblk chain head|24983
||jsr|6,sysej|||; stop|24984
||enp||||; end procedure prtnl|24985
||ejc|||||24986
;
;      prtnm -- print variable name
;
;      prtnm is used to print a character representation of the
;      name of a variable (not a value of datatype name)
;      names of pseudo-variables may not be passed to prtnm.
;
;      (xl)		     name base
;      (wa)		     name offset
;      jsr  prtnm	     call to print name
;      (wb,wc,ra)	     destroyed
;
|prtnm|prc|25,r|1,0||; entry point (recursive, see prtvl)|24999
||mov|11,-(xs)|8,wa||; save wa (offset is collectable)|25000
||mov|11,-(xs)|7,xr||; save entry xr|25001
||mov|11,-(xs)|7,xl||; save name base|25002
||bhi|7,xl|3,state|6,prn02|; jump if not natural variable|25003
;
;      here for natural variable name, recognized by the fact
;      that the name base points into the static area.
;
||mov|7,xr|7,xl||; point to vrblk|25008
||jsr|6,prtvn|||; print name of variable|25009
;
;      common exit point
;
|prn01|mov|7,xl|10,(xs)+||; restore name base|25013
||mov|7,xr|10,(xs)+||; restore entry value of xr|25014
||mov|8,wa|10,(xs)+||; restore wa|25015
||exi||||; return to prtnm caller|25016
;
;      here for case of non-natural variable
;
|prn02|mov|8,wb|8,wa||; copy name offset|25020
||bne|9,(xl)|22,=b_pdt|6,prn03|; jump if array or table|25021
;
;      for program defined datatype, prt fld name, left paren
;
||mov|7,xr|13,pddfp(xl)||; load pointer to dfblk|25025
||add|7,xr|8,wa||; add name offset|25026
||mov|7,xr|13,pdfof(xr)||; load vrblk pointer for field|25027
||jsr|6,prtvn|||; print field name|25028
||mov|8,wa|18,=ch_pp||; load left paren|25029
||jsr|6,prtch|||; print character|25030
||ejc|||||25031
;
;      prtnm (continued)
;
;      now we print an identifying name for the object if one
;      can be found. the following code searches for a natural
;      variable which contains this object as value. if such a
;      variable is found, its name is printed, else the value
;      of the object (as printed by prtvl) is used instead.
;
;      first we point to the parent tbblk if this is the case of
;      a table element. to do this, chase down the trnxt chain.
;
|prn03|bne|9,(xl)|22,=b_tet|6,prn04|; jump if we got there (or not te)|25044
||mov|7,xl|13,tenxt(xl)||; else move out on chain|25045
||brn|6,prn03|||; and loop back|25046
;
;      now we are ready for the search. to speed things up in
;      the case of calls from dump where the same name base
;      will occur repeatedly while dumping an array or table,
;      we remember the last vrblk pointer found in prnmv. so
;      first check to see if we have this one again.
;
|prn04|mov|7,xr|3,prnmv||; point to vrblk we found last time|25054
||mov|8,wa|3,hshtb||; point to hash table in case not|25055
||brn|6,prn07|||; jump into search for special check|25056
;
;      loop through hash slots
;
|prn05|mov|7,xr|8,wa||; copy slot pointer|25060
||ica|8,wa|||; bump slot pointer|25061
||sub|7,xr|19,*vrnxt||; introduce standard vrblk offset|25062
;
;      loop through vrblks on one hash chain
;
|prn06|mov|7,xr|13,vrnxt(xr)||; point to next vrblk on hash chain|25066
;
;      merge here first time to check block we found last time
;
|prn07|mov|8,wc|7,xr||; copy vrblk pointer|25070
||bze|8,wc|6,prn09||; jump if chain end (or prnmv zero)|25071
||ejc|||||25072
;
;      prtnm (continued)
;
;      loop to find value (chase down possible trblk chain)
;
|prn08|mov|7,xr|13,vrval(xr)||; load value|25078
||beq|9,(xr)|22,=b_trt|6,prn08|; loop if that was a trblk|25079
;
;      now we have the value, is this the block we want
;
||beq|7,xr|7,xl|6,prn10|; jump if this matches the name base|25083
||mov|7,xr|8,wc||; else point back to that vrblk|25084
||brn|6,prn06|||; and loop back|25085
;
;      here to move to next hash slot
;
|prn09|blt|8,wa|3,hshte|6,prn05|; loop back if more to go|25089
||mov|7,xr|7,xl||; else not found, copy value pointer|25090
||jsr|6,prtvl|||; print value|25091
||brn|6,prn11|||; and merge ahead|25092
;
;      here when we find a matching entry
;
|prn10|mov|7,xr|8,wc||; copy vrblk pointer|25096
||mov|3,prnmv|7,xr||; save for next time in|25097
||jsr|6,prtvn|||; print variable name|25098
;
;      merge here if no entry found
;
|prn11|mov|8,wc|9,(xl)||; load first word of name base|25102
||bne|8,wc|22,=b_pdt|6,prn13|; jump if not program defined|25103
;
;      for program defined datatype, add right paren and exit
;
||mov|8,wa|18,=ch_rp||; load right paren, merge|25107
;
;      merge here to print final right paren or bracket
;
|prn12|jsr|6,prtch|||; print final character|25111
||mov|8,wa|8,wb||; restore name offset|25112
||brn|6,prn01|||; merge back to exit|25113
||ejc|||||25114
;
;      prtnm (continued)
;
;      here for array or table
;
|prn13|mov|8,wa|18,=ch_bb||; load left bracket|25120
||jsr|6,prtch|||; and print it|25121
||mov|7,xl|9,(xs)||; restore block pointer|25122
||mov|8,wc|9,(xl)||; load type word again|25123
||bne|8,wc|22,=b_tet|6,prn15|; jump if not table|25124
;
;      here for table, print subscript value
;
||mov|7,xr|13,tesub(xl)||; load subscript value|25128
||mov|7,xl|8,wb||; save name offset|25129
||jsr|6,prtvl|||; print subscript value|25130
||mov|8,wb|7,xl||; restore name offset|25131
;
;      merge here from array case to print right bracket
;
|prn14|mov|8,wa|18,=ch_rb||; load right bracket|25135
||brn|6,prn12|||; merge back to print it|25136
;
;      here for array or vector, to print subscript(s)
;
|prn15|mov|8,wa|8,wb||; copy name offset|25140
||btw|8,wa|||; convert to words|25141
||beq|8,wc|22,=b_art|6,prn16|; jump if arblk|25142
;
;      here for vector
;
||sub|8,wa|18,=vcvlb||; adjust for standard fields|25146
||mti|8,wa|||; move to integer accum|25147
||jsr|6,prtin|||; print linear subscript|25148
||brn|6,prn14|||; merge back for right bracket|25149
||ejc|||||25150
;
;      prtnm (continued)
;
;      here for array. first calculate absolute subscript
;      offsets by successive divisions by the dimension values.
;      this must be done right to left since the elements are
;      stored row-wise. the subscripts are stacked as integers.
;
|prn16|mov|8,wc|13,arofs(xl)||; load length of bounds info|25159
||ica|8,wc|||; adjust for arpro field|25160
||btw|8,wc|||; convert to words|25161
||sub|8,wa|8,wc||; get linear zero-origin subscript|25162
||mti|8,wa|||; get integer value|25163
||lct|8,wa|13,arndm(xl)||; set num of dimensions as loop count|25164
||add|7,xl|13,arofs(xl)||; point past bounds information|25165
||sub|7,xl|19,*arlbd||; set ok offset for proper ptr later|25166
;
;      loop to stack subscript offsets
;
|prn17|sub|7,xl|19,*ardms||; point to next set of bounds|25170
||sti|3,prnsi|||; save current offset|25171
||rmi|13,ardim(xl)|||; get remainder on dividing by dimens|25172
||mfi|11,-(xs)|||; store on stack (one word)|25173
||ldi|3,prnsi|||; reload argument|25174
||dvi|13,ardim(xl)|||; divide to get quotient|25175
||bct|8,wa|6,prn17||; loop till all stacked|25176
||zer|7,xr|||; set offset to first set of bounds|25177
||lct|8,wb|13,arndm(xl)||; load count of dims to control loop|25178
||brn|6,prn19|||; jump into print loop|25179
;
;      loop to print subscripts from stack adjusting by adding
;      the appropriate low bound value from the arblk
;
|prn18|mov|8,wa|18,=ch_cm||; load a comma|25184
||jsr|6,prtch|||; print it|25185
;
;      merge here first time in (no comma required)
;
|prn19|mti|10,(xs)+|||; load subscript offset as integer|25189
||add|7,xl|7,xr||; point to current lbd|25190
||adi|13,arlbd(xl)|||; add lbd to get signed subscript|25191
||sub|7,xl|7,xr||; point back to start of arblk|25192
||jsr|6,prtin|||; print subscript|25193
||add|7,xr|19,*ardms||; bump offset to next bounds|25194
||bct|8,wb|6,prn18||; loop back till all printed|25195
||brn|6,prn14|||; merge back to print right bracket|25196
||enp||||; end procedure prtnm|25197
||ejc|||||25198
;
;      prtnv -- print name value
;
;      prtnv is used by the trace and dump routines to print
;      a line of the form
;
;      name = value
;
;      note that the name involved can never be a pseudo-var
;
;      (xl)		     name base
;      (wa)		     name offset
;      jsr  prtnv	     call to print name = value
;      (wb,wc,ra)	     destroyed
;
|prtnv|prc|25,e|1,0||; entry point|25214
||jsr|6,prtnm|||; print argument name|25215
||mov|11,-(xs)|7,xr||; save entry xr|25216
||mov|11,-(xs)|8,wa||; save name offset (collectable)|25217
||mov|7,xr|21,=tmbeb||; point to blank equal blank|25218
||jsr|6,prtst|||; print it|25219
||mov|7,xr|7,xl||; copy name base|25220
||add|7,xr|8,wa||; point to value|25221
||mov|7,xr|9,(xr)||; load value pointer|25222
||jsr|6,prtvl|||; print value|25223
||jsr|6,prtnl|||; terminate line|25224
||mov|8,wa|10,(xs)+||; restore name offset|25225
||mov|7,xr|10,(xs)+||; restore entry xr|25226
||exi||||; return to caller|25227
||enp||||; end procedure prtnv|25228
||ejc|||||25229
;
;      prtpg  -- print a page throw
;
;      prints a page throw or a few blank lines on the standard
;      listing channel depending on the listing options chosen.
;
;      jsr  prtpg	     call for page eject
;
|prtpg|prc|25,e|1,0||; entry point|25238
||beq|3,stage|18,=stgxt|6,prp01|; jump if execution time|25239
||bze|3,lstlc|6,prp06||; return if top of page already|25240
||zer|3,lstlc|||; clear line count|25241
;
;      check type of listing
;
|prp01|mov|11,-(xs)|7,xr||; preserve xr|25245
||bnz|3,prstd|6,prp02||; eject if flag set|25246
||bnz|3,prich|6,prp03||; jump if interactive listing channel|25247
||bze|3,precl|6,prp03||; jump if compact listing|25248
;
;      perform an eject
;
|prp02|jsr|6,sysep|||; eject|25252
||brn|6,prp04|||; merge|25253
;
;      compact or interactive channel listing. cant print
;      blanks until check made for headers printed and flag set.
;
;
|prp03|mov|7,xr|3,headp||; remember headp|25259
||mnz|3,headp|||; set to avoid repeated prtpg calls|25260
||jsr|6,prtnl|||; print blank line|25261
||jsr|6,prtnl|||; print blank line|25262
||jsr|6,prtnl|||; print blank line|25263
||mov|3,lstlc|18,=num03||; count blank lines|25264
||mov|3,headp|7,xr||; restore header flag|25265
||ejc|||||25266
;
;      prptg (continued)
;
;      print the heading
;
|prp04|bnz|3,headp|6,prp05||; jump if header listed|25272
||mnz|3,headp|||; mark headers printed|25273
||mov|11,-(xs)|7,xl||; keep xl|25274
||mov|7,xr|21,=headr||; point to listing header|25275
||jsr|6,prtst|||; place it|25276
||jsr|6,sysid|||; get system identification|25277
||jsr|6,prtst|||; append extra chars|25278
||jsr|6,prtnl|||; print it|25279
||mov|7,xr|7,xl||; extra header line|25280
||jsr|6,prtst|||; place it|25281
||jsr|6,prtnl|||; print it|25282
||jsr|6,prtnl|||; print a blank|25283
||jsr|6,prtnl|||; and another|25284
||add|3,lstlc|18,=num04||; four header lines printed|25285
||mov|7,xl|10,(xs)+||; restore xl|25286
;
;      merge if header not printed
;
|prp05|mov|7,xr|10,(xs)+||; restore xr|25290
;
;      return
;
|prp06|exi||||; return|25294
||enp||||; end procedure prtpg|25295
||ejc|||||25296
;
;      prtps - print page with test for standard listing option
;
;      if the standard listing option is selected, insist that
;      an eject be done
;
;      jsr  prtps	     call for eject
;
|prtps|prc|25,e|1,0||; entry point|25305
||mov|3,prstd|3,prsto||; copy option flag|25306
||jsr|6,prtpg|||; print page|25307
||zer|3,prstd|||; clear flag|25308
||exi||||; return|25309
||enp||||; end procedure prtps|25310
||ejc|||||25311
;
;      prtsn -- print statement number
;
;      prtsn is used to initiate a print trace line by printing
;      asterisks and the current statement number. the actual
;      format of the output generated is.
;
;      ***nnnnn**** iii.....iiii
;
;      nnnnn is the statement number with leading zeros replaced
;      by asterisks (e.g. *******9****)
;
;      iii...iii represents a variable length output consisting
;      of a number of letter i characters equal to fnclevel.
;
;      jsr  prtsn	     call to print statement number
;      (wc)		     destroyed
;
|prtsn|prc|25,e|1,0||; entry point|25330
||mov|11,-(xs)|7,xr||; save entry xr|25331
||mov|3,prsna|8,wa||; save entry wa|25332
||mov|7,xr|21,=tmasb||; point to asterisks|25333
||jsr|6,prtst|||; print asterisks|25334
||mov|3,profs|18,=num04||; point into middle of asterisks|25335
||mti|3,kvstn|||; load statement number as integer|25336
||jsr|6,prtin|||; print integer statement number|25337
||mov|3,profs|18,=prsnf||; point past asterisks plus blank|25338
||mov|7,xr|3,kvfnc||; get fnclevel|25339
||mov|8,wa|18,=ch_li||; set letter i|25340
;
;      loop to generate letter i fnclevel times
;
|prsn1|bze|7,xr|6,prsn2||; jump if all set|25344
||jsr|6,prtch|||; else print an i|25345
||dcv|7,xr|||; decrement counter|25346
||brn|6,prsn1|||; loop back|25347
;
;      merge with all letter i characters generated
;
|prsn2|mov|8,wa|18,=ch_bl||; get blank|25351
||jsr|6,prtch|||; print blank|25352
||mov|8,wa|3,prsna||; restore entry wa|25353
||mov|7,xr|10,(xs)+||; restore entry xr|25354
||exi||||; return to prtsn caller|25355
||enp||||; end procedure prtsn|25356
||ejc|||||25357
;
;      prtst -- print string
;
;      prtst places a string of characters in the print buffer
;
;      see prtnl for global locations used
;
;      note that the first word of the block (normally b_scl)
;      is not used and need not be set correctly (see prtvn)
;
;      (xr)		     string to be printed
;      jsr  prtst	     call to print string
;      (profs)		     updated past chars placed
;
|prtst|prc|25,r|1,0||; entry point|25372
||bnz|3,headp|6,prst0||; were headers printed|25373
||jsr|6,prtps|||; no - print them|25374
;
;      call syspr
;
|prst0|mov|3,prsva|8,wa||; save wa|25378
||mov|3,prsvb|8,wb||; save wb|25379
||zer|8,wb|||; set chars printed count to zero|25380
;
;      loop to print successive lines for long string
;
|prst1|mov|8,wa|13,sclen(xr)||; load string length|25384
||sub|8,wa|8,wb||; subtract count of chars already out|25385
||bze|8,wa|6,prst4||; jump to exit if none left|25386
||mov|11,-(xs)|7,xl||; else stack entry xl|25387
||mov|11,-(xs)|7,xr||; save argument|25388
||mov|7,xl|7,xr||; copy for eventual move|25389
||mov|7,xr|3,prlen||; load print buffer length|25390
||sub|7,xr|3,profs||; get chars left in print buffer|25391
||bnz|7,xr|6,prst2||; skip if room left on this line|25392
||jsr|6,prtnl|||; else print this line|25393
||mov|7,xr|3,prlen||; and set full width available|25394
||ejc|||||25395
;
;      prtst (continued)
;
;      here with chars to print and some room in buffer
;
|prst2|blo|8,wa|7,xr|6,prst3|; jump if room for rest of string|25401
||mov|8,wa|7,xr||; else set to fill line|25402
;
;      merge here with character count in wa
;
|prst3|mov|7,xr|3,prbuf||; point to print buffer|25406
||plc|7,xl|8,wb||; point to location in string|25407
||psc|7,xr|3,profs||; point to location in buffer|25408
||add|8,wb|8,wa||; bump string chars count|25409
||add|3,profs|8,wa||; bump buffer pointer|25410
||mov|3,prsvc|8,wb||; preserve char counter|25411
||mvc||||; move characters to buffer|25412
||mov|8,wb|3,prsvc||; recover char counter|25413
||mov|7,xr|10,(xs)+||; restore argument pointer|25414
||mov|7,xl|10,(xs)+||; restore entry xl|25415
||brn|6,prst1|||; loop back to test for more|25416
;
;      here to exit after printing string
;
|prst4|mov|8,wb|3,prsvb||; restore entry wb|25420
||mov|8,wa|3,prsva||; restore entry wa|25421
||exi||||; return to prtst caller|25422
||enp||||; end procedure prtst|25423
||ejc|||||25424
;
;      prttr -- print to terminal
;
;      called to print contents of standard print buffer to
;      online terminal. clears buffer down and resets profs.
;
;      jsr  prttr	     call for print
;      (wa,wb)		     destroyed
;
|prttr|prc|25,e|1,0||; entry point|25434
||mov|11,-(xs)|7,xr||; save xr|25435
||jsr|6,prtic|||; print buffer contents|25436
||mov|7,xr|3,prbuf||; point to print bfr to clear it|25437
||lct|8,wa|3,prlnw||; get buffer length|25438
||add|7,xr|19,*schar||; point past scblk header|25439
||mov|8,wb|4,nullw||; get blanks|25440
;
;      loop to clear buffer
;
|prtt1|mov|10,(xr)+|8,wb||; clear a word|25444
||bct|8,wa|6,prtt1||; loop|25445
||zer|3,profs|||; reset profs|25446
||mov|7,xr|10,(xs)+||; restore xr|25447
||exi||||; return|25448
||enp||||; end procedure prttr|25449
||ejc|||||25450
;
;      prtvl -- print a value
;
;      prtvl places an appropriate character representation of
;      a data value in the print buffer for dump/trace use.
;
;      (xr)		     value to be printed
;      jsr  prtvl	     call to print value
;      (wa,wb,wc,ra)	     destroyed
;
|prtvl|prc|25,r|1,0||; entry point, recursive|25461
||mov|11,-(xs)|7,xl||; save entry xl|25462
||mov|11,-(xs)|7,xr||; save argument|25463
||chk||||; check for stack overflow|25464
;
;      loop back here after finding a trap block (trblk)
;
|prv01|mov|3,prvsi|13,idval(xr)||; copy idval (if any)|25468
||mov|7,xl|9,(xr)||; load first word of block|25469
||lei|7,xl|||; load entry point id|25470
||bsw|7,xl|2,bl__t|6,prv02|; switch on block type|25471
||iff|2,bl_ar|6,prv05||; arblk|25489
||iff|1,1|6,prv02|||25489
||iff|1,2|6,prv02|||25489
||iff|2,bl_ic|6,prv08||; icblk|25489
||iff|2,bl_nm|6,prv09||; nmblk|25489
||iff|1,5|6,prv02|||25489
||iff|1,6|6,prv02|||25489
||iff|1,7|6,prv02|||25489
||iff|2,bl_rc|6,prv08||; rcblk|25489
||iff|2,bl_sc|6,prv11||; scblk|25489
||iff|2,bl_se|6,prv12||; seblk|25489
||iff|2,bl_tb|6,prv13||; tbblk|25489
||iff|2,bl_vc|6,prv13||; vcblk|25489
||iff|1,13|6,prv02|||25489
||iff|1,14|6,prv02|||25489
||iff|1,15|6,prv02|||25489
||iff|2,bl_pd|6,prv10||; pdblk|25489
||iff|2,bl_tr|6,prv04||; trblk|25489
||esw||||; end of switch on block type|25489
;
;      here for blocks for which we just print datatype name
;
|prv02|jsr|6,dtype|||; get datatype name|25493
||jsr|6,prtst|||; print datatype name|25494
;
;      common exit point
;
|prv03|mov|7,xr|10,(xs)+||; reload argument|25498
||mov|7,xl|10,(xs)+||; restore xl|25499
||exi||||; return to prtvl caller|25500
;
;      here for trblk
;
|prv04|mov|7,xr|13,trval(xr)||; load real value|25504
||brn|6,prv01|||; and loop back|25505
||ejc|||||25506
;
;      prtvl (continued)
;
;      here for array (arblk)
;
;      print array ( prototype ) blank number idval
;
|prv05|mov|7,xl|7,xr||; preserve argument|25514
||mov|7,xr|21,=scarr||; point to datatype name (array)|25515
||jsr|6,prtst|||; print it|25516
||mov|8,wa|18,=ch_pp||; load left paren|25517
||jsr|6,prtch|||; print left paren|25518
||add|7,xl|13,arofs(xl)||; point to prototype|25519
||mov|7,xr|9,(xl)||; load prototype|25520
||jsr|6,prtst|||; print prototype|25521
;
;      vcblk, tbblk, bcblk merge here for ) blank number idval
;
|prv06|mov|8,wa|18,=ch_rp||; load right paren|25525
||jsr|6,prtch|||; print right paren|25526
;
;      pdblk merges here to print blank number idval
;
|prv07|mov|8,wa|18,=ch_bl||; load blank|25530
||jsr|6,prtch|||; print it|25531
||mov|8,wa|18,=ch_nm||; load number sign|25532
||jsr|6,prtch|||; print it|25533
||mti|3,prvsi|||; get idval|25534
||jsr|6,prtin|||; print id number|25535
||brn|6,prv03|||; back to exit|25536
;
;      here for integer (icblk), real (rcblk)
;
;      print character representation of value
;
|prv08|mov|11,-(xs)|7,xr||; stack argument for gtstg|25542
||jsr|6,gtstg|||; convert to string|25543
||ppm||||; error return is impossible|25544
||jsr|6,prtst|||; print the string|25545
||mov|3,dnamp|7,xr||; delete garbage string from storage|25546
||brn|6,prv03|||; back to exit|25547
||ejc|||||25548
;
;      prtvl (continued)
;
;      name (nmblk)
;
;      for pseudo-variable, just print datatype name (name)
;      for all other names, print dot followed by name rep
;
|prv09|mov|7,xl|13,nmbas(xr)||; load name base|25557
||mov|8,wa|9,(xl)||; load first word of block|25558
||beq|8,wa|22,=b_kvt|6,prv02|; just print name if keyword|25559
||beq|8,wa|22,=b_evt|6,prv02|; just print name if expression var|25560
||mov|8,wa|18,=ch_dt||; else get dot|25561
||jsr|6,prtch|||; and print it|25562
||mov|8,wa|13,nmofs(xr)||; load name offset|25563
||jsr|6,prtnm|||; print name|25564
||brn|6,prv03|||; back to exit|25565
;
;      program datatype (pdblk)
;
;      print datatype name ch_bl ch_nm idval
;
|prv10|jsr|6,dtype|||; get datatype name|25571
||jsr|6,prtst|||; print datatype name|25572
||brn|6,prv07|||; merge back to print id|25573
;
;      here for string (scblk)
;
;      print quote string-characters quote
;
|prv11|mov|8,wa|18,=ch_sq||; load single quote|25579
||jsr|6,prtch|||; print quote|25580
||jsr|6,prtst|||; print string value|25581
||jsr|6,prtch|||; print another quote|25582
||brn|6,prv03|||; back to exit|25583
||ejc|||||25584
;
;      prtvl (continued)
;
;      here for simple expression (seblk)
;
;      print asterisk variable-name
;
|prv12|mov|8,wa|18,=ch_as||; load asterisk|25592
||jsr|6,prtch|||; print asterisk|25593
||mov|7,xr|13,sevar(xr)||; load variable pointer|25594
||jsr|6,prtvn|||; print variable name|25595
||brn|6,prv03|||; jump back to exit|25596
;
;      here for table (tbblk) and array (vcblk)
;
;      print datatype ( prototype ) blank number idval
;
|prv13|mov|7,xl|7,xr||; preserve argument|25602
||jsr|6,dtype|||; get datatype name|25603
||jsr|6,prtst|||; print datatype name|25604
||mov|8,wa|18,=ch_pp||; load left paren|25605
||jsr|6,prtch|||; print left paren|25606
||mov|8,wa|13,tblen(xl)||; load length of block (=vclen)|25607
||btw|8,wa|||; convert to word count|25608
||sub|8,wa|18,=tbsi_||; allow for standard fields|25609
||beq|9,(xl)|22,=b_tbt|6,prv14|; jump if table|25610
||add|8,wa|18,=vctbd||; for vcblk, adjust size|25611
;
;      print prototype
;
|prv14|mti|8,wa|||; move as integer|25615
||jsr|6,prtin|||; print integer prototype|25616
||brn|6,prv06|||; merge back for rest|25617
||enp||||; end procedure prtvl|25640
||ejc|||||25641
;
;      prtvn -- print natural variable name
;
;      prtvn prints the name of a natural variable
;
;      (xr)		     pointer to vrblk
;      jsr  prtvn	     call to print variable name
;
|prtvn|prc|25,e|1,0||; entry point|25650
||mov|11,-(xs)|7,xr||; stack vrblk pointer|25651
||add|7,xr|19,*vrsof||; point to possible string name|25652
||bnz|13,sclen(xr)|6,prvn1||; jump if not system variable|25653
||mov|7,xr|13,vrsvo(xr)||; point to svblk with name|25654
;
;      merge here with dummy scblk pointer in xr
;
|prvn1|jsr|6,prtst|||; print string name of variable|25658
||mov|7,xr|10,(xs)+||; restore vrblk pointer|25659
||exi||||; return to prtvn caller|25660
||enp||||; end procedure prtvn|25661
||ejc|||||25664
;
;      rcbld -- build a real block
;
;      (ra)		     real value for rcblk
;      jsr  rcbld	     call to build real block
;      (xr)		     pointer to result rcblk
;      (wa)		     destroyed
;
|rcbld|prc|25,e|1,0||; entry point|25673
||mov|7,xr|3,dnamp||; load pointer to next available loc|25674
||add|7,xr|19,*rcsi_||; point past new rcblk|25675
||blo|7,xr|3,dname|6,rcbl1|; jump if there is room|25676
||mov|8,wa|19,*rcsi_||; else load rcblk length|25677
||jsr|6,alloc|||; use standard allocator to get block|25678
||add|7,xr|8,wa||; point past block to merge|25679
;
;      merge here with xr pointing past the block obtained
;
|rcbl1|mov|3,dnamp|7,xr||; set new pointer|25683
||sub|7,xr|19,*rcsi_||; point back to start of block|25684
||mov|9,(xr)|22,=b_rcl||; store type word|25685
||str|13,rcval(xr)|||; store real value in rcblk|25686
||exi||||; return to rcbld caller|25687
||enp||||; end procedure rcbld|25688
||ejc|||||25690
;
;      readr -- read next source image at compile time
;
;      readr is used to read the next source image. to process
;      continuation cards properly, the compiler must read one
;      line ahead. thus readr does not destroy the current image
;      see also the nexts routine which actually gets the image.
;
;      jsr  readr	     call to read next image
;      (xr)		     ptr to next image (0 if none)
;      (r_cni)		     copy of pointer
;      (wa,wb,wc,xl)	     destroyed
;
|readr|prc|25,e|1,0||; entry point|25704
||mov|7,xr|3,r_cni||; get ptr to next image|25705
||bnz|7,xr|6,read3||; exit if already read|25706
||bnz|3,cnind|6,reada||; if within include file|25708
||bne|3,stage|18,=stgic|6,read3|; exit if not initial compile|25710
|reada|mov|8,wa|3,cswin||; max read length|25711
||zer|7,xl|||; clear any dud value in xl|25712
||jsr|6,alocs|||; allocate buffer|25713
||jsr|6,sysrd|||; read input image|25714
||ppm|6,read4|||; jump if eof or new file name|25715
||icv|3,rdnln|||; increment next line number|25716
||dcv|3,polct|||; test if time to poll interface|25718
||bnz|3,polct|6,read0||; not yet|25719
||zer|8,wa|||; =0 for poll|25720
||mov|8,wb|3,rdnln||; line number|25721
||jsr|6,syspl|||; allow interactive access|25722
||err|1,320|26,user interrupt|||25723
||ppm||||; single step|25724
||ppm||||; expression evaluation|25725
||mov|3,polcs|8,wa||; new countdown start value|25726
||mov|3,polct|8,wa||; new counter value|25727
|read0|ble|13,sclen(xr)|3,cswin|6,read1|; use smaller of string lnth ...|25729
||mov|13,sclen(xr)|3,cswin||; ... and xxx of -inxxx|25730
;
;      perform the trim
;
|read1|mnz|8,wb|||; set trimr to perform trim|25734
||jsr|6,trimr|||; trim trailing blanks|25735
;
;      merge here after read
;
|read2|mov|3,r_cni|7,xr||; store copy of pointer|25739
;
;      merge here if no read attempted
;
|read3|exi||||; return to readr caller|25743
;
;      here on end of file or new source file name.
;      if this is a new source file name, the r_sfn table will
;      be augmented with a new table entry consisting of the
;      current compiler statement number as subscript, and the
;      file name as value.
;
|read4|bze|13,sclen(xr)|6,read5||; jump if true end of file|25752
||zer|8,wb|||; new source file name|25753
||mov|3,rdnln|8,wb||; restart line counter for new file|25754
||jsr|6,trimr|||; remove unused space in block|25755
||jsr|6,newfn|||; record new file name|25756
||brn|6,reada|||; now reissue read for record data|25757
;
;      here on end of file
;
|read5|mov|3,dnamp|7,xr||; pop unused scblk|25761
||bze|3,cnind|6,read6||; jump if not within an include file|25763
||zer|7,xl|||; eof within include file|25764
||jsr|6,sysif|||; switch stream back to previous file|25765
||ppm|||||25766
||mov|8,wa|3,cnind||; restore prev line number, file name|25767
||add|8,wa|18,=vcvlb||; vector offset in words|25768
||wtb|8,wa|||; convert to bytes|25769
||mov|7,xr|3,r_ifa||; file name array|25770
||add|7,xr|8,wa||; ptr to element|25771
||mov|3,r_sfc|9,(xr)||; change source file name|25772
||mov|9,(xr)|21,=nulls||; release scblk|25773
||mov|7,xr|3,r_ifl||; line number array|25774
||add|7,xr|8,wa||; ptr to element|25775
||mov|7,xl|9,(xr)||; icblk containing saved line number|25776
||ldi|13,icval(xl)|||; line number integer|25777
||mfi|3,rdnln|||; change source line number|25778
||mov|9,(xr)|21,=inton||; release icblk|25779
||dcv|3,cnind|||; decrement nesting level|25780
||mov|8,wb|3,cmpsn||; current statement number|25781
||icv|8,wb|||; anticipate end of previous stmt|25782
||mti|8,wb|||; convert to integer|25783
||jsr|6,icbld|||; build icblk for stmt number|25784
||mov|7,xl|3,r_sfn||; file name table|25785
||mnz|8,wb|||; lookup statement number by name|25786
||jsr|6,tfind|||; allocate new teblk|25787
||ppm||||; always possible to allocate block|25788
||mov|13,teval(xl)|3,r_sfc||; record file name as entry value|25789
||beq|3,stage|18,=stgic|6,reada|; if initial compile, reissue read|25790
||bnz|3,cnind|6,reada||; still reading from include file|25791
;
;      outer nesting of execute-time compile of -include
;      resume with any string remaining prior to -include.
;
||mov|7,xl|3,r_ici||; restore code argument string|25796
||zer|3,r_ici|||; release original string|25797
||mov|8,wa|3,cnsil||; get length of string|25798
||mov|8,wb|3,cnspt||; offset of characters left|25799
||sub|8,wa|8,wb||; number of characters left|25800
||mov|3,scnil|8,wa||; set new scan length|25801
||zer|3,scnpt|||; scan from start of substring|25802
||jsr|6,sbstr|||; create substring of remainder|25803
||mov|3,r_cim|7,xr||; set scan image|25804
||brn|6,read2|||; return|25805
|read6|zer|7,xr|||; zero ptr as result|25821
||brn|6,read2|||; merge|25822
||enp||||; end procedure readr|25823
||ejc|||||25824
;
;      sbstr -- build a substring
;
;      (xl)		     ptr to scblk/bfblk with chars
;      (wa)		     number of chars in substring
;      (wb)		     offset to first char in scblk
;      jsr  sbstr	     call to build substring
;      (xr)		     ptr to new scblk with substring
;      (xl)		     zero
;      (wa,wb,wc,xl,ia)	     destroyed
;
;      note that sbstr is called with a dummy string pointer
;      (pointing into a vrblk or svblk) to copy the name of a
;      variable as a standard string value.
;
|sbstr|prc|25,e|1,0||; entry point|25919
||bze|8,wa|6,sbst2||; jump if null substring|25920
||jsr|6,alocs|||; else allocate scblk|25921
||mov|8,wa|8,wc||; move number of characters|25922
||mov|8,wc|7,xr||; save ptr to new scblk|25923
||plc|7,xl|8,wb||; prepare to load chars from old blk|25924
||psc|7,xr|||; prepare to store chars in new blk|25925
||mvc||||; move characters to new string|25926
||mov|7,xr|8,wc||; then restore scblk pointer|25927
;
;      return point
;
|sbst1|zer|7,xl|||; clear garbage pointer in xl|25931
||exi||||; return to sbstr caller|25932
;
;      here for null substring
;
|sbst2|mov|7,xr|21,=nulls||; set null string as result|25936
||brn|6,sbst1|||; return|25937
||enp||||; end procedure sbstr|25938
||ejc|||||25939
;
;      stgcc -- compute counters for stmt startup testing
;
;      jsr  stgcc	     call to recompute counters
;      (wa,wb)		     destroyed
;
;      on exit, stmcs and stmct contain the counter value to
;      tested in stmgo.
;
;
|stgcc|prc|25,e|1,0||;|25950
||mov|8,wa|3,polcs||; assume no profiling or stcount tracing|25952
||mov|8,wb|18,=num01||; poll each time polcs expires|25953
||ldi|3,kvstl|||; get stmt limit|25957
||bnz|3,kvpfl|6,stgc1||; jump if profiling enabled|25958
||ilt|6,stgc3|||; no stcount tracing if negative|25959
||bze|3,r_stc|6,stgc2||; jump if not stcount tracing|25960
;
;      here if profiling or if stcount tracing enabled
;
|stgc1|mov|8,wb|8,wa||; count polcs times within stmg|25965
||mov|8,wa|18,=num01||; break out of stmgo on each stmt|25966
||brn|6,stgc3|||;|25970
;
;      check that stmcs does not exceed kvstl
;
|stgc2|mti|8,wa|||; breakout count start value|25974
||sbi|3,kvstl|||; proposed stmcs minus stmt limit|25975
||ile|6,stgc3|||; jump if stmt count does not limit|25976
||ldi|3,kvstl|||; stlimit limits breakcount count|25977
||mfi|8,wa|||; use it instead|25978
;
;      re-initialize counter
;
|stgc3|mov|3,stmcs|8,wa||; update breakout count start value|25982
||mov|3,stmct|8,wa||; reset breakout counter|25983
||mov|3,polct|8,wb||;|25985
||exi|||||25987
||ejc|||||25988
;
;      tfind -- locate table element
;
;      (xr)		     subscript value for element
;      (xl)		     pointer to table
;      (wb)		     zero by value, non-zero by name
;      jsr  tfind	     call to locate element
;      ppm  loc		     transfer location if access fails
;      (xr)		     element value (if by value)
;      (xr)		     destroyed (if by name)
;      (xl,wa)		     teblk name (if by name)
;      (xl,wa)		     destroyed (if by value)
;      (wc,ra)		     destroyed
;
;      note that if a call by value specifies a non-existent
;      subscript, the default value is returned without building
;      a new teblk.
;
|tfind|prc|25,e|1,1||; entry point|26007
||mov|11,-(xs)|8,wb||; save name/value indicator|26008
||mov|11,-(xs)|7,xr||; save subscript value|26009
||mov|11,-(xs)|7,xl||; save table pointer|26010
||mov|8,wa|13,tblen(xl)||; load length of tbblk|26011
||btw|8,wa|||; convert to word count|26012
||sub|8,wa|18,=tbbuk||; get number of buckets|26013
||mti|8,wa|||; convert to integer value|26014
||sti|3,tfnsi|||; save for later|26015
||mov|7,xl|9,(xr)||; load first word of subscript|26016
||lei|7,xl|||; load block entry id (bl_xx)|26017
||bsw|7,xl|2,bl__d|6,tfn00|; switch on block type|26018
||iff|1,0|6,tfn00|||26029
||iff|1,1|6,tfn00|||26029
||iff|1,2|6,tfn00|||26029
||iff|2,bl_ic|6,tfn02||; jump if integer|26029
||iff|2,bl_nm|6,tfn04||; jump if name|26029
||iff|2,bl_p0|6,tfn03||; jump if pattern|26029
||iff|2,bl_p1|6,tfn03||; jump if pattern|26029
||iff|2,bl_p2|6,tfn03||; jump if pattern|26029
||iff|2,bl_rc|6,tfn02||; real|26029
||iff|2,bl_sc|6,tfn05||; jump if string|26029
||iff|1,10|6,tfn00|||26029
||iff|1,11|6,tfn00|||26029
||iff|1,12|6,tfn00|||26029
||iff|1,13|6,tfn00|||26029
||iff|1,14|6,tfn00|||26029
||iff|1,15|6,tfn00|||26029
||iff|1,16|6,tfn00|||26029
||esw||||; end switch on block type|26029
;
;      here for blocks for which we use the second word of the
;      block as the hash source (see block formats for details).
;
|tfn00|mov|8,wa|12,1(xr)||; load second word|26034
;
;      merge here with one word hash source in wa
;
|tfn01|mti|8,wa|||; convert to integer|26038
||brn|6,tfn06|||; jump to merge|26039
||ejc|||||26040
;
;      tfind (continued)
;
;      here for integer or real
;      possibility of overflow exist on twos complement
;      machine if hash source is most negative integer or is
;      a real having the same bit pattern.
;
;
|tfn02|ldi|12,1(xr)|||; load value as hash source|26050
||ige|6,tfn06|||; ok if positive or zero|26051
||ngi||||; make positive|26052
||iov|6,tfn06|||; clear possible overflow|26053
||brn|6,tfn06|||; merge|26054
;
;      for pattern, use first word (pcode) as source
;
|tfn03|mov|8,wa|9,(xr)||; load first word as hash source|26058
||brn|6,tfn01|||; merge back|26059
;
;      for name, use offset as hash source
;
|tfn04|mov|8,wa|13,nmofs(xr)||; load offset as hash source|26063
||brn|6,tfn01|||; merge back|26064
;
;      here for string
;
|tfn05|jsr|6,hashs|||; call routine to compute hash|26068
;
;      merge here with hash source in (ia)
;
|tfn06|rmi|3,tfnsi|||; compute hash index by remaindering|26072
||mfi|8,wc|||; get as one word integer|26073
||wtb|8,wc|||; convert to byte offset|26074
||mov|7,xl|9,(xs)||; get table ptr again|26075
||add|7,xl|8,wc||; point to proper bucket|26076
||mov|7,xr|13,tbbuk(xl)||; load first teblk pointer|26077
||beq|7,xr|9,(xs)|6,tfn10|; jump if no teblks on chain|26078
;
;      loop through teblks on hash chain
;
|tfn07|mov|8,wb|7,xr||; save teblk pointer|26082
||mov|7,xr|13,tesub(xr)||; load subscript value|26083
||mov|7,xl|12,1(xs)||; load input argument subscript val|26084
||jsr|6,ident|||; compare them|26085
||ppm|6,tfn08|||; jump if equal (ident)|26086
;
;      here if no match with that teblk
;
||mov|7,xl|8,wb||; restore teblk pointer|26090
||mov|7,xr|13,tenxt(xl)||; point to next teblk on chain|26091
||bne|7,xr|9,(xs)|6,tfn07|; jump if there is one|26092
;
;      here if no match with any teblk on chain
;
||mov|8,wc|19,*tenxt||; set offset to link field (xl base)|26096
||brn|6,tfn11|||; jump to merge|26097
||ejc|||||26098
;
;      tfind (continued)
;
;      here we have found a matching element
;
|tfn08|mov|7,xl|8,wb||; restore teblk pointer|26104
||mov|8,wa|19,*teval||; set teblk name offset|26105
||mov|8,wb|12,2(xs)||; restore name/value indicator|26106
||bnz|8,wb|6,tfn09||; jump if called by name|26107
||jsr|6,acess|||; else get value|26108
||ppm|6,tfn12|||; jump if reference fails|26109
||zer|8,wb|||; restore name/value indicator|26110
;
;      common exit for entry found
;
|tfn09|add|7,xs|19,*num03||; pop stack entries|26114
||exi||||; return to tfind caller|26115
;
;      here if no teblks on the hash chain
;
|tfn10|add|8,wc|19,*tbbuk||; get offset to bucket ptr|26119
||mov|7,xl|9,(xs)||; set tbblk ptr as base|26120
;
;      merge here with (xl,wc) base,offset of final link
;
|tfn11|mov|7,xr|9,(xs)||; tbblk pointer|26124
||mov|7,xr|13,tbinv(xr)||; load default value in case|26125
||mov|8,wb|12,2(xs)||; load name/value indicator|26126
||bze|8,wb|6,tfn09||; exit with default if value call|26127
||mov|8,wb|7,xr||; copy default value|26128
;
;      here we must build a new teblk
;
||mov|8,wa|19,*tesi_||; set size of teblk|26132
||jsr|6,alloc|||; allocate teblk|26133
||add|7,xl|8,wc||; point to hash link|26134
||mov|9,(xl)|7,xr||; link new teblk at end of chain|26135
||mov|9,(xr)|22,=b_tet||; store type word|26136
||mov|13,teval(xr)|8,wb||; set default as initial value|26137
||mov|13,tenxt(xr)|10,(xs)+||; set tbblk ptr to mark end of chain|26138
||mov|13,tesub(xr)|10,(xs)+||; store subscript value|26139
||mov|8,wb|10,(xs)+||; restore name/value indicator|26140
||mov|7,xl|7,xr||; copy teblk pointer (name base)|26141
||mov|8,wa|19,*teval||; set offset|26142
||exi||||; return to caller with new teblk|26143
;
;      acess fail return
;
|tfn12|exi|1,1|||; alternative return|26147
||enp||||; end procedure tfind|26148
||ejc|||||26149
;
;      tmake -- make new table
;
;      (xl)		     initial lookup value
;      (wc)		     number of buckets desired
;      jsr  tmake	     call to make new table
;      (xr)		     new table
;      (wa,wb)		     destroyed
;
|tmake|prc|25,e|1,0||;|26159
||mov|8,wa|8,wc||; copy number of headers|26160
||add|8,wa|18,=tbsi_||; adjust for standard fields|26161
||wtb|8,wa|||; convert length to bytes|26162
||jsr|6,alloc|||; allocate space for tbblk|26163
||mov|8,wb|7,xr||; copy pointer to tbblk|26164
||mov|10,(xr)+|22,=b_tbt||; store type word|26165
||zer|10,(xr)+|||; zero id for the moment|26166
||mov|10,(xr)+|8,wa||; store length (tblen)|26167
||mov|10,(xr)+|7,xl||; store initial lookup value|26168
||lct|8,wc|8,wc||; set loop counter (num headers)|26169
;
;      loop to initialize all bucket pointers
;
|tma01|mov|10,(xr)+|8,wb||; store tbblk ptr in bucket header|26173
||bct|8,wc|6,tma01||; loop till all stored|26174
||mov|7,xr|8,wb||; recall pointer to tbblk|26175
||exi|||||26176
||enp|||||26177
||ejc|||||26178
;
;      vmake -- create a vector
;
;      (wa)		     number of elements in vector
;      (xl)		     default value for vector elements
;      jsr  vmake	     call to create vector
;      ppm  loc		     if vector too large
;
;      (xr)		     pointer to vcblk
;      (wa,wb,wc,xl)	     destroyed
;
|vmake|prc|25,e|1,1||; entry point|26190
||lct|8,wb|8,wa||; copy elements for loop later on|26191
||add|8,wa|18,=vcsi_||; add space for standard fields|26192
||wtb|8,wa|||; convert length to bytes|26193
||bgt|8,wa|3,mxlen|6,vmak2|; fail if too large|26194
||jsr|6,alloc|||; allocate space for vcblk|26195
||mov|9,(xr)|22,=b_vct||; store type word|26196
||zer|13,idval(xr)|||; initialize idval|26197
||mov|13,vclen(xr)|8,wa||; set length|26198
||mov|8,wc|7,xl||; copy default value|26199
||mov|7,xl|7,xr||; copy vcblk pointer|26200
||add|7,xl|19,*vcvls||; point to first element value|26201
;
;      loop to set vector elements to default value
;
|vmak1|mov|10,(xl)+|8,wc||; store one value|26205
||bct|8,wb|6,vmak1||; loop till all stored|26206
||exi||||; success return|26207
;
;      here if desired vector size too large
;
|vmak2|exi|1,1|||; fail return|26211
||enp|||||26212
||ejc|||||26213
;
;      scane -- scan an element
;
;      scane is called at compile time (by expan ,cmpil,cncrd)
;      to scan one element from the input image.
;
;      (scncc)		     non-zero if called from cncrd
;      jsr  scane	     call to scan element
;      (xr)		     result pointer (see below)
;      (xl)		     syntax type code (t_xxx)
;
;      the following global locations are used.
;
;      r_cim		     pointer to string block (scblk)
;			     for current input image.
;
;      r_cni		     pointer to next input image string
;			     pointer (zero if none).
;
;      r_scp		     save pointer (exit xr) from last
;			     call in case rescan is set.
;
;      scnbl		     this location is set non-zero on
;			     exit if scane scanned past blanks
;			     before locating the current element
;			     the end of a line counts as blanks.
;
;      scncc		     cncrd sets this non-zero to scan
;			     control card names and clears it
;			     on return
;
;      scnil		     length of current input image
;
;      scngo		     if set non-zero on entry, f and s
;			     are returned as separate syntax
;			     types (not letters) (goto pro-
;			     cessing). scngo is reset on exit.
;
;      scnpt		     offset to current loc in r_cim
;
;      scnrs		     if set non-zero on entry, scane
;			     returns the same result as on the
;			     last call (rescan). scnrs is reset
;			     on exit from any call to scane.
;
;      scntp		     save syntax type from last
;			     call (in case rescan is set).
||ejc|||||26261
;
;      scane (continued)
;
;
;
;      element scanned	     xl	       xr
;      ---------------	     --	       --
;
;      control card name     0	       pointer to scblk for name
;
;      unary operator	     t_uop     ptr to operator dvblk
;
;      left paren	     t_lpr     t_lpr
;
;      left bracket	     t_lbr     t_lbr
;
;      comma		     t_cma     t_cma
;
;      function call	     t_fnc     ptr to function vrblk
;
;      variable		     t_var     ptr to vrblk
;
;      string constant	     t_con     ptr to scblk
;
;      integer constant	     t_con     ptr to icblk
;
;      real constant	     t_con     ptr to rcblk
;
;      binary operator	     t_bop     ptr to operator dvblk
;
;      right paren	     t_rpr     t_rpr
;
;      right bracket	     t_rbr     t_rbr
;
;      colon		     t_col     t_col
;
;      semi-colon	     t_smc     t_smc
;
;      f (scngo ne 0)	     t_fgo     t_fgo
;
;      s (scngo ne 0)	     t_sgo     t_sgo
||ejc|||||26306
;
;      scane (continued)
;
;      entry point
;
|scane|prc|25,e|1,0||; entry point|26312
||zer|3,scnbl|||; reset blanks flag|26313
||mov|3,scnsa|8,wa||; save wa|26314
||mov|3,scnsb|8,wb||; save wb|26315
||mov|3,scnsc|8,wc||; save wc|26316
||bze|3,scnrs|6,scn03||; jump if no rescan|26317
;
;      here for rescan request
;
||mov|7,xl|3,scntp||; set previous returned scan type|26321
||mov|7,xr|3,r_scp||; set previous returned pointer|26322
||zer|3,scnrs|||; reset rescan switch|26323
||brn|6,scn13|||; jump to exit|26324
;
;      come here to read new image to test for continuation
;
|scn01|jsr|6,readr|||; read next image|26328
||mov|8,wb|19,*dvubs||; set wb for not reading name|26329
||bze|7,xr|6,scn30||; treat as semi-colon if none|26330
||plc|7,xr|||; else point to first character|26331
||lch|8,wc|9,(xr)||; load first character|26332
||beq|8,wc|18,=ch_dt|6,scn02|; jump if dot for continuation|26333
||bne|8,wc|18,=ch_pl|6,scn30|; else treat as semicolon unless plus|26334
;
;      here for continuation line
;
|scn02|jsr|6,nexts|||; acquire next source image|26338
||mov|3,scnpt|18,=num01||; set scan pointer past continuation|26339
||mnz|3,scnbl|||; set blanks flag|26340
||ejc|||||26341
;
;      scane (continued)
;
;      merge here to scan next element on current line
;
|scn03|mov|8,wa|3,scnpt||; load current offset|26347
||beq|8,wa|3,scnil|6,scn01|; check continuation if end|26348
||mov|7,xl|3,r_cim||; point to current line|26349
||plc|7,xl|8,wa||; point to current character|26350
||mov|3,scnse|8,wa||; set start of element location|26351
||mov|8,wc|21,=opdvs||; point to operator dv list|26352
||mov|8,wb|19,*dvubs||; set constant for operator circuit|26353
||brn|6,scn06|||; start scanning|26354
;
;      loop here to ignore leading blanks and tabs
;
|scn05|bze|8,wb|6,scn10||; jump if trailing|26358
||icv|3,scnse|||; increment start of element|26359
||beq|8,wa|3,scnil|6,scn01|; jump if end of image|26360
||mnz|3,scnbl|||; note blanks seen|26361
;
;      the following jump is used repeatedly for scanning out
;      the characters of a numeric constant or variable name.
;      the registers are used as follows.
;
;      (xr)		     scratch
;      (xl)		     ptr to next character
;      (wa)		     current scan offset
;      (wb)		     *dvubs (0 if scanning name,const)
;      (wc)		     =opdvs (0 if scanning constant)
;
|scn06|lch|7,xr|10,(xl)+||; get next character|26373
||icv|8,wa|||; bump scan offset|26374
||mov|3,scnpt|8,wa||; store offset past char scanned|26375
||bsw|7,xr|2,cfp_u|6,scn07|; switch on scanned character|26377
;
;      switch table for switch on character
;
||ejc|||||26404
;
;      scane (continued)
;
||ejc|||||26460
;
;      scane (continued)
;
||iff|1,0|6,scn07|||26493
||iff|1,1|6,scn07|||26493
||iff|1,2|6,scn07|||26493
||iff|1,3|6,scn07|||26493
||iff|1,4|6,scn07|||26493
||iff|1,5|6,scn07|||26493
||iff|1,6|6,scn07|||26493
||iff|1,7|6,scn07|||26493
||iff|1,8|6,scn07|||26493
||iff|2,ch_ht|6,scn05||; horizontal tab|26493
||iff|1,10|6,scn07|||26493
||iff|1,11|6,scn07|||26493
||iff|1,12|6,scn07|||26493
||iff|1,13|6,scn07|||26493
||iff|1,14|6,scn07|||26493
||iff|1,15|6,scn07|||26493
||iff|1,16|6,scn07|||26493
||iff|1,17|6,scn07|||26493
||iff|1,18|6,scn07|||26493
||iff|1,19|6,scn07|||26493
||iff|1,20|6,scn07|||26493
||iff|1,21|6,scn07|||26493
||iff|1,22|6,scn07|||26493
||iff|1,23|6,scn07|||26493
||iff|1,24|6,scn07|||26493
||iff|1,25|6,scn07|||26493
||iff|1,26|6,scn07|||26493
||iff|1,27|6,scn07|||26493
||iff|1,28|6,scn07|||26493
||iff|1,29|6,scn07|||26493
||iff|1,30|6,scn07|||26493
||iff|1,31|6,scn07|||26493
||iff|2,ch_bl|6,scn05||; blank|26493
||iff|2,ch_ex|6,scn37||; exclamation mark|26493
||iff|2,ch_dq|6,scn17||; double quote|26493
||iff|2,ch_nm|6,scn41||; number sign|26493
||iff|2,ch_dl|6,scn36||; dollar|26493
||iff|2,ch_pc|6,scn38||; percent|26493
||iff|2,ch_am|6,scn44||; ampersand|26493
||iff|2,ch_sq|6,scn16||; single quote|26493
||iff|2,ch_pp|6,scn25||; left paren|26493
||iff|2,ch_rp|6,scn26||; right paren|26493
||iff|2,ch_as|6,scn49||; asterisk|26493
||iff|2,ch_pl|6,scn33||; plus|26493
||iff|2,ch_cm|6,scn31||; comma|26493
||iff|2,ch_mn|6,scn34||; minus|26493
||iff|2,ch_dt|6,scn32||; dot|26493
||iff|2,ch_sl|6,scn40||; slash|26493
||iff|2,ch_d0|6,scn08||; digit 0|26493
||iff|2,ch_d1|6,scn08||; digit 1|26493
||iff|2,ch_d2|6,scn08||; digit 2|26493
||iff|2,ch_d3|6,scn08||; digit 3|26493
||iff|2,ch_d4|6,scn08||; digit 4|26493
||iff|2,ch_d5|6,scn08||; digit 5|26493
||iff|2,ch_d6|6,scn08||; digit 6|26493
||iff|2,ch_d7|6,scn08||; digit 7|26493
||iff|2,ch_d8|6,scn08||; digit 8|26493
||iff|2,ch_d9|6,scn08||; digit 9|26493
||iff|2,ch_cl|6,scn29||; colon|26493
||iff|2,ch_sm|6,scn30||; semi-colon|26493
||iff|2,ch_bb|6,scn28||; left bracket|26493
||iff|2,ch_eq|6,scn46||; equal|26493
||iff|2,ch_rb|6,scn27||; right bracket|26493
||iff|2,ch_qu|6,scn45||; question mark|26493
||iff|2,ch_at|6,scn42||; at|26493
||iff|2,ch_ua|6,scn09||; shifted a|26493
||iff|2,ch_ub|6,scn09||; shifted b|26493
||iff|2,ch_uc|6,scn09||; shifted c|26493
||iff|2,ch_ud|6,scn09||; shifted d|26493
||iff|2,ch_ue|6,scn09||; shifted e|26493
||iff|2,ch_uf|6,scn20||; shifted f|26493
||iff|2,ch_ug|6,scn09||; shifted g|26493
||iff|2,ch_uh|6,scn09||; shifted h|26493
||iff|2,ch_ui|6,scn09||; shifted i|26493
||iff|2,ch_uj|6,scn09||; shifted j|26493
||iff|2,ch_uk|6,scn09||; shifted k|26493
||iff|2,ch_ul|6,scn09||; shifted l|26493
||iff|2,ch_um|6,scn09||; shifted m|26493
||iff|2,ch_un|6,scn09||; shifted n|26493
||iff|2,ch_uo|6,scn09||; shifted o|26493
||iff|2,ch_up|6,scn09||; shifted p|26493
||iff|2,ch_uq|6,scn09||; shifted q|26493
||iff|2,ch_ur|6,scn09||; shifted r|26493
||iff|2,ch_us|6,scn21||; shifted s|26493
||iff|2,ch_ut|6,scn09||; shifted t|26493
||iff|2,ch_uu|6,scn09||; shifted u|26493
||iff|2,ch_uv|6,scn09||; shifted v|26493
||iff|2,ch_uw|6,scn09||; shifted w|26493
||iff|2,ch_ux|6,scn09||; shifted x|26493
||iff|2,ch_uy|6,scn09||; shifted y|26493
||iff|2,ch_uz|6,scn09||; shifted z|26493
||iff|2,ch_ob|6,scn28||; left bracket|26493
||iff|1,92|6,scn07|||26493
||iff|2,ch_cb|6,scn27||; right bracket|26493
||iff|2,ch_ey|6,scn37||; up arrow|26493
||iff|2,ch_u_|6,scn24||; underline|26493
||iff|1,96|6,scn07|||26493
||iff|2,ch_la|6,scn09||; letter a|26493
||iff|2,ch_lb|6,scn09||; letter b|26493
||iff|2,ch_lc|6,scn09||; letter c|26493
||iff|2,ch_ld|6,scn09||; letter d|26493
||iff|2,ch_le|6,scn09||; letter e|26493
||iff|2,ch_lf|6,scn20||; letter f|26493
||iff|2,ch_lg|6,scn09||; letter g|26493
||iff|2,ch_lh|6,scn09||; letter h|26493
||iff|2,ch_li|6,scn09||; letter i|26493
||iff|2,ch_lj|6,scn09||; letter j|26493
||iff|2,ch_lk|6,scn09||; letter k|26493
||iff|2,ch_ll|6,scn09||; letter l|26493
||iff|2,ch_lm|6,scn09||; letter m|26493
||iff|2,ch_ln|6,scn09||; letter n|26493
||iff|2,ch_lo|6,scn09||; letter o|26493
||iff|2,ch_lp|6,scn09||; letter p|26493
||iff|2,ch_lq|6,scn09||; letter q|26493
||iff|2,ch_lr|6,scn09||; letter r|26493
||iff|2,ch_ls|6,scn21||; letter s|26493
||iff|2,ch_lt|6,scn09||; letter t|26493
||iff|2,ch_lu|6,scn09||; letter u|26493
||iff|2,ch_lv|6,scn09||; letter v|26493
||iff|2,ch_lw|6,scn09||; letter w|26493
||iff|2,ch_lx|6,scn09||; letter x|26493
||iff|2,ch_ly|6,scn09||; letter y|26493
||iff|2,ch_l_|6,scn09||; letter z|26493
||iff|1,123|6,scn07|||26493
||iff|2,ch_br|6,scn43||; vertical bar|26493
||iff|1,125|6,scn07|||26493
||iff|2,ch_nt|6,scn35||; not|26493
||iff|1,127|6,scn07|||26493
||esw||||; end switch on character|26493
;
;      here for illegal character (underline merges)
;
|scn07|bze|8,wb|6,scn10||; jump if scanning name or constant|26497
||erb|1,230|26,syntax error: illegal character|||26498
||ejc|||||26499
;
;      scane (continued)
;
;      here for digits 0-9
;
|scn08|bze|8,wb|6,scn09||; keep scanning if name/constant|26505
||zer|8,wc|||; else set flag for scanning constant|26506
;
;      here for letter. loop here when scanning name/constant
;
|scn09|beq|8,wa|3,scnil|6,scn11|; jump if end of image|26510
||zer|8,wb|||; set flag for scanning name/const|26511
||brn|6,scn06|||; merge back to continue scan|26512
;
;      come here for delimiter ending name or constant
;
|scn10|dcv|8,wa|||; reset offset to point to delimiter|26516
;
;      come here after finishing scan of name or constant
;
|scn11|mov|3,scnpt|8,wa||; store updated scan offset|26520
||mov|8,wb|3,scnse||; point to start of element|26521
||sub|8,wa|8,wb||; get number of characters|26522
||mov|7,xl|3,r_cim||; point to line image|26523
||bnz|8,wc|6,scn15||; jump if name|26524
;
;      here after scanning out numeric constant
;
||jsr|6,sbstr|||; get string for constant|26528
||mov|3,dnamp|7,xr||; delete from storage (not needed)|26529
||jsr|6,gtnum|||; convert to numeric|26530
||ppm|6,scn14|||; jump if conversion failure|26531
;
;      merge here to exit with constant
;
|scn12|mov|7,xl|18,=t_con||; set result type of constant|26535
||ejc|||||26536
;
;      scane (continued)
;
;      common exit point (xr,xl) set
;
|scn13|mov|8,wa|3,scnsa||; restore wa|26542
||mov|8,wb|3,scnsb||; restore wb|26543
||mov|8,wc|3,scnsc||; restore wc|26544
||mov|3,r_scp|7,xr||; save xr in case rescan|26545
||mov|3,scntp|7,xl||; save xl in case rescan|26546
||zer|3,scngo|||; reset possible goto flag|26547
||exi||||; return to scane caller|26548
;
;      here if conversion error on numeric item
;
|scn14|erb|1,231|26,syntax error: invalid numeric item|||26552
;
;      here after scanning out variable name
;
|scn15|jsr|6,sbstr|||; build string name of variable|26556
||bnz|3,scncc|6,scn13||; return if cncrd call|26557
||jsr|6,gtnvr|||; locate/build vrblk|26558
||ppm||||; dummy (unused) error return|26559
||mov|7,xl|18,=t_var||; set type as variable|26560
||brn|6,scn13|||; back to exit|26561
;
;      here for single quote (start of string constant)
;
|scn16|bze|8,wb|6,scn10||; terminator if scanning name or cnst|26565
||mov|8,wb|18,=ch_sq||; set terminator as single quote|26566
||brn|6,scn18|||; merge|26567
;
;      here for double quote (start of string constant)
;
|scn17|bze|8,wb|6,scn10||; terminator if scanning name or cnst|26571
||mov|8,wb|18,=ch_dq||; set double quote terminator, merge|26572
;
;      loop to scan out string constant
;
|scn18|beq|8,wa|3,scnil|6,scn19|; error if end of image|26576
||lch|8,wc|10,(xl)+||; else load next character|26577
||icv|8,wa|||; bump offset|26578
||bne|8,wc|8,wb|6,scn18|; loop back if not terminator|26579
||ejc|||||26580
;
;      scane (continued)
;
;      here after scanning out string constant
;
||mov|8,wb|3,scnpt||; point to first character|26586
||mov|3,scnpt|8,wa||; save offset past final quote|26587
||dcv|8,wa|||; point back past last character|26588
||sub|8,wa|8,wb||; get number of characters|26589
||mov|7,xl|3,r_cim||; point to input image|26590
||jsr|6,sbstr|||; build substring value|26591
||brn|6,scn12|||; back to exit with constant result|26592
;
;      here if no matching quote found
;
|scn19|mov|3,scnpt|8,wa||; set updated scan pointer|26596
||erb|1,232|26,syntax error: unmatched string quote|||26597
;
;      here for f (possible failure goto)
;
|scn20|mov|7,xr|18,=t_fgo||; set return code for fail goto|26601
||brn|6,scn22|||; jump to merge|26602
;
;      here for s (possible success goto)
;
|scn21|mov|7,xr|18,=t_sgo||; set success goto as return code|26606
;
;      special goto cases merge here
;
|scn22|bze|3,scngo|6,scn09||; treat as normal letter if not goto|26610
;
;      merge here for special character exit
;
|scn23|bze|8,wb|6,scn10||; jump if end of name/constant|26614
||mov|7,xl|7,xr||; else copy code|26615
||brn|6,scn13|||; and jump to exit|26616
;
;      here for underline
;
|scn24|bze|8,wb|6,scn09||; part of name if scanning name|26620
||brn|6,scn07|||; else illegal|26621
||ejc|||||26622
;
;      scane (continued)
;
;      here for left paren
;
|scn25|mov|7,xr|18,=t_lpr||; set left paren return code|26628
||bnz|8,wb|6,scn23||; return left paren unless name|26629
||bze|8,wc|6,scn10||; delimiter if scanning constant|26630
;
;      here for left paren after name (function call)
;
||mov|8,wb|3,scnse||; point to start of name|26634
||mov|3,scnpt|8,wa||; set pointer past left paren|26635
||dcv|8,wa|||; point back past last char of name|26636
||sub|8,wa|8,wb||; get name length|26637
||mov|7,xl|3,r_cim||; point to input image|26638
||jsr|6,sbstr|||; get string name for function|26639
||jsr|6,gtnvr|||; locate/build vrblk|26640
||ppm||||; dummy (unused) error return|26641
||mov|7,xl|18,=t_fnc||; set code for function call|26642
||brn|6,scn13|||; back to exit|26643
;
;      processing for special characters
;
|scn26|mov|7,xr|18,=t_rpr||; right paren, set code|26647
||brn|6,scn23|||; take special character exit|26648
;
|scn27|mov|7,xr|18,=t_rbr||; right bracket, set code|26650
||brn|6,scn23|||; take special character exit|26651
;
|scn28|mov|7,xr|18,=t_lbr||; left bracket, set code|26653
||brn|6,scn23|||; take special character exit|26654
;
|scn29|mov|7,xr|18,=t_col||; colon, set code|26656
||brn|6,scn23|||; take special character exit|26657
;
|scn30|mov|7,xr|18,=t_smc||; semi-colon, set code|26659
||brn|6,scn23|||; take special character exit|26660
;
|scn31|mov|7,xr|18,=t_cma||; comma, set code|26662
||brn|6,scn23|||; take special character exit|26663
||ejc|||||26664
;
;      scane (continued)
;
;      here for operators. on entry, wc points to the table of
;      operator dope vectors and wb is the increment to step
;      to the next pair (binary/unary) of dope vectors in the
;      list. on reaching scn46, the pointer has been adjusted to
;      point to the appropriate pair of dope vectors.
;      the first three entries are special since they can occur
;      as part of a variable name (.) or constant (.+-).
;
|scn32|bze|8,wb|6,scn09||; dot can be part of name or constant|26676
||add|8,wc|8,wb||; else bump pointer|26677
;
|scn33|bze|8,wc|6,scn09||; plus can be part of constant|26679
||bze|8,wb|6,scn48||; plus cannot be part of name|26680
||add|8,wc|8,wb||; else bump pointer|26681
;
|scn34|bze|8,wc|6,scn09||; minus can be part of constant|26683
||bze|8,wb|6,scn48||; minus cannot be part of name|26684
||add|8,wc|8,wb||; else bump pointer|26685
;
|scn35|add|8,wc|8,wb||; not|26687
|scn36|add|8,wc|8,wb||; dollar|26688
|scn37|add|8,wc|8,wb||; exclamation|26689
|scn38|add|8,wc|8,wb||; percent|26690
|scn39|add|8,wc|8,wb||; asterisk|26691
|scn40|add|8,wc|8,wb||; slash|26692
|scn41|add|8,wc|8,wb||; number sign|26693
|scn42|add|8,wc|8,wb||; at sign|26694
|scn43|add|8,wc|8,wb||; vertical bar|26695
|scn44|add|8,wc|8,wb||; ampersand|26696
|scn45|add|8,wc|8,wb||; question mark|26697
;
;      all operators come here (equal merges directly)
;      (wc) points to the binary/unary pair of operator dvblks.
;
|scn46|bze|8,wb|6,scn10||; operator terminates name/constant|26702
||mov|7,xr|8,wc||; else copy dv pointer|26703
||lch|8,wc|9,(xl)||; load next character|26704
||mov|7,xl|18,=t_bop||; set binary op in case|26705
||beq|8,wa|3,scnil|6,scn47|; should be binary if image end|26706
||beq|8,wc|18,=ch_bl|6,scn47|; should be binary if followed by blk|26707
||beq|8,wc|18,=ch_ht|6,scn47|; jump if horizontal tab|26709
||beq|8,wc|18,=ch_sm|6,scn47|; semicolon can immediately follow =|26714
||beq|8,wc|18,=ch_cl|6,scn47|; colon can immediately follow =|26715
||beq|8,wc|18,=ch_rp|6,scn47|; right paren can immediately follow =|26716
||beq|8,wc|18,=ch_rb|6,scn47|; right bracket can immediately follow =|26717
||beq|8,wc|18,=ch_cb|6,scn47|; right bracket can immediately follow =|26718
;
;      here for unary operator
;
||add|7,xr|19,*dvbs_||; point to dv for unary op|26722
||mov|7,xl|18,=t_uop||; set type for unary operator|26723
||ble|3,scntp|18,=t_uok|6,scn13|; ok unary if ok preceding element|26724
||ejc|||||26725
;
;      scane (continued)
;
;      merge here to require preceding blanks
;
|scn47|bnz|3,scnbl|6,scn13||; all ok if preceding blanks, exit|26731
;
;      fail operator in this position
;
|scn48|erb|1,233|26,syntax error: invalid use of operator|||26735
;
;      here for asterisk, could be ** substitute for exclamation
;
|scn49|bze|8,wb|6,scn10||; end of name if scanning name|26739
||beq|8,wa|3,scnil|6,scn39|; not ** if * at image end|26740
||mov|7,xr|8,wa||; else save offset past first *|26741
||mov|3,scnof|8,wa||; save another copy|26742
||lch|8,wa|10,(xl)+||; load next character|26743
||bne|8,wa|18,=ch_as|6,scn50|; not ** if next char not *|26744
||icv|7,xr|||; else step offset past second *|26745
||beq|7,xr|3,scnil|6,scn51|; ok exclam if end of image|26746
||lch|8,wa|9,(xl)||; else load next character|26747
||beq|8,wa|18,=ch_bl|6,scn51|; exclamation if blank|26748
||beq|8,wa|18,=ch_ht|6,scn51|; exclamation if horizontal tab|26750
;
;      unary *
;
|scn50|mov|8,wa|3,scnof||; recover stored offset|26758
||mov|7,xl|3,r_cim||; point to line again|26759
||plc|7,xl|8,wa||; point to current char|26760
||brn|6,scn39|||; merge with unary *|26761
;
;      here for ** as substitute for exclamation
;
|scn51|mov|3,scnpt|7,xr||; save scan pointer past 2nd *|26765
||mov|8,wa|7,xr||; copy scan pointer|26766
||brn|6,scn37|||; merge with exclamation|26767
||enp||||; end procedure scane|26768
||ejc|||||26769
;
;      scngf -- scan goto field
;
;      scngf is called from cmpil to scan and analyze a goto
;      field including the surrounding brackets or parentheses.
;      for a normal goto, the result returned is either a vrblk
;      pointer for a simple label operand, or a pointer to an
;      expression tree with a special outer unary operator
;      (o_goc). for a direct goto, the result returned is a
;      pointer to an expression tree with the special outer
;      unary operator o_god.
;
;      jsr  scngf	     call to scan goto field
;      (xr)		     result (see above)
;      (xl,wa,wb,wc)	     destroyed
;
|scngf|prc|25,e|1,0||; entry point|26786
||jsr|6,scane|||; scan initial element|26787
||beq|7,xl|18,=t_lpr|6,scng1|; skip if left paren (normal goto)|26788
||beq|7,xl|18,=t_lbr|6,scng2|; skip if left bracket (direct goto)|26789
||erb|1,234|26,syntax error: goto field incorrect|||26790
;
;      here for left paren (normal goto)
;
|scng1|mov|8,wb|18,=num01||; set expan flag for normal goto|26794
||jsr|6,expan|||; analyze goto field|26795
||mov|8,wa|21,=opdvn||; point to opdv for complex goto|26796
||ble|7,xr|3,statb|6,scng3|; jump if not in static (sgd15)|26797
||blo|7,xr|3,state|6,scng4|; jump to exit if simple label name|26798
||brn|6,scng3|||; complex goto - merge|26799
;
;      here for left bracket (direct goto)
;
|scng2|mov|8,wb|18,=num02||; set expan flag for direct goto|26803
||jsr|6,expan|||; scan goto field|26804
||mov|8,wa|21,=opdvd||; set opdv pointer for direct goto|26805
||ejc|||||26806
;
;      scngf (continued)
;
;      merge here to build outer unary operator block
;
|scng3|mov|11,-(xs)|8,wa||; stack operator dv pointer|26812
||mov|11,-(xs)|7,xr||; stack pointer to expression tree|26813
||jsr|6,expop|||; pop operator off|26814
||mov|7,xr|10,(xs)+||; reload new expression tree pointer|26815
;
;      common exit point
;
|scng4|exi||||; return to caller|26819
||enp||||; end procedure scngf|26820
||ejc|||||26821
;
;      setvr -- set vrget,vrsto fields of vrblk
;
;      setvr sets the proper values in the vrget and vrsto
;      fields of a vrblk. it is called whenever trblks are
;      added or subtracted (trace,stoptr,input,output,detach)
;
;      (xr)		     pointer to vrblk
;      jsr  setvr	     call to set fields
;      (xl,wa)		     destroyed
;
;      note that setvr ignores the call if xr does not point
;      into the static region (i.e. is some other name base)
;
|setvr|prc|25,e|1,0||; entry point|26836
||bhi|7,xr|3,state|6,setv1|; exit if not natural variable|26837
;
;      here if we have a vrblk
;
||mov|7,xl|7,xr||; copy vrblk pointer|26841
||mov|13,vrget(xr)|22,=b_vrl||; store normal get value|26842
||beq|13,vrsto(xr)|22,=b_vre|6,setv1|; skip if protected variable|26843
||mov|13,vrsto(xr)|22,=b_vrs||; store normal store value|26844
||mov|7,xl|13,vrval(xl)||; point to next entry on chain|26845
||bne|9,(xl)|22,=b_trt|6,setv1|; jump if end of trblk chain|26846
||mov|13,vrget(xr)|22,=b_vra||; store trapped routine address|26847
||mov|13,vrsto(xr)|22,=b_vrv||; set trapped routine address|26848
;
;      merge here to exit to caller
;
|setv1|exi||||; return to setvr caller|26852
||enp||||; end procedure setvr|26853
||ejc|||||26856
;
;      sorta -- sort array
;
;      routine to sort an array or table on same basis as in
;      sitbol. a table is converted to an array, leaving two
;      dimensional arrays and vectors as cases to be considered.
;      whole rows of arrays are permuted according to the
;      ordering of the keys they contain, and the stride
;      referred to, is the the length of a row. it is one
;      for a vector.
;      the sort used is heapsort, fundamentals of data structure
;      horowitz and sahni, pitman 1977, page 347.
;      it is an order n*log(n) algorithm. in order
;      to make it stable, comparands may not compare equal. this
;      is achieved by sorting a copy array (referred to as the
;      sort array) containing at its high address end, byte
;      offsets to the rows to be sorted held in the original
;      array (referred to as the key array). sortc, the
;      comparison routine, accesses the keys through these
;      offsets and in the case of equality, resolves it by
;      comparing the offsets themselves. the sort permutes the
;      offsets which are then used in a final operation to copy
;      the actual items into the new array in sorted order.
;      references to zeroth item are to notional item
;      preceding first actual item.
;      reverse sorting for rsort is done by having the less than
;      test for keys effectively be replaced by a
;      greater than test.
;
;      1(xs)		     first arg - array or table
;      0(xs)		     2nd arg - index or pdtype name
;      (wa)		     0 , non-zero for sort , rsort
;      jsr  sorta	     call to sort array
;      ppm  loc		     transfer loc if table is empty
;      (xr)		     sorted array
;      (xl,wa,wb,wc)	     destroyed
||ejc|||||26893
;
;      sorta (continued)
;
|sorta|prc|25,n|1,1||; entry point|26897
||mov|3,srtsr|8,wa||; sort/rsort indicator|26898
||mov|3,srtst|19,*num01||; default stride of 1|26899
||zer|3,srtof|||; default zero offset to sort key|26900
||mov|3,srtdf|21,=nulls||; clear datatype field name|26901
||mov|3,r_sxr|10,(xs)+||; unstack argument 2|26902
||mov|7,xr|10,(xs)+||; get first argument|26903
||mnz|8,wa|||; use key/values of table entries|26904
||jsr|6,gtarr|||; convert to array|26905
||ppm|6,srt18|||; signal that table is empty|26906
||ppm|6,srt16|||; error if non-convertable|26907
||mov|11,-(xs)|7,xr||; stack ptr to resulting key array|26908
||mov|11,-(xs)|7,xr||; another copy for copyb|26909
||jsr|6,copyb|||; get copy array for sorting into|26910
||ppm||||; cant fail|26911
||mov|11,-(xs)|7,xr||; stack pointer to sort array|26912
||mov|7,xr|3,r_sxr||; get second arg|26913
||mov|7,xl|13,num01(xs)||; get ptr to key array|26914
||bne|9,(xl)|22,=b_vct|6,srt02|; jump if arblk|26915
||beq|7,xr|21,=nulls|6,srt01|; jump if null second arg|26916
||jsr|6,gtnvr|||; get vrblk ptr for it|26917
||err|1,257|26,erroneous 2nd arg in sort/rsort of vector|||26918
||mov|3,srtdf|7,xr||; store datatype field name vrblk|26919
;
;      compute n and offset to item a(0) in vector case
;
|srt01|mov|8,wc|19,*vclen||; offset to a(0)|26923
||mov|8,wb|19,*vcvls||; offset to first item|26924
||mov|8,wa|13,vclen(xl)||; get block length|26925
||sub|8,wa|19,*vcsi_||; get no. of entries, n (in bytes)|26926
||brn|6,srt04|||; merge|26927
;
;      here for array
;
|srt02|ldi|13,ardim(xl)|||; get possible dimension|26931
||mfi|8,wa|||; convert to short integer|26932
||wtb|8,wa|||; further convert to baus|26933
||mov|8,wb|19,*arvls||; offset to first value if one|26934
||mov|8,wc|19,*arpro||; offset before values if one dim.|26935
||beq|13,arndm(xl)|18,=num01|6,srt04|; jump in fact if one dim.|26936
||bne|13,arndm(xl)|18,=num02|6,srt16|; fail unless two dimens|26937
||ldi|13,arlb2(xl)|||; get lower bound 2 as default|26938
||beq|7,xr|21,=nulls|6,srt03|; jump if default second arg|26939
||jsr|6,gtint|||; convert to integer|26940
||ppm|6,srt17|||; fail|26941
||ldi|13,icval(xr)|||; get actual integer value|26942
||ejc|||||26943
;
;      sorta (continued)
;
;      here with sort column index in ia in array case
;
|srt03|sbi|13,arlb2(xl)|||; subtract low bound|26949
||iov|6,srt17|||; fail if overflow|26950
||ilt|6,srt17|||; fail if below low bound|26951
||sbi|13,ardm2(xl)|||; check against dimension|26952
||ige|6,srt17|||; fail if too large|26953
||adi|13,ardm2(xl)|||; restore value|26954
||mfi|8,wa|||; get as small integer|26955
||wtb|8,wa|||; offset within row to key|26956
||mov|3,srtof|8,wa||; keep offset|26957
||ldi|13,ardm2(xl)|||; second dimension is row length|26958
||mfi|8,wa|||; convert to short integer|26959
||mov|7,xr|8,wa||; copy row length|26960
||wtb|8,wa|||; convert to bytes|26961
||mov|3,srtst|8,wa||; store as stride|26962
||ldi|13,ardim(xl)|||; get number of rows|26963
||mfi|8,wa|||; as a short integer|26964
||wtb|8,wa|||; convert n to baus|26965
||mov|8,wc|13,arlen(xl)||; offset past array end|26966
||sub|8,wc|8,wa||; adjust, giving space for n offsets|26967
||dca|8,wc|||; point to a(0)|26968
||mov|8,wb|13,arofs(xl)||; offset to word before first item|26969
||ica|8,wb|||; offset to first item|26970
;
;      separate pre-processing for arrays and vectors done.
;      to simplify later key comparisons, removal of any trblk
;      trap blocks from entries in key array is effected.
;
;      (xl) = 1(xs) = pointer to key array
;      (xs) = pointer to sort array
;      wa = number of items, n (converted to bytes).
;      wb = offset to first item of arrays.
;      wc = offset to a(0)
;
|srt04|ble|8,wa|19,*num01|6,srt15|; return if only a single item|26982
||mov|3,srtsn|8,wa||; store number of items (in baus)|26983
||mov|3,srtso|8,wc||; store offset to a(0)|26984
||mov|8,wc|13,arlen(xl)||; length of array or vec (=vclen)|26985
||add|8,wc|7,xl||; point past end of array or vector|26986
||mov|3,srtsf|8,wb||; store offset to first row|26987
||add|7,xl|8,wb||; point to first item in key array|26988
;
;      loop through array
;
|srt05|mov|7,xr|9,(xl)||; get an entry|26992
;
;      hunt along trblk chain
;
|srt06|bne|9,(xr)|22,=b_trt|6,srt07|; jump out if not trblk|26996
||mov|7,xr|13,trval(xr)||; get value field|26997
||brn|6,srt06|||; loop|26998
||ejc|||||26999
;
;      sorta (continued)
;
;      xr is value from end of chain
;
|srt07|mov|10,(xl)+|7,xr||; store as array entry|27005
||blt|7,xl|8,wc|6,srt05|; loop if not done|27006
||mov|7,xl|9,(xs)||; get adrs of sort array|27007
||mov|7,xr|3,srtsf||; initial offset to first key|27008
||mov|8,wb|3,srtst||; get stride|27009
||add|7,xl|3,srtso||; offset to a(0)|27010
||ica|7,xl|||; point to a(1)|27011
||mov|8,wc|3,srtsn||; get n|27012
||btw|8,wc|||; convert from bytes|27013
||mov|3,srtnr|8,wc||; store as row count|27014
||lct|8,wc|8,wc||; loop counter|27015
;
;      store key offsets at top of sort array
;
|srt08|mov|10,(xl)+|7,xr||; store an offset|27019
||add|7,xr|8,wb||; bump offset by stride|27020
||bct|8,wc|6,srt08||; loop through rows|27021
;
;      perform the sort on offsets in sort array.
;
;      (srtsn)		     number of items to sort, n (bytes)
;      (srtso)		     offset to a(0)
;
|srt09|mov|8,wa|3,srtsn||; get n|27028
||mov|8,wc|3,srtnr||; get number of rows|27029
||rsh|8,wc|1,1||; i = n / 2 (wc=i, index into array)|27030
||wtb|8,wc|||; convert back to bytes|27031
;
;      loop to form initial heap
;
|srt10|jsr|6,sorth|||; sorth(i,n)|27035
||dca|8,wc|||; i = i - 1|27036
||bnz|8,wc|6,srt10||; loop if i gt 0|27037
||mov|8,wc|8,wa||; i = n|27038
;
;      sorting loop. at this point, a(1) is the largest
;      item, since algorithm initialises it as, and then maintains
;      it as, root of tree.
;
|srt11|dca|8,wc|||; i = i - 1 (n - 1 initially)|27044
||bze|8,wc|6,srt12||; jump if done|27045
||mov|7,xr|9,(xs)||; get sort array address|27046
||add|7,xr|3,srtso||; point to a(0)|27047
||mov|7,xl|7,xr||; a(0) address|27048
||add|7,xl|8,wc||; a(i) address|27049
||mov|8,wb|13,num01(xl)||; copy a(i+1)|27050
||mov|13,num01(xl)|13,num01(xr)||; move a(1) to a(i+1)|27051
||mov|13,num01(xr)|8,wb||; complete exchange of a(1), a(i+1)|27052
||mov|8,wa|8,wc||; n = i for sorth|27053
||mov|8,wc|19,*num01||; i = 1 for sorth|27054
||jsr|6,sorth|||; sorth(1,n)|27055
||mov|8,wc|8,wa||; restore wc|27056
||brn|6,srt11|||; loop|27057
||ejc|||||27058
;
;      sorta (continued)
;
;      offsets have been permuted into required order by sort.
;      copy array elements over them.
;
|srt12|mov|7,xr|9,(xs)||; base adrs of key array|27065
||mov|8,wc|7,xr||; copy it|27066
||add|8,wc|3,srtso||; offset of a(0)|27067
||add|7,xr|3,srtsf||; adrs of first row of sort array|27068
||mov|8,wb|3,srtst||; get stride|27069
;
;      copying loop for successive items. sorted offsets are
;      held at end of sort array.
;
|srt13|ica|8,wc|||; adrs of next of sorted offsets|27074
||mov|7,xl|8,wc||; copy it for access|27075
||mov|7,xl|9,(xl)||; get offset|27076
||add|7,xl|13,num01(xs)||; add key array base adrs|27077
||mov|8,wa|8,wb||; get count of characters in row|27078
||mvw||||; copy a complete row|27079
||dcv|3,srtnr|||; decrement row count|27080
||bnz|3,srtnr|6,srt13||; repeat till all rows done|27081
;
;      return point
;
|srt15|mov|7,xr|10,(xs)+||; pop result array ptr|27085
||ica|7,xs|||; pop key array ptr|27086
||zer|3,r_sxl|||; clear junk|27087
||zer|3,r_sxr|||; clear junk|27088
||exi||||; return|27089
;
;      error point
;
|srt16|erb|1,256|26,sort/rsort 1st arg not suitable array or table|||27093
|srt17|erb|1,258|26,sort/rsort 2nd arg out of range or non-integer|||27094
;
;      return point if input table is empty
;
|srt18|exi|1,1|||; return indication of null table|27098
||enp||||; end procudure sorta|27099
||ejc|||||27100
;
;      sortc --	 compare sort keys
;
;      compare two sort keys given their offsets. if
;      equal, compare key offsets to give stable sort.
;      note that if srtsr is non-zero (request for reverse
;      sort), the quoted returns are inverted.
;      for objects of differing datatypes, the entry point
;      identifications are compared.
;
;      (xl)		     base adrs for keys
;      (wa)		     offset to key 1 item
;      (wb)		     offset to key 2 item
;      (srtsr)		     zero/non-zero for sort/rsort
;      (srtof)		     offset within row to comparands
;      jsr  sortc	     call to compare keys
;      ppm  loc		     key1 less than key2
;			     normal return, key1 gt than key2
;      (xl,xr,wa,wb)	     destroyed
;
|sortc|prc|25,e|1,1||; entry point|27121
||mov|3,srts1|8,wa||; save offset 1|27122
||mov|3,srts2|8,wb||; save offset 2|27123
||mov|3,srtsc|8,wc||; save wc|27124
||add|7,xl|3,srtof||; add offset to comparand field|27125
||mov|7,xr|7,xl||; copy base + offset|27126
||add|7,xl|8,wa||; add key1 offset|27127
||add|7,xr|8,wb||; add key2 offset|27128
||mov|7,xl|9,(xl)||; get key1|27129
||mov|7,xr|9,(xr)||; get key2|27130
||bne|3,srtdf|21,=nulls|6,src12|; jump if datatype field name used|27131
||ejc|||||27132
;
;      sortc (continued)
;
;      merge after dealing with field name. try for strings.
;
|src01|mov|8,wc|9,(xl)||; get type code|27138
||bne|8,wc|9,(xr)|6,src02|; skip if not same datatype|27139
||beq|8,wc|22,=b_scl|6,src09|; jump if both strings|27140
||beq|8,wc|22,=b_icl|6,src14|; jump if both integers|27141
;
;      datatypes different.  now try for numeric
;
|src02|mov|3,r_sxl|7,xl||; keep arg1|27149
||mov|3,r_sxr|7,xr||; keep arg2|27150
||beq|8,wc|22,=b_scl|6,src11|; do not allow conversion to number|27153
||beq|9,(xr)|22,=b_scl|6,src11|; if either arg is a string|27154
|src14|mov|11,-(xs)|7,xl||; stack|27197
||mov|11,-(xs)|7,xr||; args|27198
||jsr|6,acomp|||; compare objects|27199
||ppm|6,src10|||; not numeric|27200
||ppm|6,src10|||; not numeric|27201
||ppm|6,src03|||; key1 less|27202
||ppm|6,src08|||; keys equal|27203
||ppm|6,src05|||; key1 greater|27204
;
;      return if key1 smaller (sort), greater (rsort)
;
|src03|bnz|3,srtsr|6,src06||; jump if rsort|27208
;
|src04|mov|8,wc|3,srtsc||; restore wc|27210
||exi|1,1|||; return|27211
;
;      return if key1 greater (sort), smaller (rsort)
;
|src05|bnz|3,srtsr|6,src04||; jump if rsort|27215
;
|src06|mov|8,wc|3,srtsc||; restore wc|27217
||exi||||; return|27218
;
;      keys are of same datatype
;
|src07|blt|7,xl|7,xr|6,src03|; item first created is less|27222
||bgt|7,xl|7,xr|6,src05|; addresses rise in order of creation|27223
;
;      drop through or merge for identical or equal objects
;
|src08|blt|3,srts1|3,srts2|6,src04|; test offsets or key addrss instead|27227
||brn|6,src06|||; offset 1 greater|27228
||ejc|||||27229
;
;      sortc (continued)
;
;      strings
;
|src09|mov|11,-(xs)|7,xl||; stack|27239
||mov|11,-(xs)|7,xr||; args|27240
||jsr|6,lcomp|||; compare objects|27241
||ppm||||; cant|27242
||ppm||||; fail|27243
||ppm|6,src03|||; key1 less|27244
||ppm|6,src08|||; keys equal|27245
||ppm|6,src05|||; key1 greater|27246
;
;      arithmetic comparison failed - recover args
;
|src10|mov|7,xl|3,r_sxl||; get arg1|27250
||mov|7,xr|3,r_sxr||; get arg2|27251
||mov|8,wc|9,(xl)||; get type of key1|27252
||beq|8,wc|9,(xr)|6,src07|; jump if keys of same type|27253
;
;      here to compare datatype ids
;
|src11|mov|7,xl|8,wc||; get block type word|27257
||mov|7,xr|9,(xr)||; get block type word|27258
||lei|7,xl|||; entry point id for key1|27259
||lei|7,xr|||; entry point id for key2|27260
||bgt|7,xl|7,xr|6,src05|; jump if key1 gt key2|27261
||brn|6,src03|||; key1 lt key2|27262
;
;      datatype field name used
;
|src12|jsr|6,sortf|||; call routine to find field 1|27266
||mov|11,-(xs)|7,xl||; stack item pointer|27267
||mov|7,xl|7,xr||; get key2|27268
||jsr|6,sortf|||; find field 2|27269
||mov|7,xr|7,xl||; place as key2|27270
||mov|7,xl|10,(xs)+||; recover key1|27271
||brn|6,src01|||; merge|27272
||enp||||; procedure sortc|27273
||ejc|||||27274
;
;      sortf -- find field for sortc
;
;      routine used by sortc to obtain item corresponding
;      to a given field name, if this exists, in a programmer
;      defined object passed as argument.
;      if such a match occurs, record is kept of datatype
;      name, field name and offset to field in order to
;      short-circuit later searches on same type. note that
;      dfblks are stored in static and hence cannot be moved.
;
;      (srtdf)		     vrblk pointer of field name
;      (xl)		     possible pdblk pointer
;      jsr  sortf	     call to search for field name
;      (xl)		     item found or original pdblk ptr
;      (wc)		     destroyed
;
|sortf|prc|25,e|1,0||; entry point|27292
||bne|9,(xl)|22,=b_pdt|6,srtf3|; return if not pdblk|27293
||mov|11,-(xs)|7,xr||; keep xr|27294
||mov|7,xr|3,srtfd||; get possible former dfblk ptr|27295
||bze|7,xr|6,srtf4||; jump if not|27296
||bne|7,xr|13,pddfp(xl)|6,srtf4|; jump if not right datatype|27297
||bne|3,srtdf|3,srtff|6,srtf4|; jump if not right field name|27298
||add|7,xl|3,srtfo||; add offset to required field|27299
;
;      here with xl pointing to found field
;
|srtf1|mov|7,xl|9,(xl)||; get item from field|27303
;
;      return point
;
|srtf2|mov|7,xr|10,(xs)+||; restore xr|27307
;
|srtf3|exi||||; return|27309
||ejc|||||27310
;
;      sortf (continued)
;
;      conduct a search
;
|srtf4|mov|7,xr|7,xl||; copy original pointer|27316
||mov|7,xr|13,pddfp(xr)||; point to dfblk|27317
||mov|3,srtfd|7,xr||; keep a copy|27318
||mov|8,wc|13,fargs(xr)||; get number of fields|27319
||wtb|8,wc|||; convert to bytes|27320
||add|7,xr|13,dflen(xr)||; point past last field|27321
;
;      loop to find name in pdfblk
;
|srtf5|dca|8,wc|||; count down|27325
||dca|7,xr|||; point in front|27326
||beq|9,(xr)|3,srtdf|6,srtf6|; skip out if found|27327
||bnz|8,wc|6,srtf5||; loop|27328
||brn|6,srtf2|||; return - not found|27329
;
;      found
;
|srtf6|mov|3,srtff|9,(xr)||; keep field name ptr|27333
||add|8,wc|19,*pdfld||; add offset to first field|27334
||mov|3,srtfo|8,wc||; store as field offset|27335
||add|7,xl|8,wc||; point to field|27336
||brn|6,srtf1|||; return|27337
||enp||||; procedure sortf|27338
||ejc|||||27339
;
;      sorth -- heap routine for sorta
;
;      this routine constructs a heap from elements of array, a.
;      in this application, the elements are offsets to keys in
;      a key array.
;
;      (xs)		     pointer to sort array base
;      1(xs)		     pointer to key array base
;      (wa)		     max array index, n (in bytes)
;      (wc)		     offset j in a to root (in *1 to *n)
;      jsr  sorth	     call sorth(j,n) to make heap
;      (xl,xr,wb)	     destroyed
;
|sorth|prc|25,n|1,0||; entry point|27354
||mov|3,srtsn|8,wa||; save n|27355
||mov|3,srtwc|8,wc||; keep wc|27356
||mov|7,xl|9,(xs)||; sort array base adrs|27357
||add|7,xl|3,srtso||; add offset to a(0)|27358
||add|7,xl|8,wc||; point to a(j)|27359
||mov|3,srtrt|9,(xl)||; get offset to root|27360
||add|8,wc|8,wc||; double j - cant exceed n|27361
;
;      loop to move down tree using doubled index j
;
|srh01|bgt|8,wc|3,srtsn|6,srh03|; done if j gt n|27365
||beq|8,wc|3,srtsn|6,srh02|; skip if j equals n|27366
||mov|7,xr|9,(xs)||; sort array base adrs|27367
||mov|7,xl|13,num01(xs)||; key array base adrs|27368
||add|7,xr|3,srtso||; point to a(0)|27369
||add|7,xr|8,wc||; adrs of a(j)|27370
||mov|8,wa|13,num01(xr)||; get a(j+1)|27371
||mov|8,wb|9,(xr)||; get a(j)|27372
;
;      compare sons. (wa) right son, (wb) left son
;
||jsr|6,sortc|||; compare keys - lt(a(j+1),a(j))|27376
||ppm|6,srh02|||; a(j+1) lt a(j)|27377
||ica|8,wc|||; point to greater son, a(j+1)|27378
||ejc|||||27379
;
;      sorth (continued)
;
;      compare root with greater son
;
|srh02|mov|7,xl|13,num01(xs)||; key array base adrs|27385
||mov|7,xr|9,(xs)||; get sort array address|27386
||add|7,xr|3,srtso||; adrs of a(0)|27387
||mov|8,wb|7,xr||; copy this adrs|27388
||add|7,xr|8,wc||; adrs of greater son, a(j)|27389
||mov|8,wa|9,(xr)||; get a(j)|27390
||mov|7,xr|8,wb||; point back to a(0)|27391
||mov|8,wb|3,srtrt||; get root|27392
||jsr|6,sortc|||; compare them - lt(a(j),root)|27393
||ppm|6,srh03|||; father exceeds sons - done|27394
||mov|7,xr|9,(xs)||; get sort array adrs|27395
||add|7,xr|3,srtso||; point to a(0)|27396
||mov|7,xl|7,xr||; copy it|27397
||mov|8,wa|8,wc||; copy j|27398
||btw|8,wc|||; convert to words|27399
||rsh|8,wc|1,1||; get j/2|27400
||wtb|8,wc|||; convert back to bytes|27401
||add|7,xl|8,wa||; point to a(j)|27402
||add|7,xr|8,wc||; adrs of a(j/2)|27403
||mov|9,(xr)|9,(xl)||; a(j/2) = a(j)|27404
||mov|8,wc|8,wa||; recover j|27405
||aov|8,wc|8,wc|6,srh03|; j = j*2. done if too big|27406
||brn|6,srh01|||; loop|27407
;
;      finish by copying root offset back into array
;
|srh03|btw|8,wc|||; convert to words|27411
||rsh|8,wc|1,1||; j = j/2|27412
||wtb|8,wc|||; convert back to bytes|27413
||mov|7,xr|9,(xs)||; sort array adrs|27414
||add|7,xr|3,srtso||; adrs of a(0)|27415
||add|7,xr|8,wc||; adrs of a(j/2)|27416
||mov|9,(xr)|3,srtrt||; a(j/2) = root|27417
||mov|8,wa|3,srtsn||; restore wa|27418
||mov|8,wc|3,srtwc||; restore wc|27419
||exi||||; return|27420
||enp||||; end procedure sorth|27421
||ejc|||||27423
;
;      trace -- set/reset a trace association
;
;      this procedure is shared by trace and stoptr to
;      either initiate or stop a trace respectively.
;
;      (xl)		     trblk ptr (trace) or zero (stoptr)
;      1(xs)		     first argument (name)
;      0(xs)		     second argument (trace type)
;      jsr  trace	     call to set/reset trace
;      ppm  loc		     transfer loc if 1st arg is bad name
;      ppm  loc		     transfer loc if 2nd arg is bad type
;      (xs)		     popped
;      (xl,xr,wa,wb,wc,ia)   destroyed
;
|trace|prc|25,n|1,2||; entry point|27439
||jsr|6,gtstg|||; get trace type string|27440
||ppm|6,trc15|||; jump if not string|27441
||plc|7,xr|||; else point to string|27442
||lch|8,wa|9,(xr)||; load first character|27443
||flc|8,wa|||; fold to lower case|27445
||mov|7,xr|9,(xs)||; load name argument|27447
||mov|9,(xs)|7,xl||; stack trblk ptr or zero|27448
||mov|8,wc|18,=trtac||; set trtyp for access trace|27449
||beq|8,wa|18,=ch_la|6,trc10|; jump if a (access)|27450
||mov|8,wc|18,=trtvl||; set trtyp for value trace|27451
||beq|8,wa|18,=ch_lv|6,trc10|; jump if v (value)|27452
||beq|8,wa|18,=ch_bl|6,trc10|; jump if blank (value)|27453
;
;      here for l,k,f,c,r
;
||beq|8,wa|18,=ch_lf|6,trc01|; jump if f (function)|27457
||beq|8,wa|18,=ch_lr|6,trc01|; jump if r (return)|27458
||beq|8,wa|18,=ch_ll|6,trc03|; jump if l (label)|27459
||beq|8,wa|18,=ch_lk|6,trc06|; jump if k (keyword)|27460
||bne|8,wa|18,=ch_lc|6,trc15|; else error if not c (call)|27461
;
;      here for f,c,r
;
|trc01|jsr|6,gtnvr|||; point to vrblk for name|27465
||ppm|6,trc16|||; jump if bad name|27466
||ica|7,xs|||; pop stack|27467
||mov|7,xr|13,vrfnc(xr)||; point to function block|27468
||bne|9,(xr)|22,=b_pfc|6,trc17|; error if not program function|27469
||beq|8,wa|18,=ch_lr|6,trc02|; jump if r (return)|27470
||ejc|||||27471
;
;      trace (continued)
;
;      here for f,c to set/reset call trace
;
||mov|13,pfctr(xr)|7,xl||; set/reset call trace|27477
||beq|8,wa|18,=ch_lc|6,exnul|; exit with null if c (call)|27478
;
;      here for f,r to set/reset return trace
;
|trc02|mov|13,pfrtr(xr)|7,xl||; set/reset return trace|27482
||exi||||; return|27483
;
;      here for l to set/reset label trace
;
|trc03|jsr|6,gtnvr|||; point to vrblk|27487
||ppm|6,trc16|||; jump if bad name|27488
||mov|7,xl|13,vrlbl(xr)||; load label pointer|27489
||bne|9,(xl)|22,=b_trt|6,trc04|; jump if no old trace|27490
||mov|7,xl|13,trlbl(xl)||; else delete old trace association|27491
;
;      here with old label trace association deleted
;
|trc04|beq|7,xl|21,=stndl|6,trc16|; error if undefined label|27495
||mov|8,wb|10,(xs)+||; get trblk ptr again|27496
||bze|8,wb|6,trc05||; jump if stoptr case|27497
||mov|13,vrlbl(xr)|8,wb||; else set new trblk pointer|27498
||mov|13,vrtra(xr)|22,=b_vrt||; set label trace routine address|27499
||mov|7,xr|8,wb||; copy trblk pointer|27500
||mov|13,trlbl(xr)|7,xl||; store real label in trblk|27501
||exi||||; return|27502
;
;      here for stoptr case for label
;
|trc05|mov|13,vrlbl(xr)|7,xl||; store label ptr back in vrblk|27506
||mov|13,vrtra(xr)|22,=b_vrg||; store normal transfer address|27507
||exi||||; return|27508
||ejc|||||27509
;
;      trace (continued)
;
;      here for k (keyword)
;
|trc06|jsr|6,gtnvr|||; point to vrblk|27515
||ppm|6,trc16|||; error if not natural var|27516
||bnz|13,vrlen(xr)|6,trc16||; error if not system var|27517
||ica|7,xs|||; pop stack|27518
||bze|7,xl|6,trc07||; jump if stoptr case|27519
||mov|13,trkvr(xl)|7,xr||; store vrblk ptr in trblk for ktrex|27520
;
;      merge here with trblk set up in wb (or zero)
;
|trc07|mov|7,xr|13,vrsvp(xr)||; point to svblk|27524
||beq|7,xr|21,=v_ert|6,trc08|; jump if errtype|27525
||beq|7,xr|21,=v_stc|6,trc09|; jump if stcount|27526
||bne|7,xr|21,=v_fnc|6,trc17|; else error if not fnclevel|27527
;
;      fnclevel
;
||mov|3,r_fnc|7,xl||; set/reset fnclevel trace|27531
||exi||||; return|27532
;
;      errtype
;
|trc08|mov|3,r_ert|7,xl||; set/reset errtype trace|27536
||exi||||; return|27537
;
;      stcount
;
|trc09|mov|3,r_stc|7,xl||; set/reset stcount trace|27541
||jsr|6,stgcc|||; update countdown counters|27542
||exi||||; return|27543
||ejc|||||27544
;
;      trace (continued)
;
;      a,v merge here with trtyp value in wc
;
|trc10|jsr|6,gtvar|||; locate variable|27550
||ppm|6,trc16|||; error if not appropriate name|27551
||mov|8,wb|10,(xs)+||; get new trblk ptr again|27552
||add|8,wa|7,xl||; point to variable location|27553
||mov|7,xr|8,wa||; copy variable pointer|27554
;
;      loop to search trblk chain
;
|trc11|mov|7,xl|9,(xr)||; point to next entry|27558
||bne|9,(xl)|22,=b_trt|6,trc13|; jump if not trblk|27559
||blt|8,wc|13,trtyp(xl)|6,trc13|; jump if too far out on chain|27560
||beq|8,wc|13,trtyp(xl)|6,trc12|; jump if this matches our type|27561
||add|7,xl|19,*trnxt||; else point to link field|27562
||mov|7,xr|7,xl||; copy pointer|27563
||brn|6,trc11|||; and loop back|27564
;
;      here to delete an old trblk of the type we were given
;
|trc12|mov|7,xl|13,trnxt(xl)||; get ptr to next block or value|27568
||mov|9,(xr)|7,xl||; store to delete this trblk|27569
;
;      here after deleting any old association of this type
;
|trc13|bze|8,wb|6,trc14||; jump if stoptr case|27573
||mov|9,(xr)|8,wb||; else link new trblk in|27574
||mov|7,xr|8,wb||; copy trblk pointer|27575
||mov|13,trnxt(xr)|7,xl||; store forward pointer|27576
||mov|13,trtyp(xr)|8,wc||; store appropriate trap type code|27577
;
;      here to make sure vrget,vrsto are set properly
;
|trc14|mov|7,xr|8,wa||; recall possible vrblk pointer|27581
||sub|7,xr|19,*vrval||; point back to vrblk|27582
||jsr|6,setvr|||; set fields if vrblk|27583
||exi||||; return|27584
;
;      here for bad trace type
;
|trc15|exi|1,2|||; take bad trace type error exit|27588
;
;      pop stack before failing
;
|trc16|ica|7,xs|||; pop stack|27592
;
;      here for bad name argument
;
|trc17|exi|1,1|||; take bad name error exit|27596
||enp||||; end procedure trace|27597
||ejc|||||27598
;
;      trbld -- build trblk
;
;      trblk is used by the input, output and trace functions
;      to construct a trblk (trap block)
;
;      (xr)		     trtag or trter
;      (xl)		     trfnc or trfpt
;      (wb)		     trtyp
;      jsr  trbld	     call to build trblk
;      (xr)		     pointer to trblk
;      (wa)		     destroyed
;
|trbld|prc|25,e|1,0||; entry point|27612
||mov|11,-(xs)|7,xr||; stack trtag (or trfnm)|27613
||mov|8,wa|19,*trsi_||; set size of trblk|27614
||jsr|6,alloc|||; allocate trblk|27615
||mov|9,(xr)|22,=b_trt||; store first word|27616
||mov|13,trfnc(xr)|7,xl||; store trfnc (or trfpt)|27617
||mov|13,trtag(xr)|10,(xs)+||; store trtag (or trfnm)|27618
||mov|13,trtyp(xr)|8,wb||; store type|27619
||mov|13,trval(xr)|21,=nulls||; for now, a null value|27620
||exi||||; return to caller|27621
||enp||||; end procedure trbld|27622
||ejc|||||27623
;
;      trimr -- trim trailing blanks
;
;      trimr is passed a pointer to an scblk which must be the
;      last block in dynamic storage. trailing blanks are
;      trimmed off and the dynamic storage pointer reset to
;      the end of the (possibly) shortened block.
;
;      (wb)		     non-zero to trim trailing blanks
;      (xr)		     pointer to string to trim
;      jsr  trimr	     call to trim string
;      (xr)		     pointer to trimmed string
;      (xl,wa,wb,wc)	     destroyed
;
;      the call with wb zero still performs the end zero pad
;      and dnamp readjustment. it is used from acess if kvtrm=0.
;
|trimr|prc|25,e|1,0||; entry point|27641
||mov|7,xl|7,xr||; copy string pointer|27642
||mov|8,wa|13,sclen(xr)||; load string length|27643
||bze|8,wa|6,trim2||; jump if null input|27644
||plc|7,xl|8,wa||; else point past last character|27645
||bze|8,wb|6,trim3||; jump if no trim|27646
||mov|8,wc|18,=ch_bl||; load blank character|27647
;
;      loop through characters from right to left
;
|trim0|lch|8,wb|11,-(xl)||; load next character|27651
||beq|8,wb|18,=ch_ht|6,trim1|; jump if horizontal tab|27653
||bne|8,wb|8,wc|6,trim3|; jump if non-blank found|27655
|trim1|dcv|8,wa|||; else decrement character count|27656
||bnz|8,wa|6,trim0||; loop back if more to check|27657
;
;      here if result is null (null or all-blank input)
;
|trim2|mov|3,dnamp|7,xr||; wipe out input string block|27661
||mov|7,xr|21,=nulls||; load null result|27662
||brn|6,trim5|||; merge to exit|27663
||ejc|||||27664
;
;      trimr (continued)
;
;      here with non-blank found (merge for no trim)
;
|trim3|mov|13,sclen(xr)|8,wa||; set new length|27670
||mov|7,xl|7,xr||; copy string pointer|27671
||psc|7,xl|8,wa||; ready for storing blanks|27672
||ctb|8,wa|2,schar||; get length of block in bytes|27673
||add|8,wa|7,xr||; point past new block|27674
||mov|3,dnamp|8,wa||; set new top of storage pointer|27675
||lct|8,wa|18,=cfp_c||; get count of chars in word|27676
||zer|8,wc|||; set zero char|27677
;
;      loop to zero pad last word of characters
;
|trim4|sch|8,wc|10,(xl)+||; store zero character|27681
||bct|8,wa|6,trim4||; loop back till all stored|27682
||csc|7,xl|||; complete store characters|27683
;
;      common exit point
;
|trim5|zer|7,xl|||; clear garbage xl pointer|27687
||exi||||; return to caller|27688
||enp||||; end procedure trimr|27689
||ejc|||||27690
;
;      trxeq -- execute function type trace
;
;      trxeq is used to execute a trace when a fourth argument
;      has been supplied. trace has already been decremented.
;
;      (xr)		     pointer to trblk
;      (xl,wa)		     name base,offset for variable
;      jsr  trxeq	     call to execute trace
;      (wb,wc,ra)	     destroyed
;
;      the following stack entries are made before passing
;      control to the trace function using the cfunc routine.
;
;			     trxeq return point word(s)
;			     saved value of trace keyword
;			     trblk pointer
;			     name base
;			     name offset
;			     saved value of r_cod
;			     saved code ptr (-r_cod)
;			     saved value of flptr
;      flptr --------------- zero (dummy fail offset)
;			     nmblk for variable name
;      xs ------------------ trace tag
;
;      r_cod and the code ptr are set to dummy values which
;      cause control to return to the trxeq procedure on success
;      or failure (trxeq ignores a failure condition).
;
|trxeq|prc|25,r|1,0||; entry point (recursive)|27721
||mov|8,wc|3,r_cod||; load code block pointer|27722
||scp|8,wb|||; get current code pointer|27723
||sub|8,wb|8,wc||; make code pointer into offset|27724
||mov|11,-(xs)|3,kvtra||; stack trace keyword value|27725
||mov|11,-(xs)|7,xr||; stack trblk pointer|27726
||mov|11,-(xs)|7,xl||; stack name base|27727
||mov|11,-(xs)|8,wa||; stack name offset|27728
||mov|11,-(xs)|8,wc||; stack code block pointer|27729
||mov|11,-(xs)|8,wb||; stack code pointer offset|27730
||mov|11,-(xs)|3,flptr||; stack old failure pointer|27731
||zer|11,-(xs)|||; set dummy fail offset|27732
||mov|3,flptr|7,xs||; set new failure pointer|27733
||zer|3,kvtra|||; reset trace keyword to zero|27734
||mov|8,wc|21,=trxdc||; load new (dummy) code blk pointer|27735
||mov|3,r_cod|8,wc||; set as code block pointer|27736
||lcp|8,wc|||; and new code pointer|27737
||ejc|||||27738
;
;      trxeq (continued)
;
;      now prepare arguments for function
;
||mov|8,wb|8,wa||; save name offset|27744
||mov|8,wa|19,*nmsi_||; load nmblk size|27745
||jsr|6,alloc|||; allocate space for nmblk|27746
||mov|9,(xr)|22,=b_nml||; set type word|27747
||mov|13,nmbas(xr)|7,xl||; store name base|27748
||mov|13,nmofs(xr)|8,wb||; store name offset|27749
||mov|7,xl|12,6(xs)||; reload pointer to trblk|27750
||mov|11,-(xs)|7,xr||; stack nmblk pointer (1st argument)|27751
||mov|11,-(xs)|13,trtag(xl)||; stack trace tag (2nd argument)|27752
||mov|7,xl|13,trfnc(xl)||; load trace vrblk pointer|27753
||mov|7,xl|13,vrfnc(xl)||; load trace function pointer|27754
||beq|7,xl|21,=stndf|6,trxq2|; jump if not a defined function|27755
||mov|8,wa|18,=num02||; set number of arguments to two|27756
||brn|6,cfunc|||; jump to call function|27757
;
;      see o_txr for details of return to this point
;
|trxq1|mov|7,xs|3,flptr||; point back to our stack entries|27761
||ica|7,xs|||; pop off garbage fail offset|27762
||mov|3,flptr|10,(xs)+||; restore old failure pointer|27763
||mov|8,wb|10,(xs)+||; reload code offset|27764
||mov|8,wc|10,(xs)+||; load old code base pointer|27765
||mov|7,xr|8,wc||; copy cdblk pointer|27766
||mov|3,kvstn|13,cdstm(xr)||; restore stmnt no|27767
||mov|8,wa|10,(xs)+||; reload name offset|27768
||mov|7,xl|10,(xs)+||; reload name base|27769
||mov|7,xr|10,(xs)+||; reload trblk pointer|27770
||mov|3,kvtra|10,(xs)+||; restore trace keyword value|27771
||add|8,wb|8,wc||; recompute absolute code pointer|27772
||lcp|8,wb|||; restore code pointer|27773
||mov|3,r_cod|8,wc||; and code block pointer|27774
||exi||||; return to trxeq caller|27775
;
;      here if the target function is not defined
;
|trxq2|erb|1,197|26,trace fourth arg is not function name or null|||27779
;
||enp||||; end procedure trxeq|27781
||ejc|||||27782
;
;      xscan -- execution function argument scan
;
;      xscan scans out one token in a prototype argument in
;      array,clear,data,define,load function calls. xscan
;      calls must be preceded by a call to the initialization
;      procedure xscni. the following variables are used.
;
;      r_xsc		     pointer to scblk for function arg
;      xsofs		     offset (num chars scanned so far)
;
;      (wa)		     non-zero to skip and trim blanks
;      (wc)		     delimiter one (ch_xx)
;      (xl)		     delimiter two (ch_xx)
;      jsr  xscan	     call to scan next item
;      (xr)		     pointer to scblk for token scanned
;      (wa)		     completion code (see below)
;      (wc,xl)		     destroyed
;
;      the scan starts from the current position and continues
;      until one of the following three conditions occurs.
;
;      1)   delimiter one is encountered  (wa set to 1)
;
;      2)   delimiter two encountered  (wa set to 2)
;
;      3)   end of string encountered  (wa set to 0)
;
;      the result is a string containing all characters scanned
;      up to but not including any delimiter character.
;      the pointer is left pointing past the delimiter.
;
;      if only one delimiter is to be detected, delimiter one
;      and delimiter two should be set to the same value.
;
;      in the case where the end of string is encountered, the
;      string includes all the characters to the end of the
;      string. no further calls can be made to xscan until
;      xscni is called to initialize a new argument scan
||ejc|||||27822
;
;      xscan (continued)
;
|xscan|prc|25,e|1,0||; entry point|27826
||mov|3,xscwb|8,wb||; preserve wb|27827
||mov|11,-(xs)|8,wa||; record blank skip flag|27828
||mov|11,-(xs)|8,wa||; and second copy|27829
||mov|7,xr|3,r_xsc||; point to argument string|27830
||mov|8,wa|13,sclen(xr)||; load string length|27831
||mov|8,wb|3,xsofs||; load current offset|27832
||sub|8,wa|8,wb||; get number of remaining characters|27833
||bze|8,wa|6,xscn3||; jump if no characters left|27834
||plc|7,xr|8,wb||; point to current character|27835
;
;      loop to search for delimiter
;
|xscn1|lch|8,wb|10,(xr)+||; load next character|27839
||beq|8,wb|8,wc|6,xscn4|; jump if delimiter one found|27840
||beq|8,wb|7,xl|6,xscn5|; jump if delimiter two found|27841
||bze|9,(xs)|6,xscn2||; jump if not skipping blanks|27842
||icv|3,xsofs|||; assume blank and delete it|27843
||beq|8,wb|18,=ch_ht|6,xscn2|; jump if horizontal tab|27845
||beq|8,wb|18,=ch_bl|6,xscn2|; jump if blank|27850
||dcv|3,xsofs|||; undelete non-blank character|27851
||zer|9,(xs)|||; and discontinue blank checking|27852
;
;      here after performing any leading blank trimming.
;
|xscn2|dcv|8,wa|||; decrement count of chars left|27856
||bnz|8,wa|6,xscn1||; loop back if more chars to go|27857
;
;      here for runout
;
|xscn3|mov|7,xl|3,r_xsc||; point to string block|27861
||mov|8,wa|13,sclen(xl)||; get string length|27862
||mov|8,wb|3,xsofs||; load offset|27863
||sub|8,wa|8,wb||; get substring length|27864
||zer|3,r_xsc|||; clear string ptr for collector|27865
||zer|3,xscrt|||; set zero (runout) return code|27866
||brn|6,xscn7|||; jump to exit|27867
||ejc|||||27868
;
;      xscan (continued)
;
;      here if delimiter one found
;
|xscn4|mov|3,xscrt|18,=num01||; set return code|27874
||brn|6,xscn6|||; jump to merge|27875
;
;      here if delimiter two found
;
|xscn5|mov|3,xscrt|18,=num02||; set return code|27879
;
;      merge here after detecting a delimiter
;
|xscn6|mov|7,xl|3,r_xsc||; reload pointer to string|27883
||mov|8,wc|13,sclen(xl)||; get original length of string|27884
||sub|8,wc|8,wa||; minus chars left = chars scanned|27885
||mov|8,wa|8,wc||; move to reg for sbstr|27886
||mov|8,wb|3,xsofs||; set offset|27887
||sub|8,wa|8,wb||; compute length for sbstr|27888
||icv|8,wc|||; adjust new cursor past delimiter|27889
||mov|3,xsofs|8,wc||; store new offset|27890
;
;      common exit point
;
|xscn7|zer|7,xr|||; clear garbage character ptr in xr|27894
||jsr|6,sbstr|||; build sub-string|27895
||ica|7,xs|||; remove copy of blank flag|27896
||mov|8,wb|10,(xs)+||; original blank skip/trim flag|27897
||bze|13,sclen(xr)|6,xscn8||; cannot trim the null string|27898
||jsr|6,trimr|||; trim trailing blanks if requested|27899
;
;      final exit point
;
|xscn8|mov|8,wa|3,xscrt||; load return code|27903
||mov|8,wb|3,xscwb||; restore wb|27904
||exi||||; return to xscan caller|27905
||enp||||; end procedure xscan|27906
||ejc|||||27907
;
;      xscni -- execution function argument scan
;
;      xscni initializes the scan used for prototype arguments
;      in the clear, define, load, data, array functions. see
;      xscan for the procedure which is used after this call.
;
;      -(xs)		     argument to be scanned (on stack)
;      jsr  xscni	     call to scan argument
;      ppm  loc		     transfer loc if arg is not string
;      ppm  loc		     transfer loc if argument is null
;      (xs)		     popped
;      (xr,r_xsc)	     argument (scblk ptr)
;      (wa)		     argument length
;      (ia,ra)		     destroyed
;
|xscni|prc|25,n|1,2||; entry point|27924
||jsr|6,gtstg|||; fetch argument as string|27925
||ppm|6,xsci1|||; jump if not convertible|27926
||mov|3,r_xsc|7,xr||; else store scblk ptr for xscan|27927
||zer|3,xsofs|||; set offset to zero|27928
||bze|8,wa|6,xsci2||; jump if null string|27929
||exi||||; return to xscni caller|27930
;
;      here if argument is not a string
;
|xsci1|exi|1,1|||; take not-string error exit|27934
;
;      here for null string
;
|xsci2|exi|1,2|||; take null-string error exit|27938
||enp||||; end procedure xscni|27939
||ttl|27,s p i t b o l -- stack overflow section||||27940
;
;      control comes here if the main stack overflows
;
||sec||||; start of stack overflow section|27944
;
||add|3,errft|18,=num04||; force conclusive fatal error|27946
||mov|7,xs|3,flptr||; pop stack to avoid more fails|27947
||bnz|3,gbcfl|6,stak1||; jump if garbage collecting|27948
||erb|1,246|26,stack overflow|||27949
;
;      no chance of recovery in mid garbage collection
;
|stak1|mov|7,xr|21,=endso||; point to message|27953
||zer|3,kvdmp|||; memory is undumpable|27954
||brn|6,stopr|||; give up|27955
||ttl|27,s p i t b o l -- error section||||27956
;
;      this section of code is entered whenever a procedure
;      return via an err parameter or an erb opcode is obeyed.
;
;      (wa)		     is the error code
;
;      the global variable stage indicates the point at which
;      the error occured as follows.
;
;      stage=stgic	     error during initial compile
;
;      stage=stgxc	     error during compile at execute
;			     time (code, convert function calls)
;
;      stage=stgev	     error during compilation of
;			     expression at execution time
;			     (eval, convert function call).
;
;      stage=stgxt	     error at execute time. compiler
;			     not active.
;
;      stage=stgce	     error during initial compile after
;			     scanning out the end line.
;
;      stage=stgxe	     error during compile at execute
;			     time after scanning end line.
;
;      stage=stgee	     error during expression evaluation
;
||sec||||; start of error section|27986
;
|error|beq|3,r_cim|20,=cmlab|6,cmple|; jump if error in scanning label|27988
||mov|3,kvert|8,wa||; save error code|27989
||zer|3,scnrs|||; reset rescan switch for scane|27990
||zer|3,scngo|||; reset goto switch for scane|27991
||mov|3,polcs|18,=num01||; reset poll count|27993
||mov|3,polct|18,=num01||; reset poll count|27994
||mov|7,xr|3,stage||; load current stage|27996
||bsw|7,xr|2,stgno||; jump to appropriate error circuit|27997
||iff|2,stgic|6,err01||; initial compile|28005
||iff|2,stgxc|6,err04||; execute time compile|28005
||iff|2,stgev|6,err04||; eval compiling expr.|28005
||iff|2,stgxt|6,err05||; execute time|28005
||iff|2,stgce|6,err01||; compile - after end|28005
||iff|2,stgxe|6,err04||; xeq compile-past end|28005
||iff|2,stgee|6,err04||; eval evaluating expr|28005
||esw||||; end switch on error type|28005
||ejc|||||28006
;
;      error during initial compile
;
;      the error message is printed as part of the compiler
;      output. this printout includes the offending line (if not
;      printed already) and an error flag under the appropriate
;      column as indicated by scnse unless scnse is set to zero.
;
;      after printing the message, the generated code is
;      modified to an error call and control is returned to
;      the cmpil procedure after resetting the stack pointer.
;
;      if the error occurs after the end line, control returns
;      in a slightly different manner to ensure proper cleanup.
;
|err01|mov|7,xs|3,cmpxs||; reset stack pointer|28022
||ssl|3,cmpss|||; restore s-r stack ptr for cmpil|28023
||bnz|3,errsp|6,err03||; jump if error suppress flag set|28024
||mov|8,wc|3,cmpsn||; current statement|28027
||jsr|6,filnm|||; obtain file name for this statement|28028
||mov|8,wb|3,scnse||; column number|28030
||mov|8,wc|3,rdcln||; line number|28031
||mov|7,xr|3,stage||;|28032
||jsr|6,sysea|||; advise system of error|28033
||ppm|6,erra3|||; if system does not want print|28034
||mov|11,-(xs)|7,xr||; save any provided print message|28035
||mov|3,erlst|3,erich||; set flag for listr|28037
||jsr|6,listr|||; list line|28038
||jsr|6,prtis|||; terminate listing|28039
||zer|3,erlst|||; clear listr flag|28040
||mov|8,wa|3,scnse||; load scan element offset|28041
||bze|8,wa|6,err02||; skip if not set|28042
||lct|8,wb|8,wa||; loop counter|28044
||icv|8,wa|||; increase for ch_ex|28045
||mov|7,xl|3,r_cim||; point to bad statement|28046
||jsr|6,alocs|||; string block for error flag|28047
||mov|8,wa|7,xr||; remember string ptr|28048
||psc|7,xr|||; ready for character storing|28049
||plc|7,xl|||; ready to get chars|28050
;
;      loop to replace all chars but tabs by blanks
;
|erra1|lch|8,wc|10,(xl)+||; get next char|28054
||beq|8,wc|18,=ch_ht|6,erra2|; skip if tab|28055
||mov|8,wc|18,=ch_bl||; get a blank|28056
||ejc|||||28057
;
;      merge to store blank or tab in error line
;
|erra2|sch|8,wc|10,(xr)+||; store char|28061
||bct|8,wb|6,erra1||; loop|28062
||mov|7,xl|18,=ch_ex||; exclamation mark|28063
||sch|7,xl|9,(xr)||; store at end of error line|28064
||csc|7,xr|||; end of sch loop|28065
||mov|3,profs|18,=stnpd||; allow for statement number|28066
||mov|7,xr|8,wa||; point to error line|28067
||jsr|6,prtst|||; print error line|28068
;
;      here after placing error flag as required
;
|err02|jsr|6,prtis|||; print blank line|28082
||mov|7,xr|10,(xs)+||; restore any sysea message|28084
||bze|7,xr|6,erra0||; did sysea provide message to print|28085
||jsr|6,prtst|||; print sysea message|28086
|erra0|jsr|6,ermsg|||; generate flag and error message|28088
||add|3,lstlc|18,=num03||; bump page ctr for blank, error, blk|28089
|erra3|zer|7,xr|||; in case of fatal error|28090
||bhi|3,errft|18,=num03|6,stopr|; pack up if several fatals|28091
;
;      count error, inhibit execution if required
;
||icv|3,cmerc|||; bump error count|28095
||add|3,noxeq|3,cswer||; inhibit xeq if -noerrors|28096
||bne|3,stage|18,=stgic|6,cmp10|; special return if after end line|28097
||ejc|||||28098
;
;      loop to scan to end of statement
;
|err03|mov|7,xr|3,r_cim||; point to start of image|28102
||plc|7,xr|||; point to first char|28103
||lch|7,xr|9,(xr)||; get first char|28104
||beq|7,xr|18,=ch_mn|6,cmpce|; jump if error in control card|28105
||zer|3,scnrs|||; clear rescan flag|28106
||mnz|3,errsp|||; set error suppress flag|28107
||jsr|6,scane|||; scan next element|28108
||bne|7,xl|18,=t_smc|6,err03|; loop back if not statement end|28109
||zer|3,errsp|||; clear error suppress flag|28110
;
;      generate error call in code and return to cmpil
;
||mov|3,cwcof|19,*cdcod||; reset offset in ccblk|28114
||mov|8,wa|21,=ocer_||; load compile error call|28115
||jsr|6,cdwrd|||; generate it|28116
||mov|13,cmsoc(xs)|3,cwcof||; set success fill in offset|28117
||mnz|13,cmffc(xs)|||; set failure fill in flag|28118
||jsr|6,cdwrd|||; generate succ. fill in word|28119
||brn|6,cmpse|||; merge to generate error as cdfal|28120
;
;      error during execute time compile or expression evaluatio
;
;      execute time compilation is initiated through gtcod or
;      gtexp which are called by compile, code or eval.
;      before causing statement failure through exfal it is
;      helpful to set keyword errtext and for generality
;      these errors may be handled by the setexit mechanism.
;
|err04|bge|3,errft|18,=num03|6,labo1|; abort if too many fatal errors|28130
||beq|3,kvert|18,=nm320|6,err06|; treat user interrupt specially|28132
||zer|3,r_ccb|||; forget garbage code block|28134
||mov|3,cwcof|19,*cccod||; set initial offset (mbe catspaw)|28135
||ssl|3,iniss|||; restore main prog s-r stack ptr|28136
||jsr|6,ertex|||; get fail message text|28137
||dca|7,xs|||; ensure stack ok on loop start|28138
;
;      pop stack until find flptr for most deeply nested prog.
;      defined function call or call of eval / code.
;
|erra4|ica|7,xs|||; pop stack|28143
||beq|7,xs|3,flprt|6,errc4|; jump if prog defined fn call found|28144
||bne|7,xs|3,gtcef|6,erra4|; loop if not eval or code call yet|28145
||mov|3,stage|18,=stgxt||; re-set stage for execute|28146
||mov|3,r_cod|3,r_gtc||; recover code ptr|28147
||mov|3,flptr|7,xs||; restore fail pointer|28148
||zer|3,r_cim|||; forget possible image|28149
||zer|3,cnind|||; forget possible include|28151
;
;      test errlimit
;
|errb4|bnz|3,kverl|6,err07||; jump if errlimit non-zero|28156
||brn|6,exfal|||; fail|28157
;
;      return from prog. defined function is outstanding
;
|errc4|mov|7,xs|3,flptr||; restore stack from flptr|28161
||brn|6,errb4|||; merge|28162
||ejc|||||28163
;
;      error at execute time.
;
;      the action taken on an error is as follows.
;
;      if errlimit keyword is zero, an abort is signalled,
;      see coding for system label abort at l_abo.
;
;      otherwise, errlimit is decremented and an errtype trace
;      generated if required. control returns either via a jump
;      to continue (to take the failure exit) or a specified
;      setexit trap is executed and control passes to the trap.
;      if 3 or more fatal errors occur an abort is signalled
;      regardless of errlimit and setexit - looping is all too
;      probable otherwise. fatal errors include stack overflow
;      and exceeding stlimit.
;
|err05|ssl|3,iniss|||; restore main prog s-r stack ptr|28181
||bnz|3,dmvch|6,err08||; jump if in mid-dump|28182
;
;      merge here from err08 and err04 (error 320)
;
|err06|bze|3,kverl|6,labo1||; abort if errlimit is zero|28186
||jsr|6,ertex|||; get fail message text|28187
;
;      merge from err04
;
|err07|bge|3,errft|18,=num03|6,labo1|; abort if too many fatal errors|28191
||dcv|3,kverl|||; decrement errlimit|28192
||mov|7,xl|3,r_ert||; load errtype trace pointer|28193
||jsr|6,ktrex|||; generate errtype trace if required|28194
||mov|8,wa|3,r_cod||; get current code block|28195
||mov|3,r_cnt|8,wa||; set cdblk ptr for continuation|28196
||scp|8,wb|||; current code pointer|28197
||sub|8,wb|8,wa||; offset within code block|28198
||mov|3,stxoc|8,wb||; save code ptr offset for scontinue|28199
||mov|7,xr|3,flptr||; set ptr to failure offset|28200
||mov|3,stxof|9,(xr)||; save failure offset for continue|28201
||mov|7,xr|3,r_sxc||; load setexit cdblk pointer|28202
||bze|7,xr|6,lcnt1||; continue if no setexit trap|28203
||zer|3,r_sxc|||; else reset trap|28204
||mov|3,stxvr|21,=nulls||; reset setexit arg to null|28205
||mov|7,xl|9,(xr)||; load ptr to code block routine|28206
||bri|7,xl|||; execute first trap statement|28207
;
;      interrupted partly through a dump whilst store is in a
;      mess so do a tidy up operation. see dumpr for details.
;
|err08|mov|7,xr|3,dmvch||; chain head for affected vrblks|28212
||bze|7,xr|6,err06||; done if zero|28213
||mov|3,dmvch|9,(xr)||; set next link as chain head|28214
||jsr|6,setvr|||; restore vrget field|28215
;
;      label to mark end of code
;
|s_yyy|brn|6,err08|||; loop through chain|28219
||ttl|27,s p i t b o l -- here endeth the code||||28220
;
;      end of assembly
;
||end||||; end macro-spitbol assembly|28224
