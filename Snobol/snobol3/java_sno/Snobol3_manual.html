<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><style>
.break { page-break-before: always; }
</style>
</head><body>

  
<!-- base href="http://serl.cs.colorado.edu.wstub.archive.org/~dennis/software/s3/s3-1.0/doc/refman.html" -->

    <title>Snobol3 String Processing Language</title>
    <meta http-equiv="Owner" content="Dennis Heimbigner">
    <meta http-equiv="Reply-to" content="dennis.heimbigner@colorado.edu">
    <link rev="made" href="mailto:dennis.heimbigner@colorado.edu">
    <!-- base href="http://serl.cs.colorado.edu.wstub.archive.org/~dennis/software/s3/s3-1.0/doc/refman.html" -->
  


<center>
<h1>Snobol3</h1>

<h2>Snobol3 Language Implementation in Java</h2>
</center>
<hr>
<center>
<table>
<tbody><tr><td>Dennis Heimbigner
</td></tr><tr><td>Software Engineering Research Laboratory
</td></tr><tr><td>Computer Science Department
</td></tr><tr><td>University of Colorado
</td></tr><tr><td>Boulder, Colorado 80309-0430 USA
</td></tr><tr><td>dennis.heimbigner@colorado.edu
</td></tr></tbody></table>
<table><tbody><tr height="100"></tr></tbody></table>
<table>
<tbody><tr><td width="200">Last Updated:</td><td>1 October 2005</td></tr>
<tr><td>Latest Version:</td><td>Snobol3 Version 1.0</td></tr>
<tr><td>Minimum JDK Level:</td><td>JDK 1.5</td></tr>
</tbody></table>
</center>
<p>
</p><h3 class="break"><u>Table of contents</u></h3>
<table>
<tbody><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.">1.</a></td><td> &nbsp;Snobol3 Language Reference
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.1">1.1</a></td><td> &nbsp;Lexical Structure
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.2">1.2</a></td><td> &nbsp;Grammar
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.3">1.3</a></td><td> &nbsp;Processing Cycle
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.3.1">1.3.1</a></td><td> &nbsp;Subject
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.3.2">1.3.2</a></td><td> &nbsp;Pattern Matching
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.3.3">1.3.3</a></td><td> &nbsp;Pattern Matching Elements
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.3.4">1.3.4</a></td><td> &nbsp;Branching
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.3.5">1.3.5</a></td><td> &nbsp;Built-In Functions
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#1.3.6">1.3.6</a></td><td> &nbsp;User Defined Functions
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#2.">2.</a></td><td> &nbsp;Usage
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#3.">3.</a></td><td> &nbsp;Examples
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#4.">4.</a></td><td> &nbsp;Compiler/Interpreter
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#4.1">4.1</a></td><td> &nbsp;Architecture
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#4.2">4.2</a></td><td> &nbsp;Execution
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#4.3">4.3</a></td><td> &nbsp;Virtual Machine Operators
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#4.4">4.4</a></td><td> &nbsp;Extending the Interpreter
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#5.">5.</a></td><td> &nbsp;Installation
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#6.">6.</a></td><td> &nbsp;Change Log
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#7.">7.</a></td><td> &nbsp;Point of Contact
</td></tr><tr><td><a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#8.">8.</a></td><td> &nbsp;License
</td></tr></tbody></table>

<h2 class="break"><a name="1.">1.</a> &nbsp;Snobol3 Language Reference</h2>
This section documents the language as implemented in this
interpreter. Except where noted, it adheres closely to the language as defined
in this book.
<blockquote>
"Snobol 3 Primer: an introduction to the
computer programming language." by Allen Forte. M.1.T. Press, 1967.
</blockquote>
If any reader of this detects an error in interpretation
or in some missing feature, please contact the author.
<p>
Since there are many similarities, knowledge of Snobol4
as defined in this book
</p><blockquote>
"The SNOBOL 4 programming language" (2nd Ed.)
by R. E. Griswold, J. F. Poage, and I. P. Polonsky.
Prentice-Hall, 1971.
</blockquote>
may be helpful.

<h3><a name="1.1">1.1</a> &nbsp;Lexical Structure</h3>
Snobol3, like FORTRAN, uses column position to indicate
some kinds of lexical items.  In particular, the following
characters in column 1 have the following meaning (using regular expression
syntax).
<p>
<table>
<tbody><tr><td>[*]</td><td>Asterisk: rest of the line is a Comment.
</td></tr><tr><td>[.]</td><td>Period: this is a continuation of the preceding line.</td><td width="110">[a-zA-Z0-9]</td><td>Label: the line has a label.</td><td>[&nbsp;\t]'</td><td>Whitespace: the line has no label.</td><td>[-]</td><td>Dash: indicates certain flags.
The set of flags specified in the Primer are useless in modern computing
environments. Instead, this marker has been modified to 
allow the insertion of command line option flags (Section ?)
into the program. The general form is "<tt>-name[=value]</tt>";
the value is optional and if missing is presumed be the value "true".
</td></tr></tbody></table>
</p><p>
The lexical elements are defined as follows (using regular expressions).
<table>
<tbody><tr valign="top"><td>[a-zA-Z0-9.]+
</td><td>	</td><td><b>Name</b>;
	Note that in Snobol3, a string of digits is a name.

</td></tr><tr valign="top"><td>[a-zA-Z0-9][a-zA-Z.]*
</td><td>	</td><td><b>Label</b>;
	Note that labels are a restricted set of names.
	</td>

</tr><tr valign="top"><td>[/+-=()*,/$]
</td><td>	</td><td><b>Delimiters</b>
	
	
</td></tr><tr valign="top"><td>['][^'\n]*[']
</td><td>	</td><td><b>String</b>;
	Note the use of single quotes and that string constants
	may not cross line boundaries.
	As an extension, options exist (Section ?) to allow
	the use of double quotes and to allow the inclusion
	of escape sequences (e.g., '\n') in strings.
	
</td></tr><tr valign="top"><td>[ \t]
</td><td>	</td><td><b>Whitespace</b>;
	This is removed from the token stream before the parser sees it.
	
</td></tr></tbody></table>
</p><p>
Notes:
</p><ul>
<li>Lexically, DIV and SLASH are distinct tokens
even though they have the same associated string. Snobol3
parsing requires this in order to disambiguate certain
sentences. The distinction made in the lexer is that all arithmetic
operators must be surrounded by whitespace.
This means that the SLASH token that occurs in a branch must
be immediately followed by "s","f", or "(".
<p>
</p></li><li>The following names are keywords:
"define", "s", "f", "end", "return", and "freturn".
It is unclear if these are reserved words, but since it
simplifies the grammar, they are treated as reserved in this
interpreter.
<p>
</p></li><li>In snobol3, many of the symbols are in upper case,
except where noted, this interpreter equates lower case 
and upper case for keywords or built-in function names.
Names and labels are still case sensitive.
</li></ul>
<h3><a name="1.2">1.2</a> &nbsp;Grammar</h3>

The following grammar defines the language relative to the
lexical elements described above.
with obvious name changes
(e.g. the delimiter '=' is called EQUAL).
EOF of course stands for end-of-file, and EOL stands for
end-of-line.

<h4>Grammar Specification</h4>
<p>
<font size="-2">
</font></p><pre><font size="-2">program: (statement)+ EOF;
statement:   (LABEL)? (body)?  EOL;
body: subject (pattern)? (replacement)? (branch)?;
subject: primary;
replacement: EQUAL (concat)?;

concat: (expr)+;
expr: term ((PLUS|MINUS) term)*;
term: primary ((MULT|DIV) primary)*;
primary: atom | LPAREN unary RPAREN ;
unary: concat | (PLUS|MINUS) concat ;
atom: var | STRING | fcncall;

var: reference | NAME;
reference: DOLLAR primary;

fcncall: FCNNAME args ;
args: LPAREN (arglist)? RPAREN ;
arglist: concat (COMMA concat)* ;

pattern: (pattest)+;
pattest: patvar | expr;
patvar:   STAR patmatch STAR ;
patmatch:   (var)? (SLASH primary | BAR patfcn)? | LPAREN (var)? RPAREN ;
patfcn: PATFCNNAME args ;

branch: SLASH (s (f)? | f (s)? | go);

s: SUCCESS LPAREN dest RPAREN ;
f: FAIL LPAREN dest RPAREN ;
go: LPAREN dest RPAREN ;
dest: label| RETURN | FRETURN | END | reference;
label: LABEL | NAME;
</font></pre><font size="-2">
</font>
<p>
This grammar can be processed by Antlr,
although Antlr was not used throughout
because of the problem of building the lexer
and because it was overkill for such a simple language.

In the rest of this document, &lt;...&gt; generally refers
to a grammar non-terminal from the grammar above.

</p><h3><a name="1.3">1.3</a> &nbsp;Processing Cycle</h3>

Snobol3 is line oriented. Each line consists of
four parts (excluding the label) (see grammar).
Most of the parts are optional in some circumstances.
<ol>
<li> <b>Subject</b>
</li><li> <b>Pattern</b>
</li><li> <b>Replacement</b>
</li><li> <b>Branch</b>
</li></ol>

<h4><a name="1.3.1">1.3.1</a> &nbsp;Subject</h4>

A subject is an &lt;expression&gt; that is computed to produce a string
or a variable reference. It is the target of both pattern matching
and replacement.
<p>
As shown in the grammar, an expression is composed of the following operators:
addition (+), subtraction (-), multiplication (*), and integer division (/).
Concatenation is also allowed and is represented by whitespace
between expressions.
</p><p>
Add, subtract, multiply, and divide have the usual precedence.
Concat has a lower precedence than any of the arithmetic operators.
Parentheses are available to alter the evaluation order in the usual way.
</p><p>
Unary minus and plus are allowed, but only immediately after a
left parenthesis; this again avoids an ambiguity in the grammar.
Unary operators may be an extension to Snobol3; the primer is unclear.
</p><p> 
The atomic elements of an expression are string constants,
variable references, and function calls.
Note that for function calls, it is illegal
to provide too many arguments, but it  is ok to provide
too few; the remaining arguments are padded with the empty string.
</p><p>
In order to remove any ambiguity, a subject expression
must be enclosed in parentheses, unless it is an atom.
</p><p>
<a name="vars"><b>1.3.1.1 Variables</b></a>:
Variables are atomic elements in an expression
(along with string constants and function calls).
Scoping in Snobol3 is two-level: global and local (to function bodies).
This is similar to C.
</p><p>
Variables are specified in one of two ways in Snobol3.
</p><ol>
<li>Name: an occurrence of a name in an expression
is presumed to represent the name of a variable.
<p>
</p></li><li> $(&lt;expression&gt;): a dollar sign followed immediately by
a parenthesized expression is interpreted as a dynamically specified variable.
That is, the expression is computed and converted to a string.
That string is then treated as a variable name.
Note that characters that normally
cannot appear in a name are allowed here.
</li></ol>

<h4><a name="1.3.2">1.3.2</a> &nbsp;Pattern Matching</h4>

The basic pattern matching process
is as follows.
<ol>
<li> The subject string is computed and an associated cursor is set to 0.
The cursor points to the next char to be scanned and ranges
from 0 to subject.length().
<p>
</p></li><li> Each pattern element examines the subject string starting
at the cursor. If there is a match, the pattern saves information
about the substring it matches and moves the cursor to just past
that substring.
<p>
</p></li><li> If a pattern element fails, then it invokes a <em>retry</em>
on the previous element.
<p>
</p></li><li> On retry, the pattern element attempts to extend its match
to include additional characters; it succeeds, then it
invokes the following element to match at the new cursor location.
<p>
</p></li><li> If all elements fail, then the initial cursor is moved ahead
one character and the match moves forward from that point.
If anchoring is in effect, then the initial cursor is not moved
and the whole pattern fails. If the cursor moves past the end of the
subject string, then the whole pattern fails.
</li></ol>

<h4><a name="1.3.3">1.3.3</a> &nbsp;Pattern Matching Elements</h4>

Initial:
Succeed matching zero characters.
If var is specified, then assign the current matched substring to var.
<p>
Retry: if the cursor is at the end of the subject string, fail.
Otherwise, extend the match by one char and succeed.
If var is specified, then assign the current matched substring to var.

</p><table>
<tbody><tr><th>Shorthand Name</th><th>Syntax</th><th>Definition</th>
</tr><tr><td><hr></td><td><hr></td><td><hr>

</td></tr><tr valign="top">
<td><a name="stringmatch">StringMatch</a>
</td><td>&lt;expression&gt;
</td><td>Initial:
Succeed if the substring
at the cursor matches the specified string that is the result of computing
the expression; fail otherwise.
<p>
Retry: fail always.

</p></td></tr><tr height="20">

</tr><tr valign="top">
<td><a name="arb">Arb</a>
</td><td>*&lt;var&gt;*</td></tr><tr height="20">

</tr><tr valign="top">
<td><a name="len">Len</a>
</td><td width="150">*&lt;var&gt;/&lt;expr&gt;*
</td><td>Initial:
Compute &lt;expr&gt; as an integer, call it length.
It there are at least length characters following the cursor,
then match those characters and succeed, otherwise fail.
If var is specified, then assign the current matched substring to var.
<p>Retry: fail always.

</p></td></tr><tr height="20">

</tr><tr valign="top">
<td><a name="bal">Bal(anced)</a>
</td><td>*(&lt;var&gt;)*
</td><td>Initial:
Examine the character under the cursor, and act as follows.
<tr<td>[^()]</tr<td><table>
<tbody><tr><td>Match the character and succeed.
<tr<td>[)]</tr<td></td><td>Always fail.
<tr<td>[(]</tr<td></td><td>Scan ahead to find the shortest matching substring
such that the number of parentheses is balanced.
If the end of the subject string is reached without balance, fail,
otherwise succeed and match the balanced substring.
</td></tr></tbody></table>
If var is specified, then assign the current matched substring to var.
<p>Retry: Same as initial.
If var is specified, then assign the current matched substring to var.

</p></td></tr><tr height="20">

</tr><tr valign="top">
<td><a name="Pattern Function">Various</a>
</td><td width="150">*&lt;var&gt;|&lt;fcncall&gt;*
</td><td>Initial:
Compute the arguments to the function and invoke the
"initial()" entry for the function (see Section 4.1.4.1).
On success, and if the var is specified,
then assign the current matched substring to var.
<p>Retry: 
Invoke the "retry()" entry for the function.
On success, and if the var is specified,
then assign the current matched substring to var.


</p></td></tr></tbody></table>

<h4><a name="1.3.4">1.3.4</a> &nbsp;Replacement</h4>
If the subject evaluates to a
<a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#vars">variable</a>,
then all or part of its current value can be replaced
by a string of characters. If there is no &lt;pattern&gt;
specified in the statement, then a replacement will replace the
entire contents
of the variable with the value of the replacement expression.
Note that a missing replacement expression is treated as equivalent to
the empty string; e.g.,
<pre>    = ''
</pre>
<p>
If a &lt;pattern&gt; is specified in the statement,
then if the match succeeds, then the substring of the subject
that is matched by the pattern is replaced by the value
of the replacement expression.

</p><h4><a name="1.3.4">1.3.4</a> &nbsp;Branching</h4>
Any function call evaluation
or pattern match may return a condition code
of success or failure.
In the event that a failure is signaled,
then the processing of the rest of the statement is
terminated, and execution of the statement branch part
occurs. If the branch specifies a failure case of (e.g.) the form
<font size="-2"><pre>    f(label1)
</pre></font>
then transfer of control goes to the statement labeled "label1".
If success is signaled, then execution of the statement continues
until the branch part is reached. If a success case is signaled (e.g.)
<font size="-2"><pre>    s(label1)
</pre></font>
then transfer of control goes to the label specified by the success case.
It is also possible to specify an unconditional branch
<font size="-2"><pre>    (label1)
</pre></font>
that will be executed no matter what value of the condition code.
<p>
It is unclear what happens if the evaluation of an expression fails
and there is no f() branch specified; does it continue to
execute, or does it stop the stmt execution and move to the next
statement? This interpreter assumes the latter action.
</p><p>
It is also unclear exactly what combinations of branches
are allowed. This interpreter assumes the following
combinations are allowed.
</p><ul>
<li> A success branch followed by an optional failure branch,
</li><li> A failure branch followed by an optional success branch, or
</li><li> An unconditional branch only.
</li></ul>

<h4><a name="1.3.5">1.3.5</a> &nbsp;Built-In Functions</h4>
In the following definitions, arguments "s" and "t", and "u" refer
to string values and "i" and "j" refer to integer valued arguments.
Note that integers are actually encoded as strings since
an integer outside of string would be interpreted as a name.
<p>
<table>
<tbody><tr valign="top">
	<td>EQUALS(s,t)</td><td>Succeeds if s.equals(t) (in the Java sense); fails otherwise
</td></tr><tr valign="top">
	<td>UNEQL(s,t)</td><td>Succeeds if !s.equals(t); fails otherwise.
</td></tr><tr valign="top">
	<td>SIZE(s)</td><td>returns s.length(); always succeeds.
</td></tr><tr valign="top">
	<td>EQ(i,j)</td><td>Succeeds if i == j (as integers); fails otherwise.
</td></tr><tr valign="top">
	<td>GE(i,j)</td><td>Succeeds if i &gt;= j (as integers); fails otherwise.
</td></tr><tr valign="top">
	<td>GT(i,j)</td><td>Succeeds if i &gt; j (as integers); fails otherwise.
</td></tr><tr valign="top">
	<td>LE(i,j)</td><td>Succeeds if i &lt;= j (as integers); fails otherwise.
</td></tr><tr valign="top">
	<td>LT(i,j)</td><td>Succeeds if i &lt; j (as integers); fails otherwise.
</td></tr><tr valign="top">
	<td>NE(i,j)</td><td>Succeeds if i != j (as integers); fails otherwise.
</td></tr><tr valign="top">
	<td>NUM(s)</td><td>Succeeds if Integer.decode(s) succeeds ; fails otherwise.
</td></tr><tr valign="top">
	<td>REMDR(i,j)</td><td>Computes i % j (the remainder function); always succeeds; division by zero causes interpreter to halt.
</td></tr><tr valign="top">
	<td>ANCHOR()</td><td>Causes the current pattern match to operate in anchored mode; always succeeds; usually the first element in a pattern.
</td></tr><tr valign="top">
	<td>UNANCH()</td><td>Causes the current pattern match to operate in unanchored mode; always succeeds; usually the first element in a pattern.
</td></tr><tr valign="top">
	<td>PRINT(s)</td><td>cause the variable $(s) to operate in
<a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html">output mode</a>.
</td></tr><tr valign="top">
	<td>READ(s)</td><td>cause the variable $(s) to operate in
<a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html">input mode</a>.
</td></tr><tr valign="top">
	<td>MODE(s)</td><td>The argument string s specifies a series of one or more
comma separated flags that affect the global operation of the interpreter.
The currently defined mode flags are as follows.
</td></tr><tr><td></td><td>
    <table>
    <tbody><tr valign="top"><td><em>anchor</em></td><td>-</td><td>Globally set anchored mode to true as the default.
    </td></tr><tr valign="top"><td><em>unanchor</em></td><td>-</td><td>Globally set anchored mode to false as the default.</td><td>
    </td></tr><tr valign="top"><td><em>dump</em></td><td>-</td><td>Dump the value of all defined global variables at the end of the program's execution.
    </td></tr><tr valign="top"><td><em>dumper</em></td><td>-</td><td>Dump the
            value of all defined global variables at the end
            of the program's execution if the program has
            terminated with an error.
    </td></tr></tbody></table>
<p>
Mode flags can be set either in the program using the MODE function
or using the "-mode" option flag on the command line (Section ?).
The expression "MODE('x,y')" is equivalent to
specifying the option flag on the command line (e.g., <tt>-mode "x,y"</tt>).

</p></td></tr><tr valign="top">
<td>TRACE(s)</td><td>The argument string s specifies a series of one or more
comma separated function names.
After the execution of this function, the calls to this function
and the return value will be traced and printed to stdout.
</td></tr><tr valign="top">
<td>STRACE(s)</td><td>The argument string s specifies a series of one or more
comma separated variable names.
After the execution of this function, all assignments to any of these
variables will be traced and printed to stderr.
Note that the primer indicates that the argument, s, can only specify one
variable name; it has been extended here to support multiple names.

</td></tr><tr valign="top">
<td>CALL(s)</td><td>The argument string s specifies a function call.
It is dynamically interpreted and the corresponding function is invoked
as if it occurred at the point of the CALL function.

</td></tr><tr valign="top">
<td>DEFINE(s,t,u...)</td><td>The argument string s specifies the
definition of a function. The t argument specifies a label
that represents the first statement in the function body.
The sequence of zero or more u arguments represent the names
of variables that should be given local scope when the function
is executed.
</td></tr></tbody></table>

</p><h4><a name="1.3.6">1.3.6</a> &nbsp;User Defined Functions</h4>
Snobol3 has the same, rather baroque, method for defining functions
as does Snobol4.
<p>
A function is defined using the "DEFINE" built-in function.
This is treated in a non-standard way in that it is actually
evaluated at compile time, and hence its
arguments can only be constant strings.
This also means that it cannot be invoked dynamically.
The reasons for this is that it makes code generation overly difficult
and that it seems to have no use.
</p><p>
The define "declaration" must precede
the label which marks the function body.
This means as a rule that you will have
a sequence of defines interspersed with or preceding
a sequence of function bodies. Appropriate
unconditional branches must be associated with one or more
defines to jump around the function bodies.
</p><p>
The general form of a function declaration is
</p><blockquote>
DEFINE(s,t,u...)
</blockquote>
where the string s specifies the
definition of a function. The t argument specifies a label
that represents the first statement in the function body.
The sequence of zero or more u arguments represent the names
of variables that should be given local scope when the function
is executed.
<p>
Syntactically, the function definition (string s)
and the locals list (strings u...) follow this grammar.
<font size="-2"></font></p><pre><font size="-2">fcndecl:  NAME LPAREN (formals)? RPAREN;
formals:  namelist;
locals:   namelist;
namelist: NAME (COMMA (NAME)?)*;
</font></pre>
<p>
Invoking a function causes its actual arguments to be evaluated
and assigned to the corresponding formal arguments.
The formals arguments are treated as variables with local scope.
The list of locals are initialized to the empty string and,
of course, also have local scope.
Finally, functions return values by assigning to a variable
with the same name as the function. This pseudo-variable
also has local scope.

</p><h4><a name="1.3.7">1.3.7</a> &nbsp;IO</h4>
Snobol3 input/output is basically line-oriented.
The language does not have specific IO functions,
but rather associates IO with specific variables.
For example, every time a value is assigned to
the variable SYSPOT, that value is printed to the standard
output as a single line.
Similarly, every time the value of SYSPPT is obtained,
it reads and returns a line of text from standard input
(minus any trailing newline).
<p>
The variables "SYSPOT" and "SYSPPT" are predefined.
The language has been extended to also predefine the
variables "stdin" and "stdout" as additional
input and output variables respectively.
</p><p>
It is possible to define additional input and output variables
using the primitive functions
"READ(&lt;var&gt;)"
and 
"PRINT(&lt;var&gt;)"
respectively.
The PRINT function has been extended to take a second
string argument. The second argument is a comma separated
list of flags.  Currently the following flags are defined.
</p><ul>
<li><tt>nonewline</tt> - A newline is <i>not</i> automatically added to the line as printed.
</li><li><tt>stderr</tt> - Cause this variable's output to go to the standard
error stream instead of standard output. The variable "stderr"
is predefined as such a variable.
</li></ul>

<h2 class="break"><a name="2.">2.</a> &nbsp;Usage</h2>
The interpreter is setup as a Java jar file named "s3.jar",
with jsnobol3.Snobol3 as the main class (defined in the
jar manifest file).
Invocation can either be the usual form for executing jar files
or a direct invocation of the main class.
<blockquote>
<tt>java&nbsp;-jar&nbsp;s3.jar&nbsp;[&lt;options&gt;]&nbsp;&lt;program&gt;</tt>
<br>or<br>
<tt>java&nbsp;-classpath&nbsp;s3.jar&nbsp;jsnobol3.Snobol3&nbsp;[&lt;options&gt;]&nbsp;&lt;program&gt;</tt>
</blockquote>
The possible option flags are as follows.
Boolean options (such as -exec) may be preceded by "no" (e.g., "-noexec")
to negate the flag.
<dl>
<dt>-envfile &lt;filename&gt; </dt><dd>Specifies a file from which to read
			    additional options.
</dd><dt>-debug</dt><dd>Provide some levels of debug output.
</dd><dt>-stacktrace</dt><dd>Dump a Java stacktrace on fatal errors.
</dd><dt>-exec</dt><dd>Cause the compiled program to execute. The "-noexec"
flag will prevent execution. 
</dd><dt>-mode</dt><dd>Equivalent to including a "MODE()" function
call at the beginning of the program.
</dd><dt>-dquotes</dt><dd>Allow programs to use double quotes as well as single quotes.
</dd><dt>-escapes</dt><dd>Allow string constants to include standard
		escape sequences such as '\n' or '\u00ff'.
</dd><dt>-lint</dt><dd>Provide some extra checking to detect such things
	     as potential fall thru into a function body.
</dd></dl>

<h2 class="break"><a name="3.">3.</a> &nbsp;Examples</h2>

<b>Absolute Value</b>
<font size="-2"><pre>        define('abs(abs)','abs') /(main)
abs         abs '-' = /(return)
main    stdout = abs('-5')
        stdout = abs('5')
</pre></font>
<p>
<b>Greatest Common Divisor</b>
<font size="-2"></font></p><pre><font size="-2">        define('gcd(m,n)','gcd') /(main)
gcd         gcd = .ne(m) m /f(return)
            m = .remdr(n,m)
            n = gcd /(gcd)
main    stdout = gcd('12','18')
</font></pre>
<p>
<b>Recursive Factorial</b>
<font size="-2"></font></p><pre><font size="-2">        define('rfact(n)','rfact') /(main)
rfact       rfact = .le(n,'1') '1' /s(return)
            rfact = n * rfact(n - '1') /(return)
main    stdout = rfact('4')
</font></pre>
<p>
<b>Iterative Factorial</b>
<font size="-2"></font></p><pre><font size="-2">        define('fact(n)','fact') /(main)
fact        fact = '1'
fact2	    fact = .gt(n) fact * n /f(return)
	    n = n - '1' /(fact2)
main    stdout = fact('4')
</font></pre>

<h2 class="break"><a name="4.">4.</a> &nbsp;Compiler/Interpreter</h2>

<h3><a name="4.1">4.1</a> &nbsp;Architecture</h3>
The interpreter/compiler operates in three passes.

<h4>Pass1: Lexical Cleanup</h4>
The first pass reads in the whole program and processes each line
based on the character in the first column.
<tr"></tr"><table>
<caption><u>Column 1 Processing</u></caption>
<tbody><tr><th>Character<hr></th><th>Action<hr>
</th></tr><tr valign="top"><td align="center">"*"</td><td>This signals a comment; remove it.
</td></tr><tr valign="top"><td align="center">"."</td><td>This signals a continuation; combine with previous
line to form one single line.
</td></tr><tr valign="top"><td align="center">"-"</td><td>This signals an option of form
"<tt>name[=value]</tt>"; save in the options map and otherwise treat the
line like a comment. The possible values are the same as for
command line options (Section ?).
</td></tr><tr valign="top"><td align="center">Label Character</td><td>This signals that the line
has a label; collect it and store in the "labels" table, otherwise
do nothing.
</td></tr><tr valign="top"><td align="center" width="150">Whitespace ([ \t])</td><td>This signals that the
line has no label; do nothing.
</td></tr></tbody></table>

<h4>Pass2: Parsing</h4>
The second pass applies the grammar in Section ?
to parse the sequence of statements as constructed during pass1.
The output from the parse is an abstract syntax tree (AST).

<h4>Pass3: Translation to Pseudo-Code</h4>
In pass 3, the AST is walked and a sequence of operators
is constructed. The result is an array of Operator objects.
This is passed to the virtual Machine (VM) for execution.
<p>
Pass 3 actually has a second sub-pass to handle forward referencing
of labels. A binding list is kept that lists the operators
that need to be bound to a specific address for a specific named
label. This list is walked after all other
code generation.
Each specified operator is modified
to refer the to address of the specified label.
</p><p>
The "grammar" for the AST is as follows.
<font size="-2"></font></p><pre><font size="-2">program: PROGRAM (statement)*;
statement: STATEMENT LINENO (LABEL)? subj=(primary)? (pattern)? repl=(concat)? (branch)?;
concat: expr | CONCAT (expr)+;
expr: term | ADD term term | SUBSTRACT term term;
term: primary | MULT primary primary | DIV primary primary;
var: NAME String | reference;
reference: REFERENCE primary;
primary: unary | atom ;
unary: concat | NEGATE concat;
atom: STRING | var | fcncall;
fcncall: FCNCALL String arglist;
arglist: ARGLIST (concat)*;
pattern: PATTERN (pattest)*;
pattest: patmatch | expr;
patmatch: BALANCE (var)? | LEN (var)? primary | PATFCN (var)? fcncall | ARB (var)?;
branch: BRANCH dest dest dest;
dest: label | reference;
fcndel: DEFINITION String namelist;
namelist: NAMELIST (NAME)*;
LABEL: [String];
NAME: [String] ;
FCNCALL: [String];
STRING: [String];
LINENO: [Integer];
</font></pre>
<p>
The right side describes the structure of an AST node.
The names in capitals represent the type of the node.
The subtrees, if any, are defined by the structures
that follow the type.
Thus, a "branch" AST has the type BRANCH and has three
subtrees that have the structure defined by "dest".
</p><p>
Right sides that consist of a single bracketed type
are leaves and have an associated value of that Java type.
Thus, a LABEL is a leaf with the label name encoded as a
Java String object.

</p><h3 class="break"><a name="4.2">4.2</a> &nbsp;Execution</h3>
The virtual machine interpreter, VM (in file "VM.java"),
is more-or-less a standard stack machine.
It has a program counter (pc) that specifies the next
operator to execute.
Its main loop reads the operator at code[pc],
increments pc, and then invokes the execute() method
of the operator.
It continues until the End operator is executed
or a fatal error occurs.
<p>
To execute, the operator obtains its arguments, if any,
and then performs its specific action. This action
typically will pop its arguments, perform some computation,
and push a result onto the stack.
</p><p>
An Operator can obtain arguments in two ways.
First, it can access the stack using push(),pop(), and top().
Second, it can have a constant argument built into
the Operator instance.

</p><h4 class="break"><a name="4.3">4.3</a> &nbsp;Virtual Machine Operators</h4>
In the following,
constant arguments are indicated in square brackets
and
stack arguments are indicated in parentheses, with the topmost on the stack
argument being the rightmost in the parentheses.
The first list contains all non-pattern operators, which
are defined in "Operator.java". The second list
contains pattern related operators, which are defined in "PatternOp.java".
<p>
<u>Operators</u>
<table>
<tbody><tr><td width="125">Add(a,b)</td><td>a = a + b
</td></tr><tr><td>AssignLocal(value,var)
    </td><td>Assign the value to a local variable.
</td></tr><tr><td>Assign(value,var)
    </td><td>Assign the value to a variable; If the variable is defined
        locally or globally, then assign to that variable, otherwise
	create locally if possible, globally otherwise.
</td></tr><tr><td>Begin</td><td>Do any necessary initialization at the start
                 of the whole program.
</td></tr><tr><td>BeginFcn</td><td>Create the new local space for this invocation
                    of the function.
</td></tr><tr valign="top"><td>BeginStmt[dest,lineno]
		</td><td>Mark the stack for use by EndStmt,
			initialize the condition code, and save dest
			as a pointer to the end of the statement.
			Also, set the source line number for the statement.
</td></tr><tr><td>CVI</td><td>Convert the top stack value to an Integer.
</td></tr><tr><td>CVS</td><td>Convert the top stack value to a String.
</td></tr><tr><td>CVV</td><td>Convert the top stack value to a variable (the "$" operator).
</td></tr><tr><td>CallRet</td><td>Used by the CALL statement to cause a call to return
		   after the CALL statement.
</td></tr><tr><td>Concat(a,b...)[N]
    </td><td>Concatenate the top N elements into a single string.
</td></tr><tr><td>Deref(var)</td><td>Replace the var with its value on the stack.
</td></tr><tr><td>Div(a,b)</td><td>a = a / b; using integer division
</td></tr><tr><td>Dup(a)</td><td>Push a copy of a onto the stack.
</td></tr><tr><td>End</td><td>Signal the virtual machine to stop executing.
</td></tr><tr><td>EndStmt[sdest,fdest]</td><td>Clear the stack down to the point marked by the
previous BeginStmt. Use the condition code to start execution
of the success or failure branches.
</td></tr><tr><td>Frame</td><td>Save the current frame and create a new one
on entry to a function.
</td></tr><tr><td>FReturn</td><td>Set the condition code to failure and return
to just after the call.
</td></tr><tr><td>IJump(var)</td><td>Pop the var, get its value, and use it as
a label name to which to jump.
</td></tr><tr><td>JSR[dest]</td><td>Save the pc into the VM's frame and jump to the specified
destination. This is effectively the call instruction for invoking a function.
</td></tr><tr><td>Jump[dest]</td><td>Jump to dest.
<!--<tr><td>Lineno[lineno]<td>Set the source line number for the statement now
begin executed.-->
</td></tr><tr><td>Mult(a,b)</td><td>a = a * b
</td></tr><tr><td>Negate(a)</td><td>a = - a
</td></tr><tr><td>Nth</td><td>Extract the nth element in the eval stack, with n=0
as the stack top.
</td></tr><tr><td>Primitive[primfcn]</td><td>Invoke the specified primitive function.
</td></tr><tr><td>Push[value]</td><td>Push value onto the eval stack.
</td></tr><tr><td>Replace(var,range,rhs)</td><td>Replace the substring of the var
as specified by the range with the rhs value. Pop all three from stack.
</td></tr><tr><td>RetVal</td><td>Extract the return value for a user defined function
and load it into the return value in the VM. Recall that the return
value for a user defined function is the variable with the same name
as the function.
</td></tr><tr><td>Return</td><td>Push the VM's current return value onto the eval stack.
</td></tr><tr><td>Subtract(a,b)</td><td>a = a - b
</td></tr><tr><td>Swap(a,b)</td><td>tmp=a; a=b; b=tmp; (Swap top two eval stack elements).
</td></tr><tr><td>Unframe</td><td>Throw away the current frame and return to the
previous frame. Used as part of the function return process.
</td></tr></tbody></table>
</p><p>
<u>Pattern Related Operators</u>
<table>
<tbody><tr><td>Arb
    </td><td>Implement the <a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#arb">Arb</a> pattern element.
</td></tr><tr><td>Balance
    </td><td>Implement the <a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#bal">Balanced</a>
	pattern element.
</td></tr><tr><td>BeginPattern(subject,var)
	</td><td>Load the subject string into the VM's match state.
	    If the subject is also a variable, then load that as well.
	    On retry, move the anchor point if allowed, otherwise fail.
</td></tr><tr><td>EndPattern(range...)</td><td>Successful conclusion to a match, so capture
the full range matched by the pattern, remove all interim ranges,
and leave the full range on the stack.
</td></tr><tr><td>Len
</td><td>Implement the <a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/*len">Len</a> pattern element.
</td></tr><tr><td>StringMatch
</td><td>Implement the <a target="_self" href="http://web.archive.org/web/20060922152953/http://serl.cs.colorado.edu/%7Edennis/software/s3/s3-1.0/doc/refman.html#stringmatch">StringMatch</a> pattern element.
</td></tr></tbody></table>
</p><p>
It would be interesting to see if this set could
be converted to use the Snobol4 macro operators.

</p><h4 class="break"><a name="4.4">4.4</a> &nbsp;Extending the Interpreter</h4>

<h5>4.4.1 &nbsp; Adding a New Primitive Function</h5>

Each primitive function definition is encapsulated as a class
that is a subclass of the class "Primitive".
Let us define a new function called "rematch(s,re)".
This function fails if the regular expression re does not match
the target string s. It succeeds otherwise.
<p>
To define the function, we add the following code to the
source file "Primitive.java".
<font size="-2">
</font></p><pre><font size="-2">class $REmatch // The primitive class names begin with $ as a convention.
      extends Primitive
{
    public $REmatch() {super(2);} // This function &lt;= 2 arguments
    public ArgType typeFor(int argi)
	{return ArgType.CVS;} // All arguments are required to be a string
			      // The compiler will insert appropriate CVS
			      // operators to ensure this.
    public void execute(VM vm, PrimFunction fcn) throws Failure
    {
	String re = (String)vm.pop(); // pop regular expression off the stack.
	String s = (String)vm.pop(); // pop target string off the stack.
	if(re.length() == 0)
	    throw new Failure(vm,"rematch: empty regular expression");
	// See if the string can be matched by the RE
	boolean match = false;
	try {
	    match = s.matches(re);
	} catch (PatternSyntaxException pse) {
	    throw new Failure(vm,"rematch: illegal regular expression: "+re);
	}
	vm.cc = !match; // if the match failed, then set the condition code.
	setReturn(); // return empty string on success
    }
}
</font></pre><font size="-2">
</font>
This function is made known to the interpreter
by adding the following line to the procedure
"definePrimitives()" at the top of the file "Primitive.java".
<font size="-2"><pre>        fcnDef("rematch",(p=new $REMatch()));
</pre></font>

<h5 class="break">4.4.2 &nbsp; Adding a New Pattern Element</h5>
Adding a new pattern element 
is somewhat more complicated than adding an operator
because it must support both initial and retry cases.
It also requires an extension to the syntax of
Snobol3 so that new pattern operators can be specified.
The syntax chosen (also mentioned in Section 1.2) is patterned
on the following form.
<font size="-2"><pre>    *&lt;var&gt;|&lt;fcncall&gt;*
</pre></font>
<p>
The example below defines a variant of the balanced pattern.
It takes one argument: a string of length two and specifying
the left and right brackets to match.
Thus, the operator <tt>*(x)*</tt>
would be equivalent to <tt>*x|bracket('()')*</tt>.
</p><p>
To define the function, we add the following code to the
source file "PatternOp.java".
<font size="-2">
</font></p><pre><font size="-2">class BracketOp extends PatternOp
{
    char lbracket = 0;
    char rbracket = 0;

    public BracketOp() {super();}
    public int nargs() {return 1;}

    // On entry, the stack from top down contains the following items:
    // top: function argument n 
    //      function argument n-1 
    // ...
    //      function argument 1
    //      var name or null if none specified

    public void initial() throws Failure
    {
	// get the bracket pair
	String pair = (String)vm.pop();
	// get name of our variable from stack and keep until failure
	opvar = (VRef)vm.pop();
	if(pair.length() != 2)
	    throw new Failure(vm,"Bracket: illegal bracket pair: "+pair);
	// decompose the bracket pair
	lbracket = pair.charAt(0);
	rbracket = pair.charAt(1);
	// create an initial range value
	Range r = new Range(state.cursor,state.cursor);
	if(!bracket(r)) {
	    fail(r.r0); // fail and revert the cursor
	} else {
	    assign(r);  // assign the range to the variable, if any
	    succeed(r); // succeed, saving the current range on the stack
	}
    }

    public void retry() throws Failure
    {
	Range r = (Range)vm.pop(); // obtain the range from the last retry
	if(!bracket(r)) fail(r.r0); else {assign(r); succeed(r);}
    }

    boolean bracket(Range r)
    {
	String subject = state.subject; // get the subject string
	int len = subject.length(); // and length
	if(r.rn &gt;= len) return false; // if we have matched to the end,
				      // we cannot extend, so signal failure
	char ch = subject.charAt(r.rn);
	if(ch == rbracket)
	    return false; // if the next character is the rbracket, fail
	if(ch != lbracket) {
	    r.rn++;   // if next character is not an lbracket, advance one char
	    return true; // and succeed
	}
	// Only case left is that we are at an lbracket, need to scan
	// forward to find a matching rbracket, taking nesting into account
	int rn = r.rn+1;
	int depth = 1;
	while(rn &lt; len &amp;&amp; depth &gt; 0) {
	    ch = subject.charAt(rn++);
	    if(ch == lbracket)
		depth++;
	    else if(ch == rbracket)
		depth--;
	    // else do nothing
	}
	if(depth == 0) {
	    r.rn = rn; // record our current last matched char + 1.
	    return true;
	}
	// we got to the end of the subject without balancing the brackets
	return false;
    }
}
</font></pre><font size="-2">
</font>
<p>
This function is made known to the interpreter
by adding the following line to the procedure
"definePatterns()" at the top of the file "PatternOp.java".
<font size="-2"></font></p><pre><font size="-2">    Snobol3.patterns.put("bracket",new BracketOp());
</font></pre>
<p>
There are some things to note.
</p><ol>
<li> The Range class specifies the range of characters
in the subject string currently matched by the given pattern.
The range is like String.substring arguments,
which means that the first index points to the first matched character
and the last index (rn) points to the character
just after the match.
</li></ol>

<h2 class="break"><a name="5.">5.</a> &nbsp;Installation</h2>
The distribution contains both an ant build.xml file
and a Makefile. Both have the following major tasks defined.
<ul>
<li><i>all</i>: Compile the source and construct the jar file.
It is assumed that the JDK 1.5 bin directory
is in the PATH environment variable.
<p></p></li><li><i>clean</i>: Delete the .class files, the jar file,
and the manifest file.
<p></p></li><li><i>tests</i>: Execute all of the test programs.
<p></p></li><li><i>examples</i>: Execute all of the example programs.
</li></ul><a name="6.">6.</a> &nbsp;Change Log
<h3>Version 1.</h3>
<p>
Minor version levels are indicated in parentheses.
</p><ul>
<li> (0) This is the initial release
</li></ul>
<p>

</p><h2 class="break"><a name="7.">7. &nbsp;Point of Contact</a></h2>
<table>
<tbody><tr><td><b>Author:</b></td><td>Dennis Heimbigner
</td></tr><tr><td></td><td>Software Engineering Research Laboratory
</td></tr><tr><td></td><td>Computer Science Department
</td></tr><tr><td></td><td>University of Colorado
</td></tr><tr><td></td><td>Boulder, Colorado 80309-0430 USA
</td></tr><tr><td></td><td>dennis.heimbigner@colorado.edu
</td></tr></tbody></table>
<p>
A Personal Note:
</p><blockquote>
Snobol3 has always held a special fascination for me.
It was the first language I learned (after FORTRAN),
and it was the first language for which I built a partial
interpreter for the IBM 1620 computer in about 1969.
I recently found a copy of the Snobol 3 Primer,
and since I had some time on my hands, I decided 
write an interpreter for it in Java.
</blockquote>

<h2 class="break"><a name="8."><b>8. &nbsp;License</b></a></h2>
This software is released under the
following BSD license.
<font size="-2"><pre>Copyright (c) 2005, Dennis Heimbigner
All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, are permitted provided that the
following conditions are met:
* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.
* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.
* Neither the name of the <organization> nor the names of
  its contributors may be used to endorse or promote
  products derived from this software without specific prior
  written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</organization></pre></font>





<script language="Javascript">
<!--

// FILE ARCHIVED ON 20060922152953 AND RETRIEVED FROM THE
// INTERNET ARCHIVE ON 20110202192212.
// JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.
// ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
// SECTION 108(a)(3)).

   var sWayBackCGI = "http://web.archive.org/web/20060922152953/";

   function xResolveUrl(url) {
      var image = new Image();
      image.src = url;
      return image.src;
   }
   function xLateUrl(aCollection, sProp) {
      var i = 0;
      for(i = 0; i < aCollection.length; i++) {
         var url = aCollection[i][sProp];         if (typeof(url) == "string") { 
          if (url.indexOf("mailto:") == -1 &&
             url.indexOf("javascript:") == -1
             && url.length > 0) {
            if(url.indexOf("http") != 0) {
                url = xResolveUrl(url);
            }
            url = url.replace('.wstub.archive.org','');
            aCollection[i][sProp] = sWayBackCGI + url;
         }
         }
      }
   }

   xLateUrl(document.getElementsByTagName("IMG"),"src");
   xLateUrl(document.getElementsByTagName("A"),"href");
   xLateUrl(document.getElementsByTagName("AREA"),"href");
   xLateUrl(document.getElementsByTagName("OBJECT"),"codebase");
   xLateUrl(document.getElementsByTagName("OBJECT"),"data");
   xLateUrl(document.getElementsByTagName("APPLET"),"codebase");
   xLateUrl(document.getElementsByTagName("APPLET"),"archive");
   xLateUrl(document.getElementsByTagName("EMBED"),"src");
   xLateUrl(document.getElementsByTagName("BODY"),"background");
   xLateUrl(document.getElementsByTagName("TD"),"background");
   xLateUrl(document.getElementsByTagName("INPUT"),"src");
   var forms = document.getElementsByTagName("FORM");
   if (forms) {
       var j = 0;
       for (j = 0; j < forms.length; j++) {
              f = forms[j];
              if (typeof(f.action)  == "string") {
                 if(typeof(f.method)  == "string") {
                     if(typeof(f.method) != "post") {
                        f.action = sWayBackCGI + f.action;
                     }
                  }
              }
        }
    }


//-->
</script>

</body><!-- SOME LINK HREF'S ON THIS PAGE HAVE BEEN REWRITTEN BY THE WAYBACK MACHINE
OF THE INTERNET ARCHIVE IN ORDER TO PRESERVE THE TEMPORAL INTEGRITY OF THE SESSION. --></html>