* Generated by setuputil.sno setup.makeinclude() 11/17/2016 23:13:55
	SQLITE3_DL = "sqlite3"
**=pea
**=sect NAME
**snobol4sqlite3 \- SQLITE3 interface for SNOBOL4
**=sect SYNOPSYS
**B<-INCLUDE 'sqlite3.sno'>
**=sect DESCRIPTION
**=item B<SQLITE3_OPEN(>I<path>B<)>
**opens a database and returns a database handle or failure.
**=cut
	LOAD("SQLITE3_OPEN(STRING)", SQLITE3_DL)
**=pea
**=item B<SQLITE3_CLOSE(>I<db_handle>B<)>
**closes database and returns empty string or failure.
**=cut
	LOAD("SQLITE3_CLOSE(EXTERNAL)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_ERRMSG(>I<db_handle>B<)>
**Returns an SQLITE3 error string or failure if the handle is invalid.
**=cut
	LOAD("SQLITE3_ERRMSG(EXTERNAL)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_LAST_INSERT_ROWID(>I<db_handle>B<)>
**Returns an integer or failure if the handle is invalid.
**=cut
	LOAD("SQLITE3_LAST_INSERT_ROWID(EXTERNAL)INTEGER", SQLITE3_DL)
**=pea
**=item B<SQLITE3_PREPARE(>I<db_handle>,I<SQL>[,I<params ...>]B<)>
**Parses an SQL statement and optionally binds positional parameters to it.
**Call B<SQLITE3_ROW_ARRAY()> or B<SQLITE3_ROW_TABLE()> to fetch a row of results
**once all parameters have been bound.
**Returns a statement handle or failure.
**=cut
	LOAD("SQLITE3_PREPARE(EXTERNAL,STRING)", SQLITE3_DL)
**=pea
**=item B<SQLITE3_BIND_ANY(>I<st_handle>, I<position>, I<value>B<)>
**Binds I<value> at (one-based) I<position> to a prepared SQL statement.
**Returns null string or failure.
**=cut
	LOAD("SQLITE3_BIND_ANY(EXTERNAL,INTEGER,)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_BIND_BLOB(>I<st_handle>, I<position>, I<value>B<)>
**Binds I<value> to (one-based) I<position> as a BLOB value to prepared SQL statement.
**Returns null string or failure.
**=cut
	LOAD("SQLITE3_BIND_BLOB(EXTERNAL,INTEGER,STRING)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_BIND_MANY(>I<st_handle>, I<values ...>B<)>
**Binds multiple positional parameter I<values> to a prepared SQL statement.
**Returns null string or failure.
**=cut
	LOAD("SQLITE3_BIND_MANY(EXTERNAL,)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_BIND_PARAMETER_COUNT(>I<st_handle>B<)>
**Returns the number of parameters required by a prepared SQL statement, or fails.
**=cut
	LOAD("SQLITE3_BIND_PARAMETER_COUNT(EXTERNAL)INTEGER", SQLITE3_DL)
**=pea
**=item B<SQLITE3_BIND_PARAMETER_NAME(>I<st_handle>, I<position>B<)>
**Returns the name (if any) for the parameter I<position> number in
**a prepared SQL statement.
**=cut
	LOAD("SQLITE3_BIND_PARAMETER_NAME(EXTERNAL,INTEGER)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_BIND_PARAMETER_INDEX(>I<st_handle>, I<name>B<)>
**Returns the positional index for named parameter I<name> in
**prepared SQL statement.
**=cut
	LOAD("SQLITE3_BIND_PARAMETER_INDEX(EXTERNAL,STRING)INTEGER", SQLITE3_DL)
	LOAD("SQLITE3_STEP(EXTERNAL)STRING", SQLITE3_DL)
	LOAD("SQLITE3_COLUMN_COUNT(EXTERNAL)INTEGER", SQLITE3_DL)
	LOAD("SQLITE3_COLUMN_NAME(EXTERNAL,INTEGER)STRING", SQLITE3_DL)
	LOAD("SQLITE3_COLUMN_TEXT(EXTERNAL,INTEGER)STRING", SQLITE3_DL)
	LOAD("SQLITE3_COLUMN_VALUE(EXTERNAL,INTEGER)", SQLITE3_DL)
**=pea
**=item B<SQLITE3_CLEAR_BINDINGS(>I<st_handle>B<)>
**Use this routine to reset all parameter bindings to NULL.
**=cut
	LOAD("SQLITE3_CLEAR_BINDINGS(EXTERNAL)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_RESET(>I<st_handle>B<)>
**Reset a prepared statement back to its initial state, ready to be
**re-executed. Any SQL statement variables that had values bound to
**them retain their values. Use B<sqlite3_clear_bindings()>
**to reset the bindings.
**=cut
	LOAD("SQLITE3_RESET(EXTERNAL)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_FINALIZE(>I<st_handle>B<)>
**Release (delete) a statement handle.
**=cut
	LOAD("SQLITE3_FINALIZE(EXTERNAL)STRING", SQLITE3_DL)
**=pea
**=item B<SQLITE3_EXEC(>I<db_handle>,I<SQL statement(s)>B<)>
**Run one or more SQL statements that do not require parameters.
**=cut
	LOAD("SQLITE3_EXEC(EXTERNAL,STRING)STRING", SQLITE3_DL)
**** funcs.sno:
****************************************************************
*	$Id: funcs.sno,v 1.3 2014/12/24 01:28:03 phil Exp $
*	functions for SQLITE3 Interface
*	11/2/2013

****************************************************************
*	Fetch a row, and return as an ARRAY
*
**=pea
**=item B<SQLITE3_ROW_ARRAY(>I<st_handle>B<)>
**Returns an B<ARRAY> with a row of statement results or fails.
**=cut
	DEFINE("SQLITE3_ROW_ARRAY(STMT)S,CC,COL") :(SQLITE3_ROW_ARRAY.END)
SQLITE3_ROW_ARRAY
	DIFFER(SQLITE3_STEP(STMT), "row")	:S(FRETURN)
	CC = SQLITE3_COLUMN_COUNT(STMT)		:F(FRETURN)
	SQLITE3_ROW_ARRAY = ARRAY('0:' CC - 1)
	COL = 0
SQLITE3_ROW_ARRAY.LOOP
+	GE(COL,CC)				:S(RETURN)
	SQLITE3_ROW_ARRAY[COL] = SQLITE3_COLUMN_VALUE(STMT, COL) :F(FRETURN)
	COL = COL + 1				:(SQLITE3_ROW_ARRAY.LOOP)
SQLITE3_ROW_ARRAY.END

****************************************************************
*	Return an ARRAY of COLUMN names
*
**=pea
**=item B<SQLITE3_COLUMN_NAMES_ARRAY(>I<st_handle>B<)>
**Returns an B<ARRAY> with SQL statement result column names or fails.
**=cut
	DEFINE("SQLITE3_COLUMN_NAMES_ARRAY(STMT)CC,COL")
+					:(SQLITE3_COLUMN_NAMES_ARRAY.END)
SQLITE3_COLUMN_NAMES_ARRAY
+	CC = SQLITE3_COLUMN_COUNT(STMT)	:F(FRETURN)
	EQ(CC, 0)			:S(FRETURN)
	SQLITE3_COLUMN_NAMES_ARRAY = ARRAY('0:' CC - 1)
	COL = 0
SQLITE3_COLUMN_NAMES_ARRAY.LOOP
+	GE(COL,CC)			:S(RETURN)
	SQLITE3_COLUMN_NAMES_ARRAY[COL] = 
+		SQLITE3_COLUMN_NAME(STMT, COL) :F(FRETURN)
	COL = COL + 1			:(SQLITE3_COLUMN_NAMES_ARRAY.LOOP)
	:(RETURN)
SQLITE3_COLUMN_NAMES_ARRAY.END

****************************************************************
*	Fetch a row, and return as a TABLE
*
**=pea
**=item B<SQLITE3_ROW_TABLE(>I<st_handle>B<)>
**Returns a B<TABLE> with statement results indexed by column name or fails.
**=cut
	DEFINE("SQLITE3_ROW_TABLE(STMT)CC,COL,NAME")
						:(SQLITE3_ROW_TABLE.END)
SQLITE3_ROW_TABLE
+	DIFFER(SQLITE3_STEP(STMT),"row")	:S(FRETURN)
	CC = SQLITE3_COLUMN_COUNT(STMT)		:F(FRETURN)
	SQLITE3_ROW_TABLE = TABLE()
	COL = 0
SQLITE3_ROW_TABLE.LOOP
+	NAME = SQLITE3_COLUMN_NAME(STMT, COL)	:F(FRETURN)
	SQLITE3_ROW_TABLE[NAME] = SQLITE3_COLUMN_VALUE(STMT, COL) :F(FRETURN)
	COL = COL + 1
	LT(COL, CC)				:S(SQLITE3_ROW_TABLE.LOOP)
	:(RETURN)
SQLITE3_ROW_TABLE.END

****************************************************************
* UNTESTED:
*	Bind prepared statement parameters by name from TABLE TBL
*
*	Alternatively, could try converting TBL to an ARRAY and loop
*	Calling SQLITE3_BIND_PARAMETER_NAME() to convert TABLE
*	keys to integer indices.
*
	DEFINE("SQLITE3_BIND_TABLE(STMT,TBL)PC,I")
						:(SQLITE3_BIND_TABLE.END)
SQLITE3_BIND_TABLE
+	PC = SQLITE3_BIND_PARAMETER_COUNT(STMT)	:F(FRETURN)
	I = 0
SQLITE3_BIND_TABLE.LOOP
+	EQ(I,PC)				:S(RETURN)
	SQLITE3_BIND(STMT, I, TBL[SQLITE3_BIND_PARAMETER_NAME(STMT,I)])
+						:F(FRETURN)
	I = I + 1				:(SQLITE3_BIND_TABLE.LOOP)
SQLITE3_BIND_TABLE.END

****************
**=pea
**=sect SEE ALSO
**B<snobol4>(1)
**=break
**=link http://www.sqlite.org
**=break
**=link http://www.sqlite.org/c3ref/funclist.html
**=cut
******** end funcs.sno
**************** end sqlite3.sno
