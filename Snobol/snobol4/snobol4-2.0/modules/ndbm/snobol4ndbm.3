.\" generated by $Id: snopea.sno,v 1.33 2015/01/02 03:31:20 phil Exp $
.if n .ad l
.ie '\*[.T]'ascii' \{\
.	ds lq \&"\"
.	ds rq \&"\"
.	ds pi \fIpi\fP
.\}
.el \{\
.	ds rq ''
.	ds lq ``
.	ds pi \[*p]
.\}
.nh
.TH SNOBOL4NDBM 3 "January 1, 2015" "CSNOBOL4B 2.0" "CSNOBOL4 Manual"
.SH "NAME"
.nh
snobol4ndbm \- SNOBOL4 NDBM interface
.SH "SYNOPSIS"
.nh
.ft CW
.br
.ne 10
.RS 4
.nh
.nf
-INCLUDE 'ndbm.sno'
        dbhandle = DBM_OPEN(file,flags,mode)
        DBM_CLOSE(dbhandle)
        DBM_STORE(dbhandle,key,datum,flags)
        datum = DBM_FETCH(dbhandle,key)
        DBM_DELETE(dbhandle,key)
        key = DBM_FIRSTKEY(dbhandle)
        key = DBM_NEXTKEY(dbhandle)
        DBM_ERROR(dbhandle)
        DBM_CLEARERR(dbhandle)
.ft R
.fi
.nh
.RE
.SH "DESCRIPTION"
.nh
"NDBM" (for New Data Base Management) is an industry standard fast
hashed storage API first created in 4.3BSD, and included in the Unix
98 (SUSv2) standard.  The original DBM API appeared in AT&T Research
Unix Version 7, and only allowed access to a single file at a time.
.PP
There are many different implementations of this API, including:
.IP \(bu
The original BSD 4.3 ndbm
Based on AT&T dbm.
Found in commercial Un*x offerings.
.IP \(bu
Berkeley DB v1 compatibility interface.
Supplied with 4.4BSD based systems: (Free|Open|Net)BSD, MacOS X.
.IP \(bu
GNU DBM (GDBM)
Found in Linux distributions
(may require a DBM compatibility package to be installed).
.IP \(bu
SDBM, Ozan Yigit's Public Domain implementation of NDBM.
Supplied with this distribution, and used as a last resort
on Un*x systems (and by default on non Un*x systems).
.TP 4
\fBDBM_OPEN(\fP\fIfilename\fP,\fIflags\fP,\fImode\fP)
takes a filename (STRING), flags (either "R" for read-only, "W" for
write access, or "CW" to create and write a new file), and a "mode"
string, which defaults to "0666" (octal) and returns a database
handle which can be passed to the remaining functions.
.TP 4
\fBDBM_CLOSE\fP
closes the database file. \fBDBM_CLOSE\fP \fIMUST\fP
be called to ensure that all your data is written.
.TP 4
\fBDBM_STORE\fP
takes a database handle, key and datum strings, and a flag (either
\fBDBM_INSERT\fP to insert a new pair, or fail if the key already exists,
or \fBDBM_REPLACE\fP to insert or replace existing data).  The key and
datum strings may contain an arbitrary series of characters.
.TP 4
\fBDBM_FETCH\fP
returns the stored datum (if any) for the supplied key, or fails.
.TP 4
\fBDBM_DELETE\fP
deletes the stored datum (if any) for the supplied key, or fails.
.TP 4
\fBDBM_FIRSTKEY\fP
and subsequent calls to \fBDBM_NEXTKEY\fP
allow you to traverse all stored keys.  The keys will be returned in
arbitrary order, and the routines will fail at the end of the
traversal.
.TP 4
\fBDBM_ERROR\fP
is a predicate which succeeds if the database handle is valid
and an I/O error has occurred on the file.
.TP 4
\fBDBM_CLEARERR\fP
is a predicate which succeeds if if the database handle is valid, and has
the side effect of clearing the I/O error flag.
.SH "FILES"
.nh
NDBM, GDBM, and SDBM create two files: \fIfilename\fP.dir and \fIfilename\fP.pag.
Berkeley DB creates a single \fIfilename\fP.db file.
.SH "SEE ALSO"
.nh
\fBsnobol4sqlite3dbm\fP(3),
\fBndbm\fP(3),
\fBdbopen\fP(3),
\fBgdbm\fP(3).
.SH "AUTHOR"
.nh
Philip L. Budne
.SH "BUGS"
.nh
Not safe for concurrent read and write. The \fBsnobol4sqlite3dbm\fP(3)
interface achieves this portably using \fBsnobol4sqlite3\fP(3).
.PP
Some implementations (classic NDBM and SDBM) place limits on the total
size of key plus datum (typically slightly less than 1KB).
.PP
NOTE: Some implementations (classic NDBM and SDBM) create sparse files
which appear (to "ls -l") to be larger than they are (see "ls -s").
Copying such files may cause the non-allocated blocks to be "filled"
with zeroed disk blocks, and then the files really will be large!
.PP
Only GDBM provides locking to eliminate the possibility of file corruption,
or reading of incomplete data.
.PP
GDBM locking sometimes fails on NFS mounted partitions
but does not provide a way to disable locking.
.PP
DBM databases accessed concurrently by multiple processes are
traditionally (re)created from text files and used for fast disk-based
read-only table lookups.  Programs which need to update the file
generate a new temporary copy using a different name, and then rename
the new file(s), so that the next reader gets the new copies (existing
readers continue to see old data).
